
  <html lang="ko">
    <head>
      <meta charset="utf-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>What if Nx Plugins Were More Like VSCode Extensions</title>
      <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
      <script src="//unpkg.com/alpinejs" defer></script>
    </head>
    <body x-data="{ dark: false }" x-bind:data-theme="dark ? 'dark' : 'light'">
      <main class="container">
      	<button x-on:click="dark = !dark" class="contrast outline">Switch Theme</button>
	      <article>
	        <div id="readability-page-1" class="page"><div><div><a href="https://medium.com/@juristr?source=post_page-----dcdad140ae09--------------------------------" rel="noopener follow"><div aria-hidden="false"><p><img alt="Juri Strumpflohner" src="https://miro.medium.com/v2/resize:fill:88:88/1*s47HOlKyF5LEMdsNa6bGlw.png" width="44" height="44" loading="lazy" data-testid="authorPhoto"></p></div></a><a href="https://blog.nrwl.io/?source=post_page-----dcdad140ae09--------------------------------" rel="noopener  ugc nofollow"><div aria-hidden="false"><p><img alt="Nx Devtools" src="https://miro.medium.com/v2/resize:fill:48:48/1*WKgsSIGP_n6acei-mDWsOA.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto"></p></div></a></div><figure></figure><p id="db39"><strong>향상시키되</strong> 간섭하지 마세요! 이것이 바로 이상적입니다! 이것이 바로 VSCode(또는 웹스톰)에서 확장 프로그램이 작동하는 방식입니다. 확장 프로그램 없이 VSCode를 사용하여 기본 기능을 사용할 수도 있고, 확장 프로그램을 추가하여 사용 환경을 개선하고 생산성을 높일 수도 있습니다.</p><p id="f7f2"><strong>목차</strong></p><p id="e37c">- <a href="#0cc3" rel="noopener ugc nofollow">기존 모노레포에 Nx 추가하기</a><br>- <a href="#febc" rel="noopener ugc nofollow">프로젝트 크리스탈</a><br>- <a href="#c987" rel="noopener ugc nofollow">Nx 모노레포의 프로젝트 크리스탈 플러그인</a><br> ∘ <a href="#3c3c" rel="noopener ugc nofollow">추론된 타깃</a><br> ∘ 추론된 타깃 <a href="#3c30" rel="noopener ugc nofollow">시각화하기</a><br>- <a href="#3f24" rel="noopener ugc nofollow">투명성 향상 및 신뢰할 수 있는 단일 소스</a><br>- <a href="#8c50" rel="noopener ugc nofollow">Nx 플러그인으로 기존 모노레포 강화하기</a><br>- <a href="#e7b3" rel="noopener ugc nofollow">이것은 시작에 불과합니다</a><br>- <a href="#74cb" rel="noopener ugc nofollow">자세히</a> 알아보기</p></div><div><p id="0baf"><strong>동영상을 선호하시나요? 동영상이 준비되어 있습니다!</strong></p><figure></figure><p id="298a">또한 2월 8일(목)에 열리는 <a href="https://nx.dev/launch-nx" rel="noopener ugc nofollow" target="_blank">Launch Nx Conf에서</a> 프로젝트 크리스탈과 Nx 및 Nx 클라우드의 다른 흥미로운 기능에 대해 더 깊이 있는 이야기를 나눌 예정이니 꼭 확인해 보세요.</p></div><div><p id="da7b">예를 들어 Playwright 플러그인을 살펴보겠습니다. 이 플러그인을 설치하면 자동으로 Playwright 구성 파일을 감지하고 테스트와 함께 빠른 실행 버튼이나 전용 테스트 탐색기 창을 제공하여 작업 공간을 향상시킵니다.</p><figure><figcaption>개발자 경험을 향상시키는 Playwright VSCode 확장 기능</figcaption></figure><h2 id="0cc3">기존 모노레포에 Nx 추가하기</h2><p id="fc1d">기존 npm/yarn/pnpm 모노레포에 Nx를 아주 간단하게 추가할 수 있습니다. 다음을 실행합니다.</p><pre translate="no"><span id="be1e">npx nx@latest init</span></pre><p id="8685"><code translate="no">nx</code> 패키지가 설치되고 <code translate="no">nx.json</code> 에서 <a href="https://nx.dev/recipes/running-tasks/defining-task-pipeline" rel="noopener ugc nofollow" target="_blank">작업 종속성</a> 및 캐싱을 정의할 수 있습니다. 이제 <code translate="no">nx build &lt;your project&gt;</code> 또는 <code translate="no">nx run-many -t build test</code> 같은 명령을 실행하여 작업 공간의 모든 <code translate="no">build</code> 및 <code translate="no">test</code> 대상을 병렬로 실행할 수 있습니다. Nx는 기존 <code translate="no">package.json</code> 스크립트를 읽고 사용합니다. <a href="https://dev.to/nx/setup-a-monorepo-with-pnpm-workspaces-and-speed-it-up-with-nx-1eem" rel="noopener ugc nofollow" target="_blank">이러한 시나리오에서 Nx를 채택하는</a> 방법에 대한 심층적인 <a href="https://dev.to/nx/setup-a-monorepo-with-pnpm-workspaces-and-speed-it-up-with-nx-1eem" rel="noopener ugc nofollow" target="_blank">블로그 게시물을</a> 작성했습니다.</p><p id="fa86">이 설정은 가장 가벼운 설정이면서 Nx를 통해 더 빠른 작업 실행과 더 지능적인 병렬화에 관한 몇 가지 개선 사항을 얻을 수 있습니다. 하지만 모노레포 설정의 나머지 부분을 처리해야 합니다.</p><h2 id="febc">프로젝트 크리스탈</h2><p id="1374">Nx는 항상 더 많은 기능을 제공했지만 주로 플러그인을 통해 제공했습니다. 플러그인은 선택 사항이지만 일반적으로 새 작업 공간을 만들 때 설정하게 됩니다. <code translate="no">create-nx-workspace.</code> Nx 플러그인은 매우 강력하여 새로운 모노레포를 만들고 구성하는 데 도움이 될 뿐만 아니라 다양한 툴을 통합해야 하는 부담을 덜어줄 뿐만 아니라 일관성을 강화하고 유지보수에 도움이 되는 기능을 제공합니다. 이러한 측면은 Nx 플러그인이 팀이 모노포스트를 성공적으로 관리하는 데 도움이 되는 것으로 입증된 엔터프라이즈 환경에서 기본이 되는 요소입니다.</p><p id="cbf4">하지만 균형을 잡아야 합니다. 더 많은 추상화와 자동화는 더 많은 지원을 의미하지만, 잠재적으로 학습 곡선이 필요하고 일부 낮은 수준의 제어를 포기해야 할 수도 있습니다. 또한 Nx 플러그인 기반 모노레포로 마이그레이션할 때는 초기 투자 비용이 약간 더 필요합니다.</p><p id="17f2"><strong>이러한 문제를 해결하고 싶었고</strong>, <strong>프로젝트 크리스탈은</strong> 그 첫 번째 단계입니다.</p><figure></figure><p id="1828">프로젝트 크리스탈의 주요 목표는 다음과 같습니다.</p><ul><li id="d8e9">Nx 플러그인을 더 투명하게 만들기</li><li id="ac91">필요한 구성의 양을 줄입니다.</li><li id="7ad4">Nx 플러그인이 기존 npm/yarn/pnpm 모노포지션에서 드롭인 방식으로 개선될 수 있도록 허용합니다.</li><li id="7745">Nx 플러그인 기반 모노레포로의 마이그레이션 허용</li></ul><h2 id="c987">Nx 모노레포의 프로젝트 크리스탈 플러그인</h2><blockquote><p id="95a3"><em>참고로, Nx 18부터는 새 워크스페이스에서만 프로젝트 크리스탈이 활성화됩니다. 하지만 플러그인을 사용하도록 선택할 수 있습니다.</em></p></blockquote><p id="5493">다음을 사용해 새 Nx 작업 공간을 만들 때</p><pre translate="no"><span id="7473">npx create-nx-workspace myorg</span></pre><p id="e118">를 사용하여 새 Nx 작업 공간을 만들고 "통합 모노레포"를 선택하면 Nx 플러그인으로 구동되는 일반적인 설정과 함께 제공되는 모든 기능 및 이점을 사용할 수 있습니다. 프로젝트 크리스탈이 실제로 작동하는 것을 볼 수 있는 곳은 <code translate="no">project.json</code> 파일을 열 때이며, 대부분 다음과 같이 보일 것입니다:</p><pre translate="no"><span id="60d2">{<br>  "name": "reactapp",<br>  "$schema": "../../node_modules/nx/schemas/project-schema.json",<br>  "sourceRoot": "apps/reactapp/src",<br>  "projectType": "application",<br>  "targets": {},<br>  "tags": []<br>}</span></pre><h2 id="3c3c">추론된 타깃</h2><p id="f357">Nx 18 및 Project Crystal부터는 더 이상 타깃을 생성하지 않고 해당 Nx 플러그인이 대신 <a href="https://nx.dev/concepts/inferred-tasks" rel="noopener ugc nofollow" target="_blank"><strong>타깃을 추</strong></a>론합니다. <code translate="no">nx.json</code> 을 열면 새 속성인 <code translate="no">plugins</code> 이 표시됩니다:</p><pre translate="no"><span id="10b4">{<br>  ...<br>  "plugins": [<br>    {<br>      "plugin": "@nx/vite/plugin",<br>      "options": {<br>        "buildTargetName": "build",<br>        "previewTargetName": "preview",<br>        "testTargetName": "test",<br>        "serveTargetName": "serve",<br>        "serveStaticTargetName": "serve-static"<br>      }<br>    },<br>    {<br>      "plugin": "@nx/eslint/plugin",<br>      "options": {<br>        "targetName": "lint"<br>      }<br>    },<br>    {<br>      "plugin": "@nx/cypress/plugin",<br>      "options": {<br>        "targetName": "e2e",<br>        "componentTestingTargetName": "component-test"<br>      }<br>    },<br>    ...<br>  ],<br>  ...<br>}</span></pre><p id="64f4">각 플러그인에 대해 잠재적으로 유추할 수 있는 대상의 이름을 정의하는 <code translate="no">options</code> 속성을 주목하세요. 이러한 타겟은 동적으로 생성되므로 <code translate="no">apps/reactapp</code> 프로젝트의 <code translate="no">project.json</code> 에 명시적으로 정의된 <code translate="no">build</code> 타겟이 없더라도 <code translate="no">nx build reactapp</code> 을 실행할 수 있습니다.</p><p id="8d28">이렇게 하면 여러 프로젝트에서 동일한 작업(예: Jest 또는 Vitest 작업)을 반복적으로 구성하는 데 따른 중복이 크게 줄어듭니다. 대신, 이 새로운 접근 방식에서는 기본값이 제공되며, 기본값을 재정의해야 하는 경우 이전처럼 <code translate="no">project.json</code> 파일에서 정의할 수 있습니다.</p><h2 id="3c30">추론된 타겟 시각화</h2><p id="bf0b">동적으로 추론된 타겟은 유지보수 측면에 도움이 되고 전반적인 구성 오버헤드를 줄여줍니다. 하지만 특정 프로젝트에 어떤 대상을 사용할 수 있는지 어떻게 알 수 있을까요?</p><p id="ceae">옵션 1은 다음 명령을 실행하는 것입니다:</p><pre translate="no"><span id="4367">npx nx show project reactapp --web</span></pre><p id="dcbf">그러면 다음과 같은 보기로 브라우저가 열립니다:</p><figure><figcaption>추론된 타겟의 브라우저 보기</figcaption></figure><p id="bee5">옵션 2는 VSCode 및 IntelliJ(웹스톰 등)를 위한 확장 프로그램인 <a href="https://nx.dev/features/integrate-with-editors" rel="noopener ugc nofollow" target="_blank">Nx Console입니다</a>. 아래 그림과 같이 프로젝트 세부 정보 보기와 컨텍스트 기반 정보 및 기능으로 구성 파일을 향상시키는 "Codelens" 기능이 함께 제공됩니다.</p><figure><figcaption>전용 보기에 추론된 타깃을 표시하는 Nx 콘솔</figcaption></figure><h2 id="3f24">투명성 향상 및 신뢰할 수 있는 단일 소스</h2><p id="0af4">또한 플러그인에 대한 새로운 접근 방식이 사용 중인 프레임워크의 실제 CLI 도구에 더 가까워지기를 원했습니다. React + Vite 프로젝트가 있는 경우 <code translate="no">nx build</code> 은 캐싱 구성과 관련된 향상된 기능을 제공하면서 <code translate="no">vite build</code> 에 최대한 가깝게 만들어야 합니다.</p><p id="1699">그리고 이것이 일어납니다. 뒤에서 플러그인은 입출력과 태스크 종속성(예: <code translate="no">^build</code>)으로 캐싱을 구성하지만, 대부분 Vite CLI(이 경우에는), Remix, Next CLI 등으로 파이프됩니다.</p><figure></figure><p id="be87">또한 프레임워크별 구성(Vite의 예에서 <code translate="no">vite.config.ts</code> )은 Nx가 캐싱과 같은 구성을 유추하는 단일 소스입니다. Vite <code translate="no">build.outDir</code> 를 변경하면 Nx가 자동으로 이를 선택하여 캐싱 출력 디렉토리로 사용합니다.</p><h2 id="8c50">Nx 플러그인으로 기존 모노레포스를 개선하기</h2><p id="bfcb">앞서 언급했듯이 프로젝트 크리스탈의 주요 목표 중 하나는 Nx 플러그인의 채택 사례를 개선하는 것이었으며, 이는 암묵적으로 Nx 플러그인 기반 모노레포스로 마이그레이션하는 데도 도움이 됩니다. Nx 플러그인의 구성 공간을 줄이고 기존 프레임워크 구성에서 작업을 자동으로 추론함으로써 플러그인을 훨씬 더 드롭인 방식으로 사용하는 방향으로 나아갔습니다.</p><p id="38b2">Nx 18부터는 기존 npm/yarn/pnpm 작업 영역에서 <code translate="no">nx init</code> 을 실행하면 모노레포에 있는 설정을 기반으로 플러그인을 설치할지 묻는 메시지가 표시됩니다.</p><figure><figcaption>모노레포 도구에 기반한 플러그인 설치에 대해 묻는 메시지 표시</figcaption></figure><p id="2549">물론 플러그인을 전혀 설치하지 않은 상태에서 시작하여 새로운 <code translate="no">add</code> 명령어를 사용하는 데 익숙해지면 점차적으로 플러그인을 추가할 수도 있습니다:</p><pre translate="no"><span id="76f2">npx nx add @nx/vite</span></pre><h2 id="e7b3">이것은 시작에 불과합니다</h2><p id="97d3">이제 막 프로젝트 크리스탈을 출시했으니 이제 시작에 불과합니다. 기존 Nx 플러그인 중 상당수가 새로운 접근 방식을 채택하도록 변경되었지만 앞으로 몇 주 동안 더 개선해야 할 부분이 남아 있습니다. 하지만 프로젝트 크리스털을 통해 Nx 플러그인을 더욱 접근하기 쉽고, 투명하며, 가볍게 만들 수 있는 가능성과 앞으로의 도입 사례에 대해 기대가 큽니다.</p></div></div>
	      </article>
			</main>
    </body>
  </html>
  