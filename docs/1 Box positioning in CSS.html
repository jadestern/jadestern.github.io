
  <html lang="ko">
    <head>
      <meta charset="utf-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>1. Box positioning in CSS</title>
      <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
      <script src="//unpkg.com/alpinejs" defer></script>
    </head>
    <body x-data="{ dark: false }" x-bind:data-theme="dark ? 'dark' : 'light'">
      <main class="container">
      	<button x-on:click="dark = !dark" class="contrast outline">Switch Theme</button>
	      <article>
	        <div id="readability-page-1" class="page"><div id="wrapper">
<p>CSS 레이아웃의 핵심은 HTML 요소 집합을 x축, y축 및 z축에 배치할 수 있는 직사각형 상자 집합에 매핑하는 것입니다.</p>
<p>이러한 상자의 x축 및 y축 위치는 상자에 적용되는 위치 지정 체계에 따라 결정됩니다. 이 장에서는 CSS 2.1에 도입된 위치 지정 체계인 일반 흐름, 플로트 및 절대 위치 지정에 대해 다룹니다.</p>
<p>개념적으로 CSS 레이아웃의 가장 높은 수준의 추상화는 위치 지정 체계입니다. 위치 지정 체계가 결정되면 <code translate="no">display: table</code> 또는 <code translate="no">display: inline-table</code> 과 같은 특정 레이아웃 모드를 통해 추가로 수정할 수 있습니다. 플렉스박스 및 그리드와 같은 레이아웃 모드를 도입한 CSS 3 확장 기능도 여전히 주요 위치 지정 체계 중 하나(예: <code translate="no">display: flex</code> 대 <code translate="no">display: inline-flex</code>) 내에 존재합니다.</p>
<h2 id="positioning-schemes"><a href="#positioning-schemes"></a>포지셔닝 체계</h2>
<p>CSS 2.1은 세 가지 위치 지정 체계를 정의합니다:</p>
<ul>
<li>일반 흐름: 블록, 인라인 및 상대 서식 컨텍스트의 세 가지 서식 컨텍스트로 구성됩니다.</li>
<li>플로트는 자체 방식으로 일반 흐름과 상호 작용하고 대부분의 최신 CSS 그리드 프레임 워크의 기초를 형성합니다.</li>
<li>절대 위치 지정 - 일반 흐름과 관련된 절대 및 고정 요소를 처리합니다.</li>
</ul>
<p>위치 지정 체계는 요소의 x축 및 y축 위치에 많은 영향을 미칩니다. <a href="http://www.w3.org/TR/CSS2/visuren.html#dis-pos-flo">CSS 2.1 사양의</a> 섹션 <a href="http://www.w3.org/TR/CSS2/visuren.html#dis-pos-flo">9.3에서는</a> 이 세 가지 속성 간의 상호 작용에 대해 설명하지만, 간단히 요약하면 일반적으로 <code translate="no">float</code> 속성 또는 <code translate="no">position</code> 속성을 설정하여 일반 흐름에서 특별히 제거하지 않는 한 모든 요소는 기본적으로 일반 흐름에 속한다는 것입니다.</p>
<table>
<thead>
<tr>
<th>속성</th>
<th>기본값</th>
<th>목적</th>
</tr>
</thead>
<tbody>
<tr>
<td>표시</td>
<td>블록 또는 인라인</td>
<td>사용할 레이아웃 알고리즘을 결정합니다.</td>
</tr>
<tr>
<td>위치</td>
<td>정적</td>
<td>요소의 위치를 제어합니다.</td>
</tr>
<tr>
<td>float</td>
<td>none</td>
<td>요소 주위에 다른 요소가 떠다니도록 허용합니다.</td>
</tr>
</tbody>
</table>
<p>플로트와 절대 위치 지정은 모두 일반 흐름과 상호 작용하는 방식을 통해 가장 잘 이해할 수 있으므로 일반 흐름 위치 지정 방식을 먼저 다루겠습니다.</p>
<p>생각해 보면 레이아웃에는 실제로 두 가지 측면이 작용합니다:</p>
<ul>
<li>요소의 상자 크기와 정렬 방식, 이는 주로 <code translate="no">display</code> 속성(및 <code translate="no">width</code>, <code translate="no">height</code> 및 <code translate="no">margin</code>)에 의해 제어됩니다.</li>
<li>특정 부모 요소 내의 요소가 서로에 대해 상대적으로 배치되는 방식입니다.</li>
</ul>
<p>이 장에서는 후자의 측면인 상대적 위치 지정에 초점을 맞추겠습니다. 다음 장에서는 정렬과 크기를 결정하는 상자 모델을 다룹니다.</p>
<p>부모 요소 내의 요소의 상대적 위치는 특정 부모 요소의 모든 바로 아래 자식 요소에 대해 설정된 서식 컨텍스트에 의해 제어되며, 일반적인 흐름에서는 <code translate="no">block</code> 또는 <code translate="no">inline</code> 서식 컨텍스트가 될 수 있습니다.</p>
<p>CSS 2.1 사양에서 서식 컨텍스트에 대해 설명하는 내용은 다음과 같습니다:</p>
<blockquote>
<p>일반 흐름의 상자는 블록 또는 인라인일 수 있는 서식 컨텍스트에 속하지만 동시에 둘 다일 수는 없습니다. 블록 수준 상자는 블록 서식 지정 컨텍스트에 참여합니다. 인라인 수준 상자는 인라인 서식 지정 컨텍스트에 참여합니다. <a href="http://www.w3.org/TR/CSS2/visuren.html#normal-flow">소스</a></p>
</blockquote>
<p>부모(컨테이너)는 자식 상자가 인라인 수준인지 블록 수준인지에 따라 자식에 대한 서식 컨텍스트를 설정합니다. 인라인 수준 및 블록 수준이라는 용어는 <code translate="no">inline</code> 또는 <code translate="no">block</code> 이외의 <code translate="no">display</code> 속성을 가진 블록이 일반 흐름 내에서 두 서식 컨텍스트 중 하나에 매핑된다는 점을 강조하기 위해 정의되었습니다. 예를 들어 <code translate="no">display: table</code> 요소는 블록 수준으로 간주되고 <code translate="no">display: inline-table</code> 요소는 인라인 수준으로 간주됩니다.</p>
<p>블록 수준 요소는 다음과 같이 정의됩니다:</p>
<blockquote>
<p>블록 수준 요소는 시각적으로 블록(예: 단락)으로 형식이 지정된 소스 문서의 요소입니다. 'display' 속성의 다음 값은 요소를 블록 수준으로 만듭니다: '블록', '목록 항목' 및 '표'.</p>
<p>블록 수준 상자는 블록 서식 지정 컨텍스트에 참여하는 상자입니다. 각 블록 수준 요소는 하위 상자와 생성된 콘텐츠를 포함하는 기본 블록 수준 상자를 생성하며 모든 위치 지정 체계에 관여하는 상자이기도 합니다. 일부 블록 수준 요소는 기본 상자(예: '목록 항목' 요소) 외에 추가 상자를 생성할 수 있습니다. 이러한 추가 상자는 기본 상자를 기준으로 배치됩니다.</p>
</blockquote>
<p>거의 모든 블록 수준 상자는 블록 컨테이너 상자이기도 합니다. 블록 컨테이너 상자는 단순히 다른 상자 집합의 부모이며 특정 서식 컨텍스트가 있습니다:</p>
<blockquote>
<p>표 상자 [...]와 대체된 요소를 제외하고 블록 수준 상자도 블록 컨테이너 상자입니다. 블록 컨테이너 상자는 블록 수준 상자만 포함하거나 인라인 서식 컨텍스트를 설정하므로 인라인 수준 상자만 포함합니다. <a href="http://www.w3.org/TR/CSS2/visuren.html#block-level">소스</a></p>
</blockquote>
<p>그리고 인라인 수준 요소는 다음과 같이 정의됩니다:</p>
<blockquote>
<p>인라인 수준 요소는 소스 문서에서 새로운 콘텐츠 블록을 형성하지 않고 콘텐츠가 줄 단위로 배포되는 요소입니다(예: 단락 내의 강조된 텍스트 부분, 인라인 이미지 등). 'display' 속성의 다음 값은 요소를 인라인-레벨로 만듭니다: 'inline', 'inline-table', 'inline-block'. 인라인 수준 요소는 인라인 수준 상자, 즉 인라인 서식 지정 컨텍스트에 참여하는 상자를 생성합니다.</p>
<p>인라인 수준 상자는 인라인 수준인 동시에 포함된 인라인 서식 지정 컨텍스트에 참여하는 상자입니다. '표시' 값이 '인라인'인 대체되지 않은 요소는 인라인 상자를 생성합니다. 인라인 상자가 아닌 인라인 수준 상자(예: 대체된 인라인 수준 요소, 인라인 블록 요소 및 인라인 테이블 요소)는 인라인 서식 지정 컨텍스트에 하나의 불투명한 상자로 참여하므로 원자 인라인 수준 상자라고 합니다. <a href="http://www.w3.org/TR/CSS2/visuren.html#inline-level">출처</a></p>
</blockquote>
<p>대체된 요소와 대체되지 않은 요소는 아주 사소한 구분이므로 여기서는 다루지 않겠습니다. 대체된 요소에 대해 생각하는 가장 쉬운 방법은 <code translate="no">img</code> 또는 <code translate="no">video</code> 요소, 즉 텍스트 콘텐츠처럼 줄로 나눌 수 없는 단일(외부에서 정의된) 콘텐츠만 있는 요소를 생각하면 됩니다.</p>
<p>일반적인 흐름에서 두 가지 서식 지정 컨텍스트는 대략 수직 스택(블록 서식 지정 컨텍스트에 있는 경우)과 수평 스택(인라인 서식 지정 컨텍스트에 있는 경우)에 해당한다고 생각할 수 있습니다. 잠시 후에 두 가지를 모두 다루겠습니다.</p>
<p>위의 정의에서 흥미로운 점은 모든 상자의 서식 컨텍스트가 "인라인 서식 컨텍스트" 또는 "블록 서식 컨텍스트"여야 한다는 것입니다. 즉, 모든 자식 요소는 각 부모 요소에 대해 한 가지 유형의 서식 컨텍스트를 사용하여 배치됩니다. DIV와 같은 블록 수준 콘텐츠와 텍스트와 같은 인라인 수준 콘텐츠를 명확하게 혼합할 수 있는데 어떻게 그럴 수 있을까요? 답은 인라인 수준 요소를 블록 수준 요소로 승격할 수 있는 메커니즘이 있다는 것입니다. 이 메커니즘을 익명 상자 생성이라고 합니다.</p>
<h2 id="anonymous-box-generation"><a href="#anonymous-box-generation"></a>익명 상자 생성</h2>
<p>익명 상자 생성은 부모 요소에 인라인 수준과 블록 수준 자식 요소가 혼합되어 있는 경우(이 경우 "익명 블록 상자"가 생성됨)와 마크업에 인라인 수준 요소가 주변 텍스트와 혼합되어 있는 경우(이 경우 "익명 인라인 상자"가 생성됨)를 처리하는 데 사용됩니다(텍스트 단락 안에 <code translate="no">em</code> 또는 <code translate="no">i</code> 태그가 있는 경우 등)를 예로 들 수 있습니다.</p>
<h3 id="anonymous-block-boxes"><a href="#anonymous-block-boxes"></a>익명 블록 상자</h3>
<p><a href="http://www.w3.org/TR/CSS2/visuren.html#anonymous-block-level">사양에는</a> 익명 블록 상자 생성의 예가 나와 있습니다:</p>
<pre translate="no"><code translate="no"><span>&lt;<span>div</span>&gt;</span>
    Some text
    <span>&lt;<span>p</span>&gt;</span>More text
<span>&lt;/<span>p</span>&gt;</span><span>&lt;/<span>div</span>&gt;</span></code></pre><p>그리고 다음과 같이 명시되어 있습니다:</p>
<blockquote>
<p>블록 컨테이너 상자(예: 위의 DIV에 대해 생성된 상자)에 블록 수준 상자(예: 위의 P)가 있는 경우 내부에 블록 수준 상자만 포함하도록 강제합니다.</p>
</blockquote>
<p>예를 들어, 사양은 예제 코드가 인라인 수준 콘텐츠를 래핑하는 익명 상자를 생성하는 방법을 다음 그림과 같이 제공합니다:</p>
<p><img src="https://book.mixu.net/css/img/anon-block.png" alt="spec"></p>
<blockquote>
<p>인라인 상자에 흐름 내 블록 수준 상자가 포함된 경우 인라인 상자(및 동일한 줄 상자 내의 인라인 상위 상자)는 블록 수준 상자(및 접을 수 있는 공백 및/또는 흐름 외 요소로만 연속되거나 구분되는 모든 블록 수준 형제자매)를 중심으로 분할되어 인라인 상자를 블록 수준 상자 양쪽에 하나씩 두 개의 상자(어느 쪽이 비어 있어도)로 나눕니다. 나누기 전과 나누기 후의 인라인 상자는 익명 블록 상자로 묶이고 블록 수준 상자는 이러한 익명 상자의 형제 상자가 됩니다. 이러한 인라인 상자가 상대 위치의 영향을 받는 경우, 그 결과로 발생하는 모든 번역은 인라인 상자에 포함된 블록 수준 상자에도 영향을 미칩니다.</p>
</blockquote>
<p>즉, 인라인 수준 상자와 블록 수준 상자가 하나의 부모 요소에 혼합되어 있는 경우 인라인 수준 상자는 블록 수준 상자 주위로 분할되고 인라인 수준 상자 콘텐츠는 익명 블록 수준 상자로 둘러싸입니다.</p>
<h3 id="anonymous-inline-boxes"><a href="#anonymous-inline-boxes"></a>익명 인라인 상자</h3>
<p>익명 인라인 상자는 블록 컨테이너 요소에 인라인 수준 요소로 묶이지 않은 텍스트가 포함된 경우 생성됩니다. 예를 들어, 마크업:</p>
<pre translate="no"><code translate="no"><span>&lt;<span>p</span>&gt;</span>Some <span>&lt;<span>em</span>&gt;</span>emphasized<span>&lt;/<span>em</span>&gt;</span> text<span>&lt;/<span>p</span>&gt;</span></code></pre><p>마크업은 두 개의 익명 인라인 상자, 즉 "일부"와 "텍스트"를 위한 상자를 생성합니다.</p>
<p>익명 상자 생성은 블록 및 인라인 수준의 형제 요소가 모두 있는 일반 흐름의 요소에 대한 서식 컨텍스트를 결정하기 때문에 중요합니다. 많은 실제 HTML 레이아웃은 단일 부모 요소에 블록 수준 콘텐츠와 인라인 수준 콘텐츠가 모두 있습니다. 익명 상자 생성을 사용하면 블록 수준 콘텐츠가 인라인 수준 형제와 혼합되어 있는 경우 레이아웃을 위해 인라인 수준 상자를 익명 블록 수준 컨테이너로 감싸서 마치 블록 수준 상자처럼 다른 상자에 대해 상대적으로 레이아웃을 지정할 수 있습니다.</p>
<p>이제 서식 컨텍스트가 어떻게 결정되는지 알았으니 레이아웃이 어떻게 수행되는지 살펴보겠습니다.</p>
<h2 id="normal-flow-positioning"><a href="#normal-flow-positioning"></a>일반 흐름 위치 지정</h2>
<p>일반 흐름에서는 특정 부모 상자에 포함된 상자(요소)가 서식 컨텍스트에 따라 배치됩니다. 일반 흐름의 두 가지 서식 컨텍스트는 대략 수직 스태킹과 수평 스태킹에 해당합니다.</p>
<h3 id="normal-flow-block-formatting"><a href="#normal-flow-block-formatting"></a>일반 흐름: 블록 서식 지정</h3>
<p>이 사양은 블록 서식 지정 컨텍스트에서 레이아웃이 어떻게 작동하는지에 대해 매우 잘 설명합니다:</p>
<blockquote>
<p>블록 서식 지정 컨텍스트에서 상자는 포함 블록의 상단부터 시작하여 수직으로 차례로 배치됩니다. 두 형제 상자 사이의 수직 거리는 '여백' 속성에 의해 결정됩니다. 블록 서식 지정 컨텍스트에서 인접한 블록 수준 상자 사이의 세로 여백은 접힙니다.</p>
<p>블록 서식 지정 컨텍스트에서 각 상자의 왼쪽 바깥쪽 가장자리는 포함 블록의 왼쪽 가장자리에 닿습니다(오른쪽에서 왼쪽 서식 지정의 경우 오른쪽 가장자리가 닿음). 이는 상자가 새로운 블록 서식 컨텍스트를 설정하지 않는 한 플로트가 있는 경우에도 마찬가지입니다(플로트로 인해 상자의 선 상자가 줄어들 수 있음).</p>
</blockquote>
<p>가장 중요한 두 가지 사항은 상자 서식 지정 컨텍스트에서 상자가 세로로 배치된다는 것과 모든 상자의 왼쪽 바깥쪽 가장자리가 포함된 블록의 왼쪽 바깥쪽 가장자리에 닿는다는 것입니다(플로트가 있는 경우에도).</p>
<p>아래 코드 예시는 이러한 규칙 중 일부를 보여줍니다:</p>
<div><div><pre translate="no"><code translate="no"><span>.float</span> <span>{
  <span><span>float</span>:<span> left</span></span>;
}</span>
<span>.foo</span> <span>{
  <span><span>padding-top</span>:<span> <span>10px</span></span></span>;
}</span>
<span>.bar</span> <span>{
  <span><span>width</span>:<span> <span>30%</span></span></span>;
}</span>
<span>.baz</span> <span>{
  <span><span>width</span>:<span> <span>40%</span></span></span>;
}</span>
</code></pre></div><div><pre translate="no"><code translate="no"><span>&lt;<span>div</span> <span>class</span>=<span>"container violet"</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"float red"</span>&gt;</span>float<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"foo blue"</span>&gt;</span>foo<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"bar green"</span>&gt;</span>bar<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"baz orange"</span>&gt;</span>baz<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
</code></pre></div></div><p>위의 예시에서는</p>
<ul>
<li>모든 블록 상자는 포함 블록의 왼쪽 바깥쪽 가장자리에 있습니다.</li>
<li>플로트의 존재는 텍스트를 오프셋하는 것을 제외하고는 왼쪽 바깥쪽 가장자리의 위치(사양에 따라)에 어떤 영향도 미치지 않습니다.</li>
<li>너비가 설정되지 않은 블록 상자 <code translate="no">foo</code> 는 전체 컨테이너 너비로 확장됩니다.</li>
<li>너비가 설정된 다른 두 상자는 컨테이너의 왼쪽 가장자리에서 확장됩니다.</li>
<li>다른 두 상자는 예를 들어 한 행에 맞지만 어떤 방식으로도 이동되지 않습니다.</li>
</ul>
<p>전반적으로 블록 서식 지정 컨텍스트는 매우 규칙적이며 몇 개의 단락으로 설명할 수 있습니다. 하지만 인라인 서식 지정 컨텍스트는 그렇지 않습니다.</p>
<h3 id="normal-flow-inline-formatting"><a href="#normal-flow-inline-formatting"></a>일반 흐름: 인라인 서식 지정</h3>
<p>인라인 서식 컨텍스트는 마크업에서 직접 보이지 않고 콘텐츠 레이아웃을 기반으로 생성되는 또 다른 구조인 <em>줄 상자로</em> 콘텐츠를 나누기 때문에 조금 더 복잡합니다:</p>
<blockquote>
<p>인라인 서식 지정 컨텍스트에서 상자는 포함 블록의 상단부터 차례로 가로로 배치됩니다. 이러한 상자 사이에는 가로 여백, 테두리 및 패딩이 적용됩니다.</p>
<p>상자는 아래쪽 또는 위쪽을 정렬하거나 상자 안의 텍스트 기준선을 정렬하는 등 다양한 방식으로 세로로 정렬할 수 있습니다. 선을 형성하는 상자가 포함된 직사각형 영역을 선 <a href="http://www.w3.org/TR/CSS2/visuren.html#inline-formatting">상자라고</a> 합니다.</p>
<p>선 상자의 너비는 포함하는 블록과 플로트의 존재 여부에 따라 결정됩니다. 선 상자의 높이는 선 높이 계산 섹션에 제공된 규칙에 따라 결정됩니다.</p>
</blockquote>
<p>즉, 인라인 서식 지정 컨텍스트 내에서 컨텍스트 상자는 하나 이상의 선 상자에 가로로 배치됩니다. 선 상자는 필요에 따라 생성되며, 너비는 일반적으로 포함된 블록의 너비(플로트 빼기)이고 높이는 항상 포함된 모든 상자에 대해 충분합니다. 구체적으로</p>
<blockquote>
<p>선 상자는 항상 그 안에 포함된 모든 상자에 대해 충분한 높이입니다. [...] 여러 개의 인라인 수준 상자가 하나의 선 상자 안에 가로로 들어갈 수 없는 경우 세로로 쌓인 두 개 이상의 선 상자에 분산됩니다. 따라서 단락은 선 상자의 수직 스택입니다. 선 상자는 다른 곳에 지정된 경우를 제외하고 수직으로 구분되지 않고 겹치지 않게 쌓입니다.</p>
<p>일반적으로 선 상자의 왼쪽 가장자리는 포함된 블록의 왼쪽 가장자리에 닿고 오른쪽 가장자리는 포함된 블록의 오른쪽 가장자리에 닿습니다. 플로트로 인해 사용 가능한 가로 공간이 줄어들면 [선 상자]의 너비가 달라질 수 있습니다. 동일한 인라인 서식 컨텍스트에 있는 줄 상자는 일반적으로 높이가 다릅니다(예: 한 줄에는 긴 이미지가 포함되고 다른 줄에는 텍스트만 포함될 수 있음).</p>
</blockquote>
<p>인라인 상자가 줄 상자에 비해 너무 크면 어떻게 되나요? 인라인 상자가 대체되는 항목(예: 동영상 또는 이미지)인지 대체되지 않는 항목(텍스트 등)인지에 따라 달라집니다:</p>
<blockquote>
<p>인라인 상자가 선 상자의 너비를 초과하면 여러 개의 상자로 분할되고 이러한 상자는 여러 개의 선 상자에 걸쳐 분산됩니다. 인라인 상자를 분할할 수 없는 경우 [...]는 인라인 상자가 선 상자를 넘기게 됩니다.</p>
<p>인라인 상자가 분할되면 여백, 테두리 및 패딩은 분할이 발생하는 위치(또는 분할이 여러 개 있는 경우 모든 분할 위치)에 시각적 효과가 없습니다.</p>
</blockquote>
<p>즉, 인라인 상자가 선 상자의 너비를 초과하는 경우 가능한 경우 분할됩니다. 규칙에 따라 상자 분할이 허용되지 않는 경우에는 단순히 선 상자를 가로로 넘기게 됩니다.</p>
<p>인라인 서식 지정 컨텍스트에서 가장 복잡한 측면은 줄 상자 내에서 정렬이 작동하는 방식일 것입니다. <code translate="no">text-align</code> 및 <code translate="no">vertical-align</code> 두 가지 속성이 정렬을 제어합니다.</p>
<h3 id="horizontal-alignment-within-line-boxes-text-align-"><a href="#horizontal-alignment-within-line-boxes-text-align-"></a>줄 상자 내 가로 맞춤: <code translate="no">text-align</code></h3>
<p><code translate="no">text-align</code> 속성은 줄 상자에서 인라인 수준 상자가 배치되는 방식을 제어합니다.</p>
<table>
<thead>
<tr>
<th>속성</th>
<th>기본값</th>
<th>목적</th>
</tr>
</thead>
<tbody>
<tr>
<td>text-align</td>
<td>'방향'이 'ltr'인 경우 '왼쪽', '방향'이 'rtl'인 경우 '오른쪽' 역할을 하는 이름 없는 값입니다.</td>
<td>블록 컨테이너의 인라인 수준 콘텐츠가 정렬되는 방식을 설명합니다.</td>
</tr>
</tbody>
</table>
<p>줄 상자에 사용되지 않은 공간이 있는 경우에만 적용되며, 인라인 수준 콘텐츠가 줄 상자에 배치되는 방식을 직접 제어할 수는 없습니다. 사양에는 다음과 같이 명시되어 있습니다:</p>
<blockquote>
<p>한 줄에 있는 인라인 수준 상자의 전체 너비가 해당 상자가 포함된 줄 상자의 너비보다 작은 경우 줄 상자 내의 가로 분포는 '텍스트 정렬' 속성에 의해 결정됩니다. 해당 속성의 값이 'justify'인 경우 사용자 에이전트는 인라인 상자(인라인 테이블 및 인라인 블록 상자 제외)에서도 공백과 단어를 늘릴 수 있습니다.</p>
</blockquote>
<p>즉, 텍스트 정렬 속성은 인라인 콘텐츠가 줄 상자에 분산된 후에 적용됩니다.</p>
<blockquote>
<p>텍스트 블록은 줄 상자의 스택입니다. '왼쪽', '오른쪽' 및 '가운데'의 경우 이 속성은 각 줄 상자 내의 인라인 수준 상자가 줄 상자의 왼쪽과 오른쪽을 기준으로 정렬되는 방식을 지정하며, 뷰포트를 기준으로 정렬되지 않습니다. '맞춤'의 경우 이 속성은 인라인 상자의 내용을 확장하거나 축소하여 가능하면 인라인 수준 상자를 선 상자의 양쪽과 같은 높이로 만들고, 그렇지 않으면 초기 값대로 정렬하도록 지정합니다. ('문자 간격' 및 '단어 간격'도 참조하세요.) <a href="http://www.w3.org/TR/2011/REC-CSS2-20110607/text.html#alignment-prop">출처</a></p>
</blockquote>
<p>일반적으로 공백(공백, 탭 등)은 정당화의 영향을 받을 수 있습니다. 하지만</p>
<blockquote>
<p>요소의 '공백'에 대한 계산된 값이 'pre' 또는 'pre-wrap'인 경우, 해당 요소의 텍스트 콘텐츠의 글리프나 공백은 정당화를 위해 변경할 수 없습니다.</p>
</blockquote>
<h3 id="vertical-alignment-within-line-boxes-vertical-align-"><a href="#vertical-alignment-within-line-boxes-vertical-align-"></a>줄 상자 내 세로 정렬: <code translate="no">vertical-align</code></h3>
<p>다음 두 속성은 줄 상자 내의 세로 정렬을 제어합니다:</p>
<table>
<thead>
<tr>
<th>속성</th>
<th>기본값</th>
<th>목적</th>
</tr>
</thead>
<tbody>
<tr>
<td>수직 정렬</td>
<td>기준선</td>
<td>상자의 세로 정렬을 제어합니다. 인라인(및 표 셀) 상자에만 적용됩니다.</td>
</tr>
<tr>
<td>줄 높이</td>
<td>일반(글꼴 높이의 ~1.2배)</td>
<td>선 상자 높이를 계산하는 데 사용되는 높이를 지정합니다.</td>
</tr>
</tbody>
</table>
<p><code translate="no">vertical-align</code> 줄 상자 자체의 세로 정렬이 아닌 줄 상자 내 인라인 상자의 세로 정렬을 제어합니다. 물론 인라인 상자가 어떻게 배치되는지 이해하려면 인라인 상자 자체뿐만 아니라 라인 상자의 높이가 어떻게 계산되는지도 알아야 합니다.</p>
<p>라인 상자 높이는 두 가지 요소에 의해 결정됩니다:</p>
<ul>
<li>그 안에 포함된 인라인 상자의 높이</li>
<li>그 안에 포함된 인라인 상자의 정렬입니다.</li>
</ul>
<p>(대체되지 않은) 인라인 박스의 높이는 다음과 같이 정의됩니다<a href="http://www.w3.org/TR/CSS2/visudet.html#inline-non-replaced">(출처</a>):</p>
<blockquote>
<p>'높이' 속성은 적용되지 않습니다. 콘텐츠 영역의 높이는 글꼴을 기준으로 해야 하지만 이 사양에서는 방법을 지정하지 않습니다. 예를 들어 UA는 em-박스 또는 글꼴의 최대 오름차순 및 내림차순을 사용할 수 있습니다. [...]</p>
<p>교체되지 않는 인라인 상자의 세로 패딩, 테두리 및 여백은 콘텐츠 영역의 위쪽과 아래쪽에서 시작하며 '줄 높이'와는 관련이 없습니다. 그러나 줄 상자의 높이를 계산할 때는 '줄 높이'만 사용됩니다.</p>
</blockquote>
<p>위에 표시된 사양의 일부에서 볼 수 있듯이 인라인 상자의 높이는 글꼴과 줄 높이에 따라 결정됩니다. 특히 각 글꼴은 기준선, 텍스트 상단 가장자리 및 텍스트 하단 가장자리를 정의해야 합니다. 인라인 상자의 콘텐츠 영역의 계산된 높이는 글꼴의 높이(예: 아래쪽 - 위쪽)에 줄 높이 값을 곱한 값입니다:</p>
<blockquote>
<p>대체되지 않은 인라인 요소에서 '줄 높이'는 줄 상자 높이 계산에 사용되는 높이를 지정합니다.</p>
</blockquote>
<p><code translate="no">line-height</code> 글꼴 높이를 기준으로 지정하거나 절대 길이 값으로 설정할 수 있으며, 이 경우 글꼴 높이는 더 이상 인라인 상자의 높이 계산에 관여하지 않습니다. 백분율로 지정한 경우에도 부모 요소의 높이와는 전혀 관련이 없습니다.</p>
<table>
<thead>
<tr>
<th><code translate="no">line-height</code> value</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>normal</td>
<td>사용자 상담원에게 요소의 글꼴에 따라 사용된 값을 "적절한" 값으로 설정하도록 지시합니다. 이 값은 <code translate="no">&lt;number&gt;</code> 와 같은 의미를 갖습니다. 'normal'의 사용 값은 1.0에서 1.2 사이를 권장합니다. 계산된 값은 '보통'입니다.</td>
</tr>
<tr>
<td><code translate="no">&lt;length&gt;</code></td>
<td>지정된 길이는 선 상자 높이 계산에 사용됩니다. 음수 값은 불법입니다.</td>
</tr>
<tr>
<td><code translate="no">&lt;number&gt;</code></td>
<td>속성의 사용 값은 이 숫자에 요소의 글꼴 크기를 곱한 값입니다. 음수 값은 유효하지 않습니다. 계산된 값이 지정된 값과 동일합니다.</td>
</tr>
<tr>
<td><code translate="no">&lt;percentage&gt;</code></td>
<td>속성의 계산된 값은 이 백분율에 요소의 계산된 글꼴 크기를 곱한 값입니다. 음수 값은 유효하지 않습니다.</td>
</tr>
</tbody>
</table>
<p>단일 인라인 상자 내에 두 개 이상의 글꼴이 사용되면 어떻게 되나요?</p>
<blockquote>
<p>두 개 이상의 글꼴이 사용되는 경우(글리프가 서로 다른 글꼴에서 발견될 때 발생할 수 있음) 콘텐츠 영역의 높이는 이 사양에 정의되어 있지 않습니다. 그러나 콘텐츠 영역의 높이가 요소에 있는 모든 글꼴의 (1) 엠박스 또는 (2) 최대 오름차순 및 내림차순에 충분히 맞도록 높이가 선택되는 것이 좋습니다. [...]</p>
</blockquote>
<p>사양에는 이 값이 정의되어 있지 않지만 사용되는 모든 글꼴(예: 글꼴 높이 중 최대값)에 대해 충분히 큰 것이 좋습니다.</p>
<p>인라인 상자의 정렬은 <code translate="no">vertical-align</code> 속성에 의해 결정됩니다. 두 가지 값 세트가 있는데, 첫 번째 세트는 부모 글꼴 기준선, 콘텐츠 영역 또는 하위 및 상위와 같은 글꼴 정의 위치에 상대적인 값입니다.</p>
<table>
<thead>
<tr>
<th><code translate="no">vertical-align</code> value</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>기준선</td>
<td>상자의 기준선을 부모 상자의 기준선에 맞춥니다. 상자에 기준선이 없는 경우 아래쪽 여백 가장자리를 부모의 기준선에 맞춥니다.</td>
</tr>
<tr>
<td>가운데</td>
<td>상자의 세로 중간점을 부모 상자의 기준선에 부모 상자의 x 높이의 절반을 더한 값에 맞춥니다.</td>
</tr>
<tr>
<td>sub</td>
<td>상자의 기준선을 부모 상자의 아래 첨자를 위한 적절한 위치로 낮춥니다.</td>
</tr>
<tr>
<td>super</td>
<td>상자의 기준선을 부모 상자의 위 첨자를 위한 적절한 위치로 올립니다.</td>
</tr>
<tr>
<td>text-top</td>
<td>상자의 상단을 상위 콘텐츠 영역의 상단에 맞춥니다(10.6.1 참조).</td>
</tr>
<tr>
<td>text-bottom</td>
<td>상자의 하단을 상위 콘텐츠 영역의 하단에 맞춥니다(10.6.1 참조).</td>
</tr>
<tr>
<td><code translate="no">&lt;percentage&gt;</code></td>
<td>이 거리('줄 높이' 값의 백분율)만큼 상자를 올리거나(양수 값) 내립니다(음수 값). '0%' 값은 '기준선'과 같은 의미입니다.</td>
</tr>
<tr>
<td><code translate="no">&lt;length&gt;</code></td>
<td>이 거리만큼 상자를 올리거나(양수 값) 내립니다(음수 값). '0cm' 값은 '기준선'과 같은 의미입니다.</td>
</tr>
</tbody>
</table>
<p>두 번째 값 집합은 다른 요소의 <code translate="no">vertical-align</code> 에 의해 정의되는 상위의 선 상자를 기준으로 정의됩니다. 선 상자의 높이는 수직 정렬에 따라 달라지고 수직 정렬은 선 상자 높이에 따라 달라지므로 이것은 재귀적 정의입니다. 즉, 이러한 특수 값을 가진 상자는 앞서 정의한 인라인 상자 크기와 정렬을 기반으로 선 상자 높이가 계산된 후에야 배치됩니다. <code translate="no">vertical-align</code> 의 두 값은 다음과 같습니다:</p>
<table>
<thead>
<tr>
<th><code translate="no">vertical-align</code> 값</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>top</td>
<td>정렬된 하위 트리의 상단을 선 상자의 상단과 정렬합니다.</td>
</tr>
<tr>
<td>bottom</td>
<td>정렬된 하위 트리의 아래쪽을 선 상자의 아래쪽에 정렬합니다.</td>
</tr>
</tbody>
</table>
<p>요약하자면, 인라인 상자에는</p>
<ul>
<li>글꼴 크기 - 텍스트 글리프의 크기를 결정합니다.</li>
<li>인라인 상자의 높이를 결정하는 줄 높이(절대 또는 글꼴 크기 대비)</li>
<li>기준선: 글꼴에 의해 정의되고 대부분의 글리프/문자의 하단 가장자리가 정렬되는 위치입니다(기준선 정렬의 아래/위로 확장되는 부분인 내림/상향선이 있는 q 및 g와 같은 문자 제외).</li>
</ul>
<p>선 상자 높이는 모든 인라인 상자의 높이를 계산한 다음 <code translate="no">vertical-align: top</code> 및 <code translate="no">vertical-align: bottom</code> 을 제외한 모든 <code translate="no">vertical-align</code> 정렬을 적용한 후 계산됩니다.</p>
<p>각 줄 상자에는</p>
<ul>
<li>부모에서 상속되는 글꼴 크기</li>
<li>줄 상자에 있는 인라인 상자의 높이와 정렬에 의해 정의된 높이</li>
<li>"스트럿"으로 정의되는 기준선( <code translate="no">vertical-align: top</code> / <code translate="no">bottom</code>)과 같은 드문 경우 제외: 요소의 글꼴 및 줄 높이 속성이 있는 보이지 않는 제로 너비 인라인 상자.</li>
</ul>
<p>일반적으로 부모 요소와 자식 요소의 글꼴 크기는 동일하므로 선 상자의 기준선과 자식 인라인 상자의 기준선 사이의 차이를 볼 수 없습니다. 그러나 다음은 다소 복잡한 경우 수직 정렬이 어떻게 작동하는지 보여주는 예시입니다:</p>
<div><div><pre translate="no"><code translate="no"><span>.parent</span> <span>{
  <span><span>font-size</span>:<span> <span>48pt</span></span></span>;
  <span><span>border</span>:<span> <span>1px</span> solid black</span></span>;
  <span><span>float</span>:<span> left</span></span>;
}</span>
<span>.child</span> <span>{
  <span><span>font-size</span>:<span> <span>12pt</span></span></span>;
  <span><span>vertical-align</span>:<span> baseline</span></span>;
}</span>
<span>.super</span> <span>{
  <span><span>font-size</span>:<span> <span>12pt</span></span></span>;
  <span><span>vertical-align</span>:<span> super</span></span>;
}</span>
</code></pre></div><div><pre translate="no"><code translate="no"><span>&lt;<span>div</span> <span>class</span>=<span>"parent"</span>&gt;</span>
  <span>&lt;<span>span</span> <span>class</span>=<span>"child"</span>&gt;</span>child
    <span>&lt;<span>span</span> <span>class</span>=<span>"super"</span>&gt;</span>sup
      <span>&lt;<span>span</span> <span>class</span>=<span>"super"</span>&gt;</span>sup<span>&lt;/<span>span</span>&gt;</span>
    <span>&lt;/<span>span</span>&gt;</span> here
  <span>&lt;/<span>span</span>&gt;</span>
  <span>&lt;<span>span</span> <span>class</span>=<span>"super"</span>&gt;</span>sup-parent<span>&lt;/<span>span</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"parent"</span>&gt;</span>aA<span>&lt;/<span>div</span>&gt;</span>
</code></pre></div></div><p>위의 예시에서</p>
<ul>
<li>첫 번째 부모 요소에 자체적으로 텍스트가 포함되어 있지 않더라도 해당 부모 요소 내부의 선 상자의 기준선과 최소 선 높이는 부모 요소에 설정된 글꼴 크기에 의해 정의됩니다.</li>
<li>첫 번째 자식 요소의 기준선은 부모 요소의 기준선에 맞춰 정렬됩니다. 부모 요소에 해당 글꼴 크기를 사용하는 텍스트가 포함되어 있지 않더라도 부모 요소의 기준선은 부모 요소에 설정된 글꼴 크기를 기준으로 합니다. 이것이 바로 "스트럿" 메커니즘이 작동하는 방식이며, 부모 기준선은 요소의 글꼴 및 줄 높이 속성이 있는 보이지 않는 너비 0의 인라인 상자로 정의됩니다.</li>
<li>다음으로 일련의 <code translate="no">vertical-align: super</code> 인라인 요소가 기준선을 점진적으로 이동하여 줄 높이를 더 높일 수 있습니다(이 경우 부모 글꼴이 너무 커서 그렇지 않습니다). 이는 정렬을 통해 줄 상자 높이를 높일 수 있는 방법을 보여줍니다.</li>
<li>마지막으로 '상위 부모'가 있는 스팬은 첫 번째 '하위' 요소와 같은 수준에 있으므로 부모 글꼴 크기의 <code translate="no">super</code> 위치에 따라 기준선이 이동하며, 부모 글꼴 크기가 하위 글꼴 크기보다 크기 때문에 다른 두 개의 상위 정렬 인라인 요소보다 훨씬 높게 나타납니다.</li>
</ul>
<p><code translate="no">vertical-align</code> 값의 대부분은 부모 요소의 글꼴 메트릭과 글꼴 크기에 따라 결정되는 부모 요소의 기준선에 상대적인 값이라는 점에 유의하세요. 예를 들어 <code translate="no">vertical-align: super</code> 요소의 체인은 기준선을 점차적으로 위로 이동시킵니다.</p>
<p>표에도 <code translate="no">vertical-align</code> 속성이 있지만 표의 컨텍스트에서 다르게 작동한다는 점에 유의하세요.</p>
<p>다음 예시는 인라인 블록 수직 중앙 맞춤 기법이 어떻게 작동하는지 보여줍니다( <a href="https://codepen.io/shshaw/full/gEiDt">이 페이지</a> 기준). 인라인 블록 중앙 정렬 기법은 요소를 세로(및 가로) 중앙에 배치할 수 있는 여러 가지 방법 중 하나입니다. 인라인 서식 컨텍스트와 <code translate="no">vertical-align</code> 속성을 사용하기 때문에 이러한 속성이 어떻게 사용되는지에 대한 좋은 실용적인 예시를 제공합니다.</p>
<div><div><pre translate="no"><code translate="no"><span>.container</span> <span>{
  <span><span>text-align</span>:<span> center</span></span>;
  <span><span>overflow</span>:<span> auto</span></span>;
  <span><span>height</span>:<span> <span>120px</span></span></span>;
}</span>

<span>.container</span><span>:after</span>,
<span>.block</span> <span>{
  <span><span>display</span>:<span> inline-block</span></span>;
  <span><span>vertical-align</span>:<span> middle</span></span>;
}</span>

<span>.container</span><span>:after</span> <span>{
  <span><span>content</span>:<span> <span>''</span></span></span>;
  <span><span>height</span>:<span> <span>100%</span></span></span>;
  <span><span>margin-left</span>:<span> -<span>0.25em</span></span></span>; <span>/* To offset spacing. May vary by font */</span>
  <span><span>width</span>:<span> <span>10px</span></span></span>; <span>/* to show the inserted pseudo element */</span>
  <span><span>background-color</span>:<span> lightgreen</span></span>; <span>/* to show the inserted pseudo element */</span>
}</span>

<span>.block</span> <span>{
  <span><span>max-width</span>:<span> <span>99%</span></span></span>; <span>/* Prevents issues with long content causes the content block to be pushed to the top */</span>
}</span>
</code></pre></div><div><pre translate="no"><code translate="no"><span>&lt;<span>div</span> <span>class</span>=<span>"container blue"</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"block red"</span>&gt;</span>Centered<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
</code></pre></div></div><p>세로 중앙 정렬 기법이 작동하는 다양한 부분을 더 잘 보여주기 위해 몇 가지 스타일을 추가했습니다. 위의 예시에서 볼 수 있듯이</p>
<ul>
<li>컨테이너 내부의 내부 블록은 <code translate="no">display: inline-block</code> 으로 인라인 수준 상자로 취급되어 인라인 서식 컨텍스트를 생성하지만 그 내용은 <code translate="no">display: block</code> 요소처럼 동작합니다(예: <code translate="no">width: 100%</code> 설정이 작동합니다!).</li>
<li>컨테이너에 <code translate="no">text-align: center</code> 이 있는 경우 인라인 수준 블록이 각 줄 상자의 중앙에 위치하게 됩니다.</li>
<li>콘텐츠 블록에 <code translate="no">vertical-align: middle</code> 을 설정하면 줄 상자의 다른 모든 콘텐츠에 대해 세로로 정렬됩니다.</li>
<li><code translate="no">height: 100%</code> 가 있는 의사 요소가 컨테이너 끝에 추가됩니다. 녹색으로 표시됩니다. 이 요소가 없으면 콘텐츠 블록이 하나의 줄 상자에 단독으로 존재하기 때문에 흐름의 맨 위에 위치하게 되고, 줄 상자 높이가 콘텐츠 블록과 일치하기 때문에 정렬할 대상이 없어지기 때문에 이 요소가 필요합니다.</li>
<li><code translate="no">margin-left: -0.25em</code> 은 의사 요소로 인한 간격을 상쇄하기 위한 휴리스틱일 뿐입니다.</li>
</ul>
<p>간단히 말해, 이 중앙 정렬 기법이 작동하는 이유는 컨테이너의 선 높이를 부모 높이의 100%로 강제 설정한 다음 중앙에 있는 항목이 형제(녹색) 요소의 중간 지점에 위치하도록 요청했기 때문입니다. 중앙에 배치할 상자가 컨테이너보다 너비가 작다고 가정하면 이 모든 것이 하나의 매우 높은 선 상자에 배치되고 최종 결과는 수직 및 수평 중앙 배치가 됩니다.</p>
<p>마지막 예는 익명 상자 생성으로 인해 인라인 수준 상자를 선 상자에 배포하는 데 문제가 발생할 수 있는 추가 상호 작용을 보여줍니다:</p>
<div><div><pre translate="no"><code translate="no"><span>.half</span> <span>{
  <span><span>display</span>:<span> inline-block</span></span>;
  <span><span>width</span>:<span> <span>50%</span></span></span>;
  <span><span>border-width</span>:<span> <span>0</span></span></span>;
}</span>
</code></pre></div><div><pre translate="no"><code translate="no"><span>&lt;<span>div</span> <span>class</span>=<span>"blue"</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"half green"</span>&gt;</span>width: 50%<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"half orange"</span>&gt;</span>width: 50%<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
</code></pre></div></div><p>위의 예시에서</p>
<ul>
<li>두 div의 크기는 <code translate="no">width: 50%</code> 로 지정되어 있지만 두 줄로 둘러싸여 있습니다.</li>
<li>여기서 문제는 두 div 사이의 공백으로 인해 익명 인라인 상자가 생성된다는 것입니다. 익명 인라인 상자를 사용하면 줄 상자의 내용이 부모의 사용 가능한 너비의 100%를 초과하여 두 번째 줄 상자가 생성됩니다.</li>
</ul>
<p>이 문제에 대한 몇 가지 해결책이 있습니다:</p>
<ul>
<li>이 문제를 해결하는 한 가지 방법은 두 div 사이의 공백을 없애는 것입니다(예: <code translate="no">...&lt;/div&gt;&lt;div&gt;...</code>).</li>
<li>이 문제를 해결하는 또 다른 방법은 부모 레이어에서 글꼴 크기를 0으로 설정한 다음 두 자식 div에서 원하는 값으로 설정하는 것입니다. 이렇게 하면 공백이 전혀 차지하지 않습니다.</li>
<li><code translate="no">white-space: nowrap</code> 설정도 도움이 됩니다. 공백을 없애지는 않지만 공백으로 인한 줄 바꿈은 방지할 수 있습니다. 이 경우 두 div는 같은 줄 상자에 배치되지만 그 사이에 공백이 있고 오른쪽 div가 부모 컨테이너를 넘기게 됩니다.</li>
<li>마지막으로, 현재 구현되지 않은 CSS3 <a href="http://dev.w3.org/csswg/css-text-4/#white-space-collapsing"><code translate="no">text-space-collapse</code></a> 속성을 사용하면 현재 대부분의 브라우저에서 구현되지 않는 이 문제를 해결할 수 있습니다.</li>
</ul>
<h3 id="vertical-align-middle-doesn-t-quite-do-what-you-d-expect"><a href="#vertical-align-middle-doesn-t-quite-do-what-you-d-expect"></a>수직 정렬: 가운데가 예상대로 작동하지 않음</h3>
<p>글을 쓰는 과정에서 꽤 늦게 깨달은 또 다른 점은 <code translate="no">vertical-align: middle</code> 이 실제로 예상대로 부모 컨테이너 상자의 가운데에 요소를 정렬하지 않는다는 것입니다.</p>
<p>기억하시겠지만, 스펙에는 다음과 같이 나와 있습니다:</p>
<blockquote>
<p><em>middle</em>: 상자의 세로 중간점을 부모 상자의 기준선에 부모 상자의 x 높이의 절반을 더한 값에 맞춥니다.</p>
</blockquote>
<p>하지만 이것이 실제로 무엇을 의미할까요? 해독해 봅시다:</p>
<ul>
<li><em>(자식, 인라인 수준) 상자의 세로 중간점</em> 정렬: 괜찮아 보입니다.</li>
<li><em>부모 상자의 기준선에</em> 맞추기: 이는 부모 글꼴 메트릭이 위치 지정에 역할을 한다는 의미입니다.</li>
<li><em>와 부모 글꼴 높이의 절반을 더한</em> 값: <code translate="no">x-height</code>?</li>
</ul>
<p>이 조각들을 조합하는 데 시간이 좀 걸렸습니다. 첫째, <code translate="no">x-height</code> 은 부모 상자의 <code translate="no">height</code> 과는 다릅니다. 대신 <a href="http://www.w3.org/TR/2011/REC-CSS2-20110607/syndata.html#length-units">사양의 섹션 4.3.2에</a> 다음과 같이 정의되어 있습니다:</p>
<blockquote>
<p>'x-height'는 종종 소문자 "x"의 높이와 같기 때문에 그렇게 불립니다. 그러나 'x'가 포함되지 않은 글꼴에 대해서도 'ex'가 정의되어 있습니다.</p>
<p>글꼴의 x 높이는 다양한 방법으로 찾을 수 있습니다. 일부 글꼴에는 x 높이에 대한 신뢰할 수 있는 메트릭이 포함되어 있습니다. 신뢰할 수 있는 글꼴 메트릭을 사용할 수 없는 경우 UA는 소문자 글리프의 높이에서 x 높이를 결정할 수 있습니다. 한 가지 가능한 휴리스틱은 소문자 'o'의 글리프가 기준선 아래로 얼마나 뻗어 있는지 살펴보고 해당 값을 경계 상자의 상단에서 빼는 것입니다. x 높이를 결정하는 것이 불가능하거나 비현실적인 경우에는 0.5m의 값을 사용해야 합니다.</p>
</blockquote>
<p>따라서 x-height는 말 그대로 글꼴의 x 문자 높이가 아니라 부모 요소 높이의 절반을 의미합니다.</p>
<p>자, 사양에 "부모 상자"라고 되어 있는 것은 무엇을 의미할까요? 인라인 서식 컨텍스트를 설정하는 컨테이너 상자가 아니라 줄 상자를 의미하는 것으로 밝혀졌습니다. 제가 설명해드리겠습니다:</p>
<div><div><pre translate="no"><code translate="no"><span>.parent</span> <span>{
  <span><span>height</span>:<span> <span>60px</span></span></span>;
  <span><span>font-family</span>:<span> monospace</span></span>;
}</span>
<span>.child</span> <span>{
  <span><span>font-size</span>:<span> medium</span></span>;
  <span><span>vertical-align</span>:<span> middle</span></span>;
}</span>
</code></pre></div><div><pre translate="no"><code translate="no"><span>&lt;<span>div</span> <span>class</span>=<span>"parent blue"</span>&gt;</span>
  x
  <span>&lt;<span>span</span> <span>class</span>=<span>"child green"</span>&gt;</span>&amp;lt;<span>&lt;/<span>span</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
</code></pre></div></div><p>위에서 볼 수 있듯이 자식은 <code translate="no">parent</code> 요소의 높이가 아닌 <code translate="no">x-height</code> 줄 상자에 맞춰 정렬됩니다. 줄에는 공백을 위해 스팬과 생성된 익명 인라인 수준 상자만 포함되므로 높이가 글꼴의 줄 높이와 일치하며 아무 일도 일어나지 않습니다. 사실, 높이가 아니라 <code translate="no">x-height</code> 에 대해 이야기하고 있기 때문에 줄 상자의 높이는 중요하지도 않습니다. 다음 예시를 살펴보겠습니다:</p>
<div><div><pre translate="no"><code translate="no"><span>.parent</span> <span>{
  <span><span>height</span>:<span> <span>60px</span></span></span>;
  <span><span>font-family</span>:<span> monospace</span></span>;
}</span>
<span>.parent2</span> <span>{
  <span><span>height</span>:<span> <span>60px</span></span></span>;
  <span><span>font-family</span>:<span> monospace</span></span>;
  <span><span>font-size</span>:<span> <span>40px</span></span></span>;
}</span>
<span>.large</span> <span>{
  <span><span>font-size</span>:<span> <span>40px</span></span></span>;
}</span>
<span>.child</span> <span>{
  <span><span>font-size</span>:<span> medium</span></span>;
  <span><span>vertical-align</span>:<span> middle</span></span>;
}</span>
</code></pre></div><div><pre translate="no"><code translate="no"><span>&lt;<span>div</span> <span>class</span>=<span>"parent blue"</span>&gt;</span>
  x
  <span>&lt;<span>span</span> <span>class</span>=<span>"child green"</span>&gt;</span>&amp;lt;<span>&lt;/<span>span</span>&gt;</span>
  <span>&lt;<span>span</span> <span>class</span>=<span>"large green"</span>&gt;</span>&amp;lt;<span>&lt;/<span>span</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"parent2 blue"</span>&gt;</span>
  x
  <span>&lt;<span>span</span> <span>class</span>=<span>"child green"</span>&gt;</span>&amp;lt;<span>&lt;/<span>span</span>&gt;</span>
  <span>&lt;<span>span</span> <span>class</span>=<span>"large green"</span>&gt;</span>&amp;lt;<span>&lt;/<span>span</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
</code></pre></div></div><p>예제에서 두 상자를 비교해보면</p>
<ul>
<li>첫 번째 예제에서는 두 번째 <code translate="no">&lt;</code> 로 인해 선 상자 높이가 훨씬 커졌지만 첫 번째 <code translate="no">&lt;</code> 와 <code translate="no">x</code> 사이의 정렬은 이전과 정확히 동일하게 보입니다.</li>
<li>두 번째 예제에서는 줄 상자의 높이가 이전과 동일합니다. 하지만 부모의 글꼴 크기도 늘렸습니다. 이로 인해 부모 상자의 기준선이 모두 이동하고 <code translate="no">x-height</code> (문자 그대로 부모 글꼴의 X 높이)도 증가합니다. 보시다시피 첫 번째 <code translate="no">&lt;</code> 의 위치가 최종적으로 변경됩니다.</li>
</ul>
<p>간단히 말해서 <code translate="no">vertical-align: middle</code> 은 거의 모든 상황에서 "중간"이 아니라 "부모 글꼴의 x 문자 높이의 절반에 해당하는 위치에 자식 요소를 부모 요소의 기준선 위에 배치"한다는 의미입니다. 이는 매우 글꼴 중심적인 세계관으로, 부모 요소의 중간도 아니고 자식 요소가 있는 줄 상자의 중간도 아닙니다. <code translate="no">vertical-align: middle</code> 는 종종 괜찮아 보이지만, 엄밀히 말하면 부모 글꼴의 X-글리프가 아닌 다른 어떤 것의 <code translate="no">middle</code> 도 아닙니다.</p>
<h3 id="normal-flow-relative-positioning"><a href="#normal-flow-relative-positioning"></a>일반적인 흐름: 상대적 위치 지정</h3>
<p>블록 서식 지정 컨텍스트와 인라인 서식 지정 컨텍스트에 대해 살펴봤으니 이제 마지막 일반 흐름 위치 지정 속성 값인 <code translate="no">position: relative</code> 을 살펴볼 차례입니다.</p>
<p>상대적 위치 지정은 일반 흐름과 크게 다르지 않기 때문에 일반 흐름의 일부로 간주됩니다.</p>
<blockquote>
<p>상대적: 상자의 위치는 일반 흐름 [...]에 따라 계산됩니다. 그러면 상자는 정상 위치에 대해 상대적으로 오프셋됩니다. 상자 B가 상대적으로 위치하면 다음 상자의 위치는 B가 오프셋되지 않은 것처럼 계산됩니다. 표-행 그룹, 표 머리글 그룹, 표 바닥글 그룹, 표 행, 표 열 그룹, 표 열, 표 셀 및 표 캡션 요소에 대한 '위치:상대'의 효과는 정의되지 않습니다.</p>
</blockquote>
<p>즉, 상대적으로 위치가 지정된 요소는 정상 위치로 배치된 다음 <code translate="no">top</code>, <code translate="no">left</code>, <code translate="no">bottom</code> 및 <code translate="no">right</code> 속성 값에 따라 정상 위치에서 오프셋됩니다.</p>
<div><div><pre translate="no"><code translate="no"><span>.float</span> <span>{
  <span><span>float</span>:<span> left</span></span>;
}</span>
<span>.foo</span> <span>{
  <span><span>padding-top</span>:<span> <span>10px</span></span></span>;
}</span>
<span>.bar</span> <span>{
  <span><span>position</span>:<span> relative</span></span>;
  <span><span>top</span>:<span> -<span>20px</span></span></span>;
  <span><span>left</span>:<span> <span>10px</span></span></span>;
  <span><span>width</span>:<span> <span>30%</span></span></span>;
}</span>
<span>.baz</span> <span>{
  <span><span>width</span>:<span> <span>40%</span></span></span>;
}</span>
</code></pre></div><div><pre translate="no"><code translate="no"><span>&lt;<span>div</span>&gt;</span><span>&lt;<span>div</span> <span>class</span>=<span>"float red"</span>&gt;</span>float<span>&lt;/<span>div</span>&gt;</span><span>&lt;<span>div</span> <span>class</span>=<span>"foo blue"</span>&gt;</span>foo<span>&lt;/<span>div</span>&gt;</span><span>&lt;<span>div</span> <span>class</span>=<span>"bar green"</span>&gt;</span>bar<span>&lt;/<span>div</span>&gt;</span><span>&lt;<span>div</span> <span>class</span>=<span>"baz orange"</span>&gt;</span>baz<span>&lt;/<span>div</span>&gt;</span><span>&lt;/<span>div</span>&gt;</span>
</code></pre></div></div><p>예시에서 볼 수 있듯이</p>
<ul>
<li><code translate="no">.bar</code> 상자는 다음과 같이 정상 흐름 위치에서 20픽셀 위로 오프셋됩니다. <code translate="no">top: -20px</code></li>
<li>가 있기 때문에 후속 <code translate="no">.baz</code> 상자는 일반 흐름에서 <code translate="no">.bar</code> 상자가 원래 위치에 있는 것처럼 여전히 배치됩니다.</li>
</ul>
<h2 id="float-positioning-scheme"><a href="#float-positioning-scheme"></a>플로트 위치 지정 방식</h2>
<p>플로트 위치 지정 체계는 이미지 주위에 텍스트를 둘러싸기 위한 것이지만, 대부분의 최신 CSS 그리드 프레임워크의 기본 구성 요소가 되었습니다. 일반 흐름의 작동 방식과 인라인 서식 컨텍스트가 줄 상자로 분할되는 방식을 이해하면 플로트를 훨씬 더 쉽게 사용할 수 있습니다. <code translate="no">float</code> 속성을 설정하면 요소의 상자가 플로트 위치 지정 체계를 사용하여 위치가 지정됩니다.</p>
<table>
<thead>
<tr>
<th>속성</th>
<th>기본값</th>
<th>목적</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>none</td>
<td>요소 주위에 다른 요소가 떠 있도록 허용합니다.</td>
</tr>
</tbody>
</table>
<p>플로트는 레이아웃 중에 정상적인 흐름에서 벗어나는 블록 수준과 유사한 요소라고 할 수 있습니다. 블록 수준 상자에는 영향을 주지 않지만 블록 수준 상자 안에 포함된 선 상자에는 영향을 줄 수 있습니다. 사양에서 정의하는 방식은 다음과 같습니다:</p>
<blockquote>
<p>플로트는 현재 줄에서 왼쪽 또는 오른쪽으로 이동하는 상자입니다. 플로트(또는 '플로팅' 또는 '부동' 상자)의 가장 흥미로운 특징은 콘텐츠가 측면을 따라 흐르거나 '지우기' 속성에 의해 금지될 수 있다는 것입니다(또는 '지우기' 속성에 의해 금지됨). 콘텐츠는 왼쪽으로 떠 있는 상자의 오른쪽 아래로, 오른쪽으로 떠 있는 상자의 왼쪽 아래로 흐릅니다.</p>
</blockquote>
<p>플로트에는 몇 가지 특별한 동작이 있습니다:</p>
<ul>
<li>플로트는 레이아웃 중에 일반적인 흐름에서 벗어나므로 블록 수준 요소의 수직 위치에 영향을 주지 않습니다.</li>
<li>플로트는 컨테이너의 왼쪽 또는 오른쪽 바깥쪽 가장자리에 정렬됩니다.</li>
<li>플로트는 왼쪽 또는 오른쪽 가장자리에서 시작하여 마크업에 표시되는 순서대로 쌓입니다. 즉, 오른쪽으로 떠 있는 상자의 경우 첫 번째 오른쪽 떠 있는 상자는 해당 상자가 들어 있는 상자의 오른쪽 가장자리에 배치되고 두 번째 오른쪽 떠 있는 상자는 첫 번째 상자의 바로 왼쪽에 배치됩니다.</li>
<li>그러나 플로트는 현재 및 후속 요소의 인라인 수준 콘텐츠의 줄 상자에 영향을 줄 수 있습니다. 구체적으로, 현재 및 후속 줄 상자는 플로트를 위한 공간을 확보하기 위해 짧아집니다.</li>
<li>플로트는 정상적인 흐름에 있지 않으므로 일반적으로 부모 높이에 영향을 주지 않습니다. 이것이 바로 '클리어픽스' 기법이 개발된 이유 중 하나입니다.</li>
<li>플로트는 <code translate="no">clear</code> 속성을 사용하여 지울 수 있습니다.</li>
</ul>
<p>몇 가지 예시 코드 예시와 함께 이러한 각 동작의 세부 사항을 살펴보겠습니다.</p>
<p>플로트는 포함 블록의 바깥쪽 가장자리에 배치되거나 다른 플로트가 있는 경우 앞쪽 플로트의 바깥쪽 가장자리에 배치됩니다:</p>
<blockquote>
<p>플로트 상자는 바깥쪽 가장자리가 포함 블록 가장자리 또는 다른 플로트의 바깥쪽 가장자리에 닿을 때까지 왼쪽 또는 오른쪽으로 이동합니다. 선 상자가 있는 경우 플로트 상자의 바깥쪽 위쪽이 현재 선 상자의 위쪽과 정렬됩니다.</p>
</blockquote>
<p>플로트는 마크업에서 정의된 순서대로 쌓입니다:</p>
<blockquote>
<p>현재 상자가 왼쪽 부동이고 소스 문서의 이전 요소에서 생성된 왼쪽 부동 상자가 있는 경우, 이러한 각 이전 상자에 대해 현재 상자의 왼쪽 바깥쪽 가장자리가 이전 상자의 오른쪽 바깥쪽 가장자리 오른쪽에 있거나 상단이 이전 상자의 아래쪽보다 낮아야 합니다. 오른쪽으로 떠 있는 상자에도 유사한 규칙이 적용됩니다.</p>
</blockquote>
<p>다음 예제는 이 동작을 보여줍니다:</p>
<div><div><pre translate="no"><code translate="no"><span>.left</span> <span>{
  <span><span>float</span>:<span> left</span></span>;
}</span>
<span>.right</span> <span>{
  <span><span>float</span>:<span> right</span></span>;
}</span>
</code></pre></div><div><pre translate="no"><code translate="no"><span>&lt;<span>div</span> <span>class</span>=<span>"left red"</span>&gt;</span>A<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"right blue"</span>&gt;</span>B<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"left red"</span>&gt;</span>C<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"right blue"</span>&gt;</span>D<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"left red"</span>&gt;</span>E<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"right blue"</span>&gt;</span>F<span>&lt;/<span>div</span>&gt;</span>
</code></pre></div></div><p>위의 예시에서는</p>
<ul>
<li>div는 마크업에서 알파벳순으로 정렬됩니다(A, B, C, D, E, F).</li>
<li>첫 번째, 세 번째 및 다섯 번째 div는 <code translate="no">float: left</code> 이고 두 번째, 네 번째 및 여섯 번째 div는 <code translate="no">float: right</code> 입니다.</li>
<li>모든 div는 마크업 순서대로 쌓이며, 가장 왼쪽 또는 오른쪽에 있는 첫 번째 플로팅된 div가 가장 왼쪽 또는 가장 오른쪽에 위치하는 식으로 쌓입니다.</li>
</ul>
<p>가로로 맞지 않는 플로트는 아래쪽으로 이동합니다:</p>
<blockquote>
<p>플로트를 위한 가로 공간이 충분하지 않으면 플로트가 맞거나 더 이상 플로트가 없을 때까지 아래쪽으로 이동합니다.</p>
</blockquote>
<p>플로트는 동일한 흐름에서 블록 상자를 세로로 배치하기 위한 목적으로 무시됩니다. 그러나 플로트는 일반 흐름에서 블록 상자 안에 포함된 라인 상자에 영향을 줄 수 있습니다:</p>
<blockquote>
<p>플로트가 흐름에 없으므로 플로트 상자 앞뒤에 생성된 위치가 지정되지 않은 블록 상자는 플로트가 없는 것처럼 수직으로 흐릅니다. 그러나 플로트 옆에 생성된 현재 및 후속 라인 상자는 플로트의 여백 상자를 위한 공간을 확보하기 위해 필요에 따라 짧아집니다.</p>
</blockquote>
<p>다음 예제는 이 동작을 설명합니다:</p>
<div><div><pre translate="no"><code translate="no"><span>.float</span> <span>{
  <span><span>float</span>:<span> left</span></span>;
  <span><span>height</span>:<span> <span>500px</span></span></span>;
}</span>
<span>.para</span> <span>{
  <span><span>margin</span>:<span> <span>0</span></span></span>;
}</span>
</code></pre></div><div><pre translate="no"><code translate="no"><span>&lt;<span>div</span> <span>class</span>=<span>"para blue"</span>&gt;</span>Text inside a block-level box placed on a line box before the float<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"para green"</span>&gt;</span>Text before the float. <span>&lt;<span>div</span> <span>class</span>=<span>"float red"</span>&gt;</span>The float<span>&lt;/<span>div</span>&gt;</span> Text after the float.<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"para orange"</span>&gt;</span>Text inside a block-level box placed on a line box after the float<span>&lt;/<span>div</span>&gt;</span>
</code></pre></div></div><p>위의 예시에서</p>
<ul>
<li>모든 블록 수준 div(<code translate="no">.para</code>)는 자체적으로 블록 서식 컨텍스트에 있는 것처럼 세로로 배치됩니다.</li>
<li>플로트는 현재 및 후속 줄 상자에 영향을 주지만 첫 번째 블록 수준 div의 줄 상자는 플로트보다 앞에 있기 때문에 영향을 주지 않습니다.</li>
<li>단락에 <code translate="no">p</code> 태그를 사용하지 않은 이유는 다르게 해석되어 다른 렌더링이 생성되기 때문입니다. 이는 CSS 때문이 아니라 HTML에서 <code translate="no">p</code> 태그 안에 <code translate="no">div</code>s(예: float)를 허용하지 않으며 브라우저 오류 수정 동작으로 인해 수정된 마크업과 렌더링이 달라지기 때문입니다.</li>
</ul>
<p>플로트는 새로운 블록 서식 컨텍스트를 설정하는 일반 흐름에서 요소 내부의 줄 상자에 영향을 주지 않습니다. 대신 이러한 요소는 플로트의 측면에 배치되거나 앞의 플로트 아래에 배치하여 지워집니다:</p>
<blockquote>
<p>표의 테두리 상자, 블록 수준으로 대체된 요소 또는 새 블록 서식 컨텍스트를 설정하는 일반 흐름의 요소('표시'가 아닌 '오버플로'가 있는 요소 등)는 요소 자체와 동일한 블록 서식 컨텍스트에 있는 플로트의 여백 상자와 겹치지 않아야 합니다. 필요한 경우 구현은 해당 요소를 앞의 플로트 아래에 배치하여 지워야 하지만 충분한 공간이 있는 경우 해당 플로트에 인접하여 배치할 수 있습니다.</p>
</blockquote>
<p>다음 예제는 이 동작을 설명합니다:</p>
<div><div><pre translate="no"><code translate="no"><span>.float</span> <span>{
  <span><span>float</span>:<span> left</span></span>;
  <span><span>height</span>:<span> <span>500px</span></span></span>;
}</span>
<span>.para</span> <span>{
  <span><span>margin</span>:<span> <span>0</span></span></span>;
}</span>
<span>.new-context</span> <span>{
  <span><span>margin</span>:<span> <span>0</span></span></span>;
  <span><span>overflow</span>:<span> auto</span></span>;
}</span>
</code></pre></div><div><pre translate="no"><code translate="no"><span>&lt;<span>div</span> <span>class</span>=<span>"para blue"</span>&gt;</span>before<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"float red"</span>&gt;</span>The float<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"new-context green"</span>&gt;</span>new formatting context<span>&lt;<span>br</span>&gt;</span>foo bar<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"para orange"</span>&gt;</span>after<span>&lt;/<span>div</span>&gt;</span>
</code></pre></div></div><p>위의 예시에서</p>
<ul>
<li><code translate="no">new-context</code> div는 새로운 서식 컨텍스트를 설정합니다(예: <code translate="no">overflow</code> 이 <code translate="no">visible</code> 이 아니기 때문에).</li>
<li>해당 div 앞에 있는 플로트는 <code translate="no">new-context</code> 의 줄 상자에 영향을 주지 않습니다. 보시다시피 <code translate="no">new-context</code> 의 테두리는 플로트 테두리 옆에 있고 <code translate="no">new-context</code> 상자는 플로트 옆에 배치되어 있습니다.</li>
<li>플로트는 새 블록 서식 컨텍스트를 설정하지 않기 때문에 다음 div의 줄 상자에 영향을 줍니다. "after"가 포함된 div의 왼쪽 테두리가 플로트 아래에 그려집니다.</li>
</ul>
<p>이 동작은 매우 유용하고 실질적으로 중요한 것으로 밝혀졌습니다. 대부분의 CSS 그리드 프레임워크는 레이아웃에 <code translate="no">visible</code> 이외의 <code translate="no">overflow</code> 값과 플로트를 사용합니다.</p>
<h2 id="float-clearing"><a href="#float-clearing"></a>플로트 지우기</h2>
<p>CSS 사양에서는 <code translate="no">clear</code> 속성<a href="http://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#flow-control">(소스)</a>을 설정하여 플로트가 후속 요소의 줄 상자와 상호 작용하지 않도록 할 수 있습니다.</p>
<table>
<thead>
<tr>
<th>속성</th>
<th>기본값</th>
<th>목적</th>
</tr>
</thead>
<tbody>
<tr>
<td>clear</td>
<td>none</td>
<td>요소가 앞에 있는 부동 요소 옆에 위치할 수 있는지 또는 그 아래로 이동(지워짐)해야 하는지 여부를 지정합니다.</td>
</tr>
</tbody>
</table>
<p><code translate="no">clear</code> 속성은 다음 값 중 하나를 사용할 수 있습니다:</p>
<ul>
<li><code translate="no">left</code>: 상자의 위쪽 테두리 가장자리가 소스 문서 앞의 요소로 인해 발생한 왼쪽 부동 상자의 아래쪽 바깥쪽 가장자리 아래에 있어야 합니다.</li>
<li><code translate="no">right</code>: 상자의 위쪽 테두리 가장자리가 소스 문서의 앞부분에 있는 요소로 인해 발생한 오른쪽으로 떠 있는 상자의 아래쪽 바깥쪽 가장자리 아래에 있어야 합니다.</li>
<li><code translate="no">both</code>: <code translate="no">float: left</code> 및 <code translate="no">float: right</code> 모두 위와 같이 지워야 합니다.</li>
<li><code translate="no">none</code>: 플로트에 대한 상자의 위치에는 제약이 없습니다.</li>
</ul>
<p>다음 예시가 이를 보여줍니다:</p>
<div><div><pre translate="no"><code translate="no"><span>.left</span>, <span>.right</span> <span>{
  <span><span>width</span>:<span> <span>35%</span></span></span>;
  <span><span>height</span>:<span> <span>40px</span></span></span>;
}</span>
<span>.left</span> <span>{
  <span><span>float</span>:<span> left</span></span>;
}</span>
<span>.right</span> <span>{
  <span><span>float</span>:<span> right</span></span>;
}</span>
<span>.clear-left</span> <span>{
  <span><span>clear</span>:<span> left</span></span>;
}</span>
<span>.clear-both</span> <span>{
  <span><span>clear</span>:<span> both</span></span>;
}</span>
</code></pre></div><div><pre translate="no"><code translate="no"><span>&lt;<span>div</span> <span>class</span>=<span>"left blue"</span>&gt;</span>A<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"left blue"</span>&gt;</span>B<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"right red"</span>&gt;</span>C<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"right red"</span>&gt;</span>D<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"clear-left orange"</span>&gt;</span>Clear left only. Clear left only. Clear left only. Clear left only. Clear left only. Clear left only.<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"left blue"</span>&gt;</span>E<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"left blue"</span>&gt;</span>F<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"right red"</span>&gt;</span>G<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"right red"</span>&gt;</span>H<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"clear-both violet"</span>&gt;</span>Clear both. Clear both. Clear both. Clear both. Clear both. Clear both. Clear both.<span>&lt;/<span>div</span>&gt;</span>
</code></pre></div></div><p>플로트의 또 다른 놀라운 속성은 부모 요소의 높이를 계산할 때 고려되지 않는다는 것입니다! 부모 요소에 다른 요소가 없는 경우 부모 요소의 높이는 0이 됩니다. 아래 예시가 이를 보여줍니다:</p>
<div><div><pre translate="no"><code translate="no"><span>.left</span> <span>{
  <span><span>float</span>:<span> left</span></span>;
  <span><span>width</span>:<span> <span>35%</span></span></span>;
  <span><span>height</span>:<span> <span>40px</span></span></span>;
}</span>
</code></pre></div><div><pre translate="no"><code translate="no"><span>&lt;<span>div</span> <span>class</span>=<span>"orange"</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left blue"</span>&gt;</span>A<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left blue"</span>&gt;</span>B<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left red"</span>&gt;</span>C<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left red"</span>&gt;</span>D<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
</code></pre></div></div><p>그 이유는 실제로 "콘텐츠 기반" 높이 계산에는 두 가지 변형이 있으며, <code translate="no">overflow: visible</code> (기본값)이 있는 블록 수준 요소에 사용되는 것은 상위 요소의 높이를 결정할 때 부동을 고려하지 않기 때문입니다. <code translate="no">overflow</code> 을 다른 값으로 설정하거나 명시적으로 플로트를 지우면 부모 높이가 계산되어 플로트가 고려됩니다. 다음 장에서는 상자 모델 크기 계산에 대해 훨씬 더 자세히 다룹니다.</p>
<h2 id="the-clearfix"><a href="#the-clearfix"></a>클리어픽스</h2>
<p>클리어픽스 기법은 기본 플로트 지우기보다 향상된 기법입니다. clearfix는 플로트로 작업하는 많은 개발자가 사용하는 작은 CSS 조각입니다. 수년에 걸쳐 여러 가지 버전의 클리어픽스가 있었지만 최신 버전은 오래된 IE 관련 수정 사항이 적기 때문에 덜 끔찍합니다.</p>
<p>클리어픽스는 여러 가지 바람직한 속성을 하나의 클래스로 결합합니다:</p>
<ul>
<li>클리어픽스된 부모 요소 내의 플로트가 클리어픽스된 요소를 따르는 다른 요소의 줄 상자에 영향을 미치지 않도록 합니다.</li>
<li>를 사용하면 해당 요소의 높이를 계산할 때 명확하게 고정된 부모 요소 내의 플로트가 고려됩니다.</li>
</ul>
<p>예를 들어 클리어픽스가 활성화되어 있지 않은 다음 마크업이 있다고 가정해 보겠습니다:</p>
<div><div><pre translate="no"><code translate="no"><span>.left</span> <span>{
  <span><span>float</span>:<span> left</span></span>;
  <span><span>width</span>:<span> <span>15%</span></span></span>;
  <span><span>height</span>:<span> <span>40px</span></span></span>;
}</span>
</code></pre></div><div><pre translate="no"><code translate="no"><span>&lt;<span>div</span> <span>class</span>=<span>"row clearfix blue"</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left blue"</span>&gt;</span>A<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left blue"</span>&gt;</span>B<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"row clearfix green"</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left green"</span>&gt;</span>C<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left green"</span>&gt;</span>D<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"row clearfix orange"</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left orange"</span>&gt;</span>E<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left orange"</span>&gt;</span>F<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
</code></pre></div></div><p>... 플로트가 부모 요소 내에서 개별 행을 형성하도록 하고 싶습니다.</p>
<p>이를 달성하는 세 가지 방법이 있습니다:</p>
<ul>
<li>부모 끝에 <code translate="no">clear: both</code> 를 사용하여 명시적으로 요소 추가하기</li>
<li>부모 끝에 의사 요소를 사용하여 <code translate="no">clear: both</code> 으로 요소를 추가합니다.</li>
<li>부모 요소가 <code translate="no">overflow: hidden</code> 또는 <code translate="no">overflow: auto</code></li>
</ul>
<p>플로트 지우기 섹션의 예제에서는 플로트를 지우는 요소를 명시적으로 추가하면 플로트가 후속 요소와 상호 작용하지 못하도록 하는 첫 번째 접근 방식을 설명했습니다. 그러나 특정 레이아웃을 달성하기 위해 마크업에 요소를 명시적으로 추가하는 것은 마크업이 레이아웃에 관여해서는 안 된다는 계약을 위반하는 나쁜 방법입니다.</p>
<p>요소를 명시적으로 추가하는 대신 <code translate="no">:after</code> 의사 요소를 사용하여 <code translate="no">.clearfix</code>ed div의 끝에 추가 콘텐츠를 삽입할 수 있습니다. 이 패턴을 따르는 기본 클리어픽스는 다음과 같습니다:</p>
<div><div><pre translate="no"><code translate="no"><span>.clearfix</span><span>:after</span> <span>{
  <span><span>content</span>:<span> <span>""</span></span></span>;
  <span><span>display</span>:<span> table</span></span>;
  <span><span>clear</span>:<span> both</span></span>;
}</span>
<span>.left</span> <span>{
  <span><span>float</span>:<span> left</span></span>;
  <span><span>width</span>:<span> <span>15%</span></span></span>;
  <span><span>height</span>:<span> <span>40px</span></span></span>;
}</span>
</code></pre></div><div><pre translate="no"><code translate="no"><span>&lt;<span>div</span> <span>class</span>=<span>"clearfix blue"</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left blue"</span>&gt;</span>A<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left blue"</span>&gt;</span>B<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"clearfix green"</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left green"</span>&gt;</span>C<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left green"</span>&gt;</span>D<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"clearfix orange"</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left orange"</span>&gt;</span>E<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left orange"</span>&gt;</span>F<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
</code></pre></div></div><p>마지막으로 <code translate="no">.clearfix</code>ed 요소에 <code translate="no">overflow</code> 값을 <code translate="no">visible</code> 이외의 다른 값으로 설정하여 새로운 서식 컨텍스트를 설정하는 것도 효과가 있습니다. 이는 요소의 자동 높이가 계산되는 방식에도 영향을 미치므로(다음 장의 자세한 내용 참조) 높이를 계산할 때 부동 소수점이 고려됩니다:</p>
<div><div><pre translate="no"><code translate="no"><span>.clearfix</span> <span>{
  <span><span>overflow</span>:<span> auto</span></span>;
}</span>
<span>.left</span> <span>{
  <span><span>float</span>:<span> left</span></span>;
  <span><span>width</span>:<span> <span>15%</span></span></span>;
  <span><span>height</span>:<span> <span>40px</span></span></span>;
}</span>
</code></pre></div><div><pre translate="no"><code translate="no"><span>&lt;<span>div</span> <span>class</span>=<span>"clearfix blue"</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left blue"</span>&gt;</span>A<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left blue"</span>&gt;</span>B<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"clearfix green"</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left green"</span>&gt;</span>C<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left green"</span>&gt;</span>D<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"clearfix orange"</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left orange"</span>&gt;</span>E<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left orange"</span>&gt;</span>F<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
</code></pre></div></div><p>어떤 기술을 사용해야 할까요? 첫 번째 의사 요소 기반 기법은 요소 오버플로 문제를 피할 수 있기 때문에 더 일반적입니다. 오버플로를 <code translate="no">visible</code> 이외의 다른 이름으로 설정하면 콘텐츠가 잘리고 스크롤바가 표시될 수 있습니다. 아래 예시가 이를 보여줍니다:</p>
<div><div><pre translate="no"><code translate="no"><span>.clearfix-overflow</span> <span>{
  <span><span>overflow</span>:<span> auto</span></span>;
}</span>
<span>.clearfix-pseudo</span><span>:after</span> <span>{
  <span><span>content</span>:<span> <span>""</span></span></span>;
  <span><span>display</span>:<span> table</span></span>;
  <span><span>clear</span>:<span> both</span></span>;
}</span>
<span>.left</span> <span>{
  <span><span>float</span>:<span> left</span></span>;
  <span><span>width</span>:<span> <span>15%</span></span></span>;
  <span><span>height</span>:<span> <span>40px</span></span></span>;
}</span>
<span>.offset-1</span> <span>{
  <span><span>position</span>:<span> relative</span></span>;
  <span><span>top</span>:<span> <span>15px</span></span></span>;
}</span>
<span>.offset-2</span> <span>{
  <span><span>position</span>:<span> relative</span></span>;
  <span><span>top</span>:<span> <span>30px</span></span></span>;
}</span>
</code></pre></div><div><pre translate="no"><code translate="no"><span>&lt;<span>div</span> <span>class</span>=<span>"clearfix-overflow blue"</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left blue"</span>&gt;</span>A<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left offset-1 blue"</span>&gt;</span>B<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left offset-2 blue"</span>&gt;</span>C<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;<span>br</span>&gt;</span>
<span>&lt;<span>div</span> <span>class</span>=<span>"clearfix-pseudo green"</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left green"</span>&gt;</span>D<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left offset-1 green"</span>&gt;</span>E<span>&lt;/<span>div</span>&gt;</span>
  <span>&lt;<span>div</span> <span>class</span>=<span>"left offset-2 green"</span>&gt;</span>F<span>&lt;/<span>div</span>&gt;</span>
<span>&lt;/<span>div</span>&gt;</span>
</code></pre></div></div><p>이 예에서는 플로팅된 블록이 컨테이너 상자를 넘기도록 위에서 오프셋되어 있습니다.</p>
<p>첫 번째 행은 <code translate="no">overflow: auto</code> 수정 사항을 사용하여 부모 요소가 새 서식 컨텍스트를 설정하도록 합니다. 그러나 부작용으로 <code translate="no">overflow</code> 작동 방식도 변경되어 오버플로된 콘텐츠가 표시되지 않고 스크롤할 수 있게 됩니다.</p>
<p>두 번째 행은 의사 요소 접근 방식을 사용하여 행 끝에 <code translate="no">clear: both</code> 가 있는 의사 요소를 추가합니다. 이렇게 하면 기본값인 <code translate="no">overflow: visible</code> 값이 유지되므로 오버플로된 플로트가 계속 표시됩니다.</p>
<h2 id="absolute-fixed-positioning-scheme"><a href="#absolute-fixed-positioning-scheme"></a>절대/고정 위치 지정 방식</h2>
<p>절대/고정 위치 지정 방식은 마지막 위치 지정 방식입니다. 설명하기 매우 간단합니다. 상자는 포함된 블록에 대한 절대 오프셋으로 배치됩니다.</p>
<p>절대 위치 요소는 일반 흐름 위치 계산을 위해 무시되며 형제 부동 요소와 상호 작용하지 않습니다. 이후 형제 자매의 레이아웃에 영향을 미치지 않습니다. 절대 위치 요소에 포함된 플로트는 절대 위치 요소 내의 요소와만 상호 작용합니다.</p>
<p>사양에 명시된 대로:</p>
<blockquote>
<p>절대 위치 지정 모델에서 상자는 포함된 블록에 대해 명시적으로 오프셋됩니다. 이 상자는 일반 흐름에서 완전히 제거됩니다(이후 형제 자매에는 영향을 미치지 않음). 절대 위치 상자는 일반 흐름 자식과 절대(고정되지 않은) 위치 자손에 대한 새 포함 블록을 설정합니다. 그러나 절대적으로 배치된 요소의 내용은 다른 상자 주위로 흐르지 않습니다. 겹치는 상자의 스택 레벨에 따라 다른 상자의 내용을 가리거나 그 자체로 가려질 수 있습니다.</p>
</blockquote>
<p>절대 위치 지정을 트리거하는 <code translate="no">position</code> 속성에는 <code translate="no">position: absolute</code> 과 <code translate="no">position: fixed</code> 의 두 가지 값이 있습니다. 스펙에서는 이를 다음과 같이 정의합니다:</p>
<blockquote>
<p><em>절대</em>: 상자의 위치(및 가능하면 크기)는 'top', 'right', 'bottom', 'left' 속성으로 지정됩니다. 이러한 속성은 상자를 포함하는 블록에 대한 오프셋을 지정합니다. 절대적으로 배치된 상자는 일반 흐름에서 제외됩니다. 즉, 이후 형제의 레이아웃에 영향을 미치지 않습니다. 또한 절대적으로 배치된 상자는 여백이 있지만 다른 여백과 함께 접히지 않습니다.</p>
<p><em>고정</em>: 상자의 위치는 '절대' 모델에 따라 계산되지만 일부 참조에 대해 상자가 고정됩니다.</p>
</blockquote>
<p>고정 위치는 뷰포트에 상대적인 위치이고 절대 위치는 포함된 블록에 상대적인 위치입니다.</p>
<p>이러한 상자의 정확한 위치는 <code translate="no">width</code>, <code translate="no">height</code>, <code translate="no">top</code>, <code translate="no">left</code>, <code translate="no">bottom</code> 및 <code translate="no">right</code> 속성을 기반으로 합니다. 이러한 값이 명시적으로 설정되어 있으면 위치 지정이 매우 간단합니다. 그러나 값이 부분적으로 지정되어 있으면 계산이 훨씬 더 복잡해집니다.</p>

         
        </div></div>
	      </article>
			</main>
    </body>
  </html>
  