
  <html lang="ko">
    <head>
      <meta charset="utf-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>Reimagine Atomic CSS</title>
      <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
      <script src="//unpkg.com/alpinejs" defer></script>
    </head>
    <body x-data="{ dark: false }" x-bind:data-theme="dark ? 'dark' : 'light'">
      <main class="container">
      	<button x-on:click="dark = !dark" class="contrast outline">Switch Theme</button>
	      <article>
	        <div id="readability-page-1" class="page"><article><div><div><ul><li><a href="#what-is-atomic-css">아토믹 CSS란 무엇인가요?</a></li><li><a href="#the-background">배경</a></li><li><a href="#breakdown-atomic-css">아토믹 CSS 분석</a><ul><li><a href="#traditional-way">기존 방식</a></li><li><a href="#on-demand-way">온디맨드 방식</a></li></ul></li><li><a href="#the-itches">가려운 부분</a></li><li><a href="#introducing-unocss">UnoCSS 소개</a><ul><li><a href="#the-engine">엔진</a></li><li><a href="#intuitive-fully-customizable">직관적이고 완벽한 커스터마이징 가능</a></li><li><a href="#variants">변형</a></li><li><a href="#presets">프리셋</a></li><li><a href="#flexibility">유연성</a></li><li><a href="#scoping">스코핑</a></li></ul></li><li><a href="#performance">성능</a><ul><li><a href="#no-parsing-no-ast">파싱 없음, AST 없음</a></li><li><a href="#single-pass">단일 패스</a></li></ul></li><li><a href="#can-i-use-it-now">지금 사용할 수 있나요?</a></li><li><a href="#thanks">예</a></li><li><a href="#wrapping-up">마무리</a></li></ul></div><blockquote><p>이번 포스팅은 평소보다 조금 길어졌습니다. 제게는 꽤 중요한 발표이고 하고 싶은 얘기가 많기 때문입니다. 시간을 내어 읽어주시면 감사하겠습니다. 데스크톱을 사용 중이라면 왼쪽에 목차가 숨겨져 있습니다. 즐거운 시간 되세요 :)</p></blockquote><blockquote><p><a href="https://antfu.me/posts/reimagine-atomic-css-zh">中文 중국어 버전</a></p></blockquote><h2 id="what-is-atomic-css" tabindex="-1">아토믹 CSS란 무엇인가요? </h2><p>먼저 <strong>아토믹 CSS에</strong> 대해 제대로 정의해 보겠습니다:</p><p>존 폴라섹의 <a href="https://css-tricks.com/lets-define-exactly-atomic-css/" target="_blank" rel="noopener">이 글</a> 에서 발췌한 내용입니다:</p><blockquote><p>아토믹 CSS는 시각적 기능에 기반한 이름을 가진 작은 단일 목적의 클래스를 선호하는 CSS 아키텍처 접근 방식입니다.</p></blockquote><p>일부에서는 이를 함수형 CSS 또는 CSS 유틸리티라고 부르기도 합니다. 기본적으로 아토믹 CSS 프레임워크는 이와 같은 CSS의 집합이라고 할 수 있습니다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>.</span><span>m-0</span><span> {</span></span>
<span><span>  margin</span><span>:</span><span> 0</span><span>;</span></span>
<span><span>}</span></span>
<span><span>.</span><span>text-red</span><span> {</span></span>
<span><span>  color</span><span>:</span><span> red</span><span>;</span></span>
<span><span>}</span></span>
<span><span>/* ... */</span></span>
<span></span></code></pre><p><a href="https://tailwindcss.com/" target="_blank" rel="noopener">Tailwind CSS</a>, <a href="https://windicss.org/" target="_blank" rel="noopener">Windi CSS</a>, <a href="https://tachyons.io/" target="_blank" rel="noopener">Tachyons</a> 등과 같은 유틸리티를 우선으로 하는 CSS 프레임워크가 꽤 많이 있습니다. 또한 프레임워크를 보완하기 위해 일부 CSS 유틸리티와 함께 제공되는 일부 UI 라이브러리(예: <a href="https://getbootstrap.com/docs/5.1/utilities/api/" target="_blank" rel="noopener">Bootstrap</a> 및 <a href="https://chakra-ui.com/docs/features/style-props" target="_blank" rel="noopener">Chakra UI</a>)도 있습니다.</p><p>이미 여러 번 들어보셨을 것이므로 여기서는 원자 CSS 사용의 장단점에 대해 이야기하지 않겠습니다. 오늘은 프레임워크 작성자의 관점에서 여러분이 좋아하는 프레임워크를 구축하는 데 있어 어떤 장단점이 있는지, 그 한계는 무엇인지, 궁극적으로 여러분의 일상 업무에 도움이 되기 위해 무엇을 더 개선할 수 있는지 살펴보겠습니다.</p><h2 id="the-background" tabindex="-1">배경 </h2><p>시작하기 전에 배경에 대해 잠깐 이야기해 보겠습니다. 저를 잘 모르시는 분들을 위해 소개하자면, 저는 <a href="https://vitejs.dev/" target="_blank" rel="noopener">Vite</a> 팀원이자 Vite에서 가장 인기 있는 시작용 템플릿 중 하나인 <a href="https://github.com/antfu/vitesse" target="_blank" rel="noopener">Vitesse의</a> 제작자인 Anthony Fu입니다. 저는 아토믹 CSS(또는 CSS 유틸리티)의 빠른 개발 경험을 좋아하기 때문에 Vitesse의 기본 UI 프레임워크로 <a href="https://tailwindcss.com/" target="_blank" rel="noopener">Tailwind CSS를</a> 선택했습니다. 바이테스는 웹팩 등에 비해 엄청나게 빨라야 하지만, 메가바이트의 유틸리티 CSS를 생성하는 테일윈드 때문에 바이테스의 시작과 HMR이 예전처럼 느려졌습니다. 저는 한때 이것이 아토믹 CSS 솔루션을 사용하는 데 따른 일종의 트레이드 오프라고 생각했는데, <a href="https://windicss.org/" target="_blank" rel="noopener">Windi CSS를</a> 발견하기 전까지는 말이죠.</p><p><img src="https://antfu.me/images/discover-windicss.png"></p><p><a href="https://windicss.org/" target="_blank" rel="noopener">Windi C</a> SS는 테일윈드 CSS의 대안으로 처음부터 다시 작성되었습니다. 종속성이 전혀 없고 PostCSS와 자동 접두사에 의존하지 않습니다. 더 중요한 것은 <strong>온디맨드 방식으로 사용할</strong> 수 있다는 점입니다. Windi CSS는 나중에 제거하기 위해 거의 사용하지 않는 모든 유틸리티 조합을 생성하는 대신 코드베이스에 실제로 표시된 것만 생성합니다. 이는 Vite의 온디맨드 철학에 완벽하게 부합하며, 이론적으로는 Tailwind보다 훨씬 빠를 것입니다. 그래서 <a href="https://github.com/windicss/vite-plugin-windicss" target="_blank" rel="noopener">Vite 플러그인을</a> 작성했는데, 그 결과 Tailwind보다 <a href="https://twitter.com/antfu7/status/1361398324587163648" target="_blank" rel="noopener">20~100배 빠른</a> 것으로 나타났습니다.</p><p>그 후 Windi CSS는 팀으로 성장했고, <a href="https://windicss.org/features/value-auto-infer.html" target="_blank" rel="noopener">가치 추론</a>, <a href="https://windicss.org/features/variant-groups.html" target="_blank" rel="noopener">변형 그룹</a>, <a href="https://windicss.org/features/shortcuts.html" target="_blank" rel="noopener">단축키</a>, <a href="https://twitter.com/antfu7/status/1372244287975387145" target="_blank" rel="noopener">개발 도구 내 디자인</a>, <a href="https://twitter.com/windi_css/status/1387460661135896577" target="_blank" rel="noopener">어트리뷰티파이 모드</a> 등과 같은 더 많은 혁신을 이루었습니다. 그 결과, Tailwind는 자체 온디맨드 <a href="https://tailwindcss.com/docs/just-in-time-mode" target="_blank" rel="noopener">JIT 엔진을</a> <a href="https://twitter.com/adamwathan/status/1371542711086559237?s=20" target="_blank" rel="noopener">도입하게</a> 되었습니다.</p><h2 id="breakdown-atomic-css" tabindex="-1">아토믹 CSS 분석 </h2><p>다시 본론으로 돌아와서 아토믹 CSS가 어떻게 작동하는지 먼저 살펴보겠습니다.</p><h3 id="traditional-way" tabindex="-1">전통적인 방식 </h3><p>아토믹 CSS를 만드는 전통적인 방법은 사용자가 원하는 모든 CSS 유틸리티를 제공하는 것입니다. 예를 들어, 전처리기(이 경우 SCSS)를 사용하여 직접 생성할 수 있는 것이 있습니다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>// style.scss</span></span>
<span></span>
<span><span>@</span><span>for</span><span> $i</span><span> from</span><span> 1</span><span> through</span><span> 10</span><span> {</span></span>
<span><span>  .</span><span>m-</span><span>#{</span><span>$i</span><span>}</span><span> {</span></span>
<span><span>    margin</span><span>:</span><span> $i</span><span> /</span><span> 4</span><span> rem</span><span>;</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span></span></code></pre><p>로 컴파일됩니다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>.</span><span>m-1</span><span> {</span><span> margin</span><span>:</span><span> 0.25</span><span> rem</span><span>;</span><span> }</span></span>
<span><span>.</span><span>m-2</span><span> {</span><span> margin</span><span>:</span><span> 0.5</span><span> rem</span><span>;</span><span> }</span></span>
<span><span>/* ... */</span></span>
<span><span>.</span><span>m-10</span><span> {</span><span> margin</span><span>:</span><span> 2.5</span><span> rem</span><span>;</span><span> }</span></span>
<span></span></code></pre><p>이제 <code translate="no">class="m-1"</code> 을 사용하여 여백을 설정할 수 있습니다. 하지만 보시다시피 이 접근 방식에서는 여백을 1~10을 벗어난 값으로 설정할 수 없으며, 한 개만 사용하더라도 10개의 CSS 규칙을 전송하는 데 드는 비용을 지불해야 합니다. 나중에 <code translate="no">margin-top</code> 의 경우 <code translate="no">mt</code>, <code translate="no">mb</code> 의 경우 <code translate="no">margin-bottom</code> 과 같이 다른 여백 방향을 지원하려는 경우. 이 네 가지 방향을 사용하면 CSS 크기에 5를 곱하게 됩니다. 그런 다음 <code translate="no">hover:</code> 및 <code translate="no">focus:</code> 과 같은 변형에 관해서는 이야기를 알 수 있습니다. 이 시점에서 유틸리티를 하나 더 추가한다는 것은 종종 몇 킬로바이트가 추가된다는 것을 의미합니다. 따라서 기존 Tailwind가 메가바이트의 CSS를 제공하는 이유이기도 합니다.</p><p>이 문제를 해결하기 위해 Tailwind는 <a href="https://purgecss.com/" target="_blank" rel="noopener">PurgeCSS를</a> 사용하여 배포 번들을 스캔하고 필요하지 않은 규칙을 제거하는 솔루션을 고안했습니다. 이제 프로덕션 환경에서는 몇 KB의 CSS만 남았습니다. 하지만 퍼지는 프로덕션 빌드에서만 작동하므로 개발 중에는 여전히 엄청난 양의 CSS를 다루고 있다는 점에 유의하세요. 웹팩에서는 그다지 눈에 띄지 않았지만, 나머지 기능들이 엄청나게 빠르게 발전하고 있기 때문에 Vite에서는 골칫거리가 되고 있습니다.</p><p>생성 및 제거 방식에는 한계가 있지만 더 나은 해결책이 있을까요?</p><h3 id="on-demand-way" tabindex="-1">온디맨드 방식 </h3><p>"온디맨드" 아이디어는 완전히 새로운 사고 방식을 도입합니다. 두 가지 접근 방식을 비교해 보겠습니다.</p><p><img src="https://antfu.me/images/unocss-traditional-way.png"></p><p>기존의 방식은 불필요한 계산(생성은 되었지만 사용하지 않는) 비용이 발생할 뿐만 아니라 애초에 포함되지 않은 요구 사항도 충족할 수 없습니다.</p><p><img src="https://antfu.me/images/unocss-on-demand-way.png"></p><p>'온디맨드' 접근 방식은 '생성'과 '사용량 스캔'의 순서를 뒤집음으로써 낭비되는 계산 및 전송 비용을 절감하는 동시에 사전 생성으로는 충족할 수 없는 동적 요구 사항을 유연하게 제공할 수 있습니다. 또한 이 접근 방식은 개발과 프로덕션 모두에서 사용할 수 있으며, 일관성에 대한 확신을 높이고 HMR의 효율성을 높일 수 있습니다.</p><p>이를 위해 Windi CSS와 테일윈드 JIT는 모두 소스 코드를 사전 스캔하는 방식을 취합니다. 다음은 그 간단한 예입니다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>import</span><span> {</span><span> promises</span><span> as</span><span> fs</span><span> }</span><span> from</span><span> '</span><span>node:fs</span><span>'</span></span>
<span><span>import</span><span> glob</span><span> from</span><span> '</span><span>fast-glob</span><span>'</span></span>
<span></span>
<span><span>// this usually comes from user config</span></span>
<span><span>const </span><span>include</span><span> =</span><span> [</span><span>'</span><span>src/**/*.{jsx,tsx,vue,html}</span><span>'</span><span>]</span></span>
<span></span>
<span><span>async</span><span> function</span><span> scan</span><span>()</span><span> {</span></span>
<span><span>  const </span><span>files</span><span> =</span><span> await</span><span> glob</span><span>(</span><span>include</span><span>)</span></span>
<span></span>
<span><span>  for</span><span> (</span><span>const </span><span>file</span><span> of</span><span> files</span><span>)</span><span> {</span></span>
<span><span>    const </span><span>content</span><span> =</span><span> await</span><span> fs</span><span>.</span><span>readFile</span><span>(</span><span>file</span><span>,</span><span> '</span><span>utf8</span><span>'</span><span>)</span></span>
<span><span>    // pass the content to the generator and match for class usages</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>await</span><span> scan</span><span>()</span></span>
<span><span>// scanning is done before the build / dev process</span></span>
<span><span>await</span><span> buildOrStartDevServer</span><span>()</span></span>
<span></span></code></pre><p>개발 중에 HMR을 제공하려면 일반적으로 <a href="https://github.com/paulmillr/chokidar" target="_blank" rel="noopener">파일 감시자가</a> 필요합니다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>import</span><span> chokidar</span><span> from</span><span> '</span><span>chokidar</span><span>'</span></span>
<span></span>
<span><span>chokidar</span><span>.</span><span>watch</span><span>(</span><span>include</span><span>).</span><span>on</span><span>(</span><span>'</span><span>change</span><span>'</span><span>,</span><span> (</span><span>event</span><span>,</span><span> path</span><span>)</span><span> =&gt;</span><span> {</span></span>
<span><span>  // read the file again</span></span>
<span><span>  const </span><span>content</span><span> =</span><span> await</span><span> fs</span><span>.</span><span>readFile</span><span>(</span><span>file</span><span>,</span><span> '</span><span>utf8</span><span>'</span><span>)</span></span>
<span><span>  // pass the content to the generator again</span></span>
<span><span>  // invalidate the css module and send HMR event</span></span>
<span><span>})</span></span>
<span></span></code></pre><p>결과적으로 온디맨드 접근 방식을 통해 Windi CSS는 기존 Tailwind CSS보다 약 <a href="https://twitter.com/antfu7/status/1361398324587163648" target="_blank" rel="noopener">100배 빠른 성능을</a> 제공할 수 있습니다.</p><h2 id="the-itches" tabindex="-1">가려운 부분 </h2><p>저는 현재 거의 모든 앱에서 Windi CSS를 사용하고 있으며, 꽤 잘 작동합니다. 성능은 훌륭하고 HMR은 눈에 띄지 않습니다. <a href="https://windicss.org/features/value-auto-infer.html" target="_blank" rel="noopener">값 자동 추론</a> 및 속성 지정 <a href="https://twitter.com/windi_css/status/1387460661135896577" target="_blank" rel="noopener">모드를</a> 사용하면 개발 속도가 훨씬 빨라집니다. 이제 정말 푹 자고 다른 꿈을 꿀 수 있습니다. 하지만 가끔 달콤한 꿈에서 깨어날 때면 가려울 때가 있습니다.</p><p>제가 성가신 점은 제가 무엇을 얻고 있는지, 그리고 그것을 작동시키기 위해 무엇을 해야 하는지 불분명하다는 것입니다. 제 생각에 가장 이상적인 CSS는 눈에 보이지 않아야 합니다. 한 번 익히면 직관적이고 유추할 수 있어야 합니다. 예상대로 작동할 때는 눈에 보이지 않고, 그렇지 않을 때는 답답할 수 있습니다.</p><p>예를 들어, 테일윈드에서 <code translate="no">border-2</code> 은 테두리 너비의 <code translate="no">2px</code>, <code translate="no">4</code> 은 <code translate="no">4px</code>, <code translate="no">6</code> 는 <code translate="no">6px</code>, <code translate="no">8</code> 은 <code translate="no">8px</code> 을 의미하지만, <code translate="no">border-10</code> 은 <strong>작동하지 않습니다</strong> (알아내는 데 시간이 걸릴 수도 있습니다!). 이는 디자인 시스템을 일관성 있고 제한적으로 만들기 위해 Tailwind에서 의도적으로 설계한 것이라고 할 수 있습니다. 알았어요, 하지만 간단한 퀴즈를 하나 내볼게요. <strong> <code translate="no">border-10</code> 가 작동하게 하려면 어떻게 해야 하나요?</strong></p><p>글로벌 스타일 어딘가에 자신만의 유틸리티를 작성하시겠습니까?</p><pre translate="no" tabindex="0"><code translate="no"><span><span>.</span><span>border-10</span><span> {</span></span>
<span><span>  border-width</span><span>:</span><span> 10</span><span>px</span><span>;</span></span>
<span><span>}</span></span>
<span></span></code></pre><p>꽤 빠르고 간단합니다. 그리고 중요한 것은 작동한다는 것입니다. 하지만 솔직히 이 작업을 직접 수동으로 해야 한다면 애초에 Tailwind가 왜 필요할까요?</p><p>테일윈드에 대해 조금 더 알고 있다면 구성이 가능하다는 것을 알 수 있습니다. 그래서 5분 동안 문서를 검색하면 다음과 같은 결과를 <a href="https://tailwindcss.com/docs/border-width#border-widths" target="_blank" rel="noopener">얻을</a> 수 있습니다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>// tailwind.config.js</span></span>
<span><span>module</span><span>.</span><span>exports</span><span> =</span><span> {</span></span>
<span><span>  theme</span><span>:</span><span> {</span></span>
<span><span>    borderWidth</span><span>:</span><span> {</span></span>
<span><span>      DEFAULT</span><span>:</span><span> '</span><span>1px</span><span>'</span><span>,</span></span>
<span><span>      0</span><span>:</span><span> '</span><span>0</span><span>'</span><span>,</span></span>
<span><span>      2</span><span>:</span><span> '</span><span>2px</span><span>'</span><span>,</span></span>
<span><span>      3</span><span>:</span><span> '</span><span>3px</span><span>'</span><span>,</span></span>
<span><span>      4</span><span>:</span><span> '</span><span>4px</span><span>'</span><span>,</span></span>
<span><span>      6</span><span>:</span><span> '</span><span>6px</span><span>'</span><span>,</span></span>
<span><span>      8</span><span>:</span><span> '</span><span>8px</span><span>'</span><span>,</span></span>
<span><span>      10</span><span>:</span><span> '</span><span>10px</span><span>'</span><span> // &lt;-- here</span></span>
<span><span>    }</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span></span></code></pre><p>이제 모두 나열하고 다시 작업할 수 있겠군요... 잠깐만요, 제가 어디까지 말했었죠? 원래 진행 중이던 작업을 잃어버리고 다시 맥락으로 돌아가는 데 시간이 걸립니다. 나중에 테두리 색상을 설정하려면 문서를 다시 찾아서 어떻게 구성할 수 있는지 등을 확인해야 합니다. 누군가는 이 워크플로우를 좋아할지 모르지만 저는 그렇지 않습니다. 직관적으로 작동해야 하는 작업이 방해받는 것을 좋아하지 않거든요.</p><p>Windi CSS는 규칙을 좀 더 완화하여 가능한 한 해당 유틸리티를 제공하려고 노력합니다. 앞의 경우 <code translate="no">border-10</code> 는 Windi에서 바로 작동합니다(감사합니다!). 하지만 Windi는 Tailwind와 호환되기 때문에 Tailwind와 똑같은 구성 인터페이스를 사용해야 합니다. 숫자 추론은 Windi에서 작동하지만 사용자 정의 유틸리티를 추가하려는 경우 여전히 악몽이 될 수 있습니다. 다음은 <a href="https://tailwindcss.com/docs/plugins#escaping-class-names" target="_blank" rel="noopener">Tailwind의 문서에</a> 있는 예제입니다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>// tailwind.config.js</span></span>
<span><span>const </span><span>_</span><span> =</span><span> require</span><span>(</span><span>'</span><span>lodash</span><span>'</span><span>)</span></span>
<span><span>const </span><span>plugin</span><span> =</span><span> require</span><span>(</span><span>'</span><span>tailwindcss/plugin</span><span>'</span><span>)</span></span>
<span></span>
<span><span>module</span><span>.</span><span>exports</span><span> = {</span></span>
<span><span>  theme</span><span>: {</span></span>
<span><span>    rotate</span><span>: {</span></span>
<span><span>      '</span><span>1/4</span><span>'</span><span>: </span><span>'</span><span>90deg</span><span>'</span><span>,</span></span>
<span><span>      '</span><span>1/2</span><span>'</span><span>: </span><span>'</span><span>180deg</span><span>'</span><span>,</span></span>
<span><span>      '</span><span>3/4</span><span>'</span><span>: </span><span>'</span><span>270deg</span><span>'</span><span>,</span></span>
<span><span>    }</span></span>
<span><span>  },</span></span>
<span><span>  plugins</span><span>: [</span></span>
<span><span>    plugin</span><span>(({ </span><span>addUtilities</span><span>, </span><span>theme</span><span>, </span><span>e</span><span> }) =&gt; {</span></span>
<span><span>      const </span><span>rotateUtilities</span><span> =</span><span> _</span><span>.</span><span>map</span><span>(</span><span>theme</span><span>(</span><span>'</span><span>rotate</span><span>'</span><span>),</span><span> (</span><span>value</span><span>,</span><span> key</span><span>)</span><span> =&gt;</span><span> {</span></span>
<span><span>        return</span><span> {</span></span>
<span><span>          [</span><span>`</span><span>.</span><span>${</span><span>e</span><span>(</span><span>`</span><span>rotate-</span><span>${</span><span>key</span><span>}</span><span>`</span><span>)</span><span>}</span><span>`</span><span>]: {</span></span>
<span><span>            transform</span><span>: </span><span>`</span><span>rotate(</span><span>${</span><span>value</span><span>}</span><span>)</span><span>`</span></span>
<span><span>          }</span></span>
<span><span>        }</span></span>
<span><span>      })</span></span>
<span></span>
<span><span>      addUtilities</span><span>(</span><span>rotateUtilities</span><span>)</span></span>
<span><span>    })</span></span>
<span><span>  ]</span></span>
<span><span>}</span></span>
<span></span></code></pre><p>이것만으로도 충분합니다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>.</span><span>rotate-1</span><span>\/</span><span>4</span><span> {</span></span>
<span><span>  transform</span><span>:</span><span> rotate</span><span>(</span><span>90</span><span>deg</span><span>);</span></span>
<span><span>}</span></span>
<span><span>.</span><span>rotate-1</span><span>\/</span><span>2</span><span> {</span></span>
<span><span>  transform</span><span>:</span><span> rotate</span><span>(</span><span>180</span><span>deg</span><span>);</span></span>
<span><span>}</span></span>
<span><span>.</span><span>rotate-3</span><span>\/</span><span>4</span><span> {</span></span>
<span><span>  transform</span><span>:</span><span> rotate</span><span>(</span><span>270</span><span>deg</span><span>);</span></span>
<span><span>}</span></span>
<span></span></code></pre><p>CSS를 생성하는 코드는 결과물보다 훨씬 더 깁니다. 읽기 및 유지 관리가 어려울 뿐만 아니라 온디맨드 기능도 저하될 수 있습니다.</p><p>Tailwind의 API와 플러그인 시스템은 전통적인 사고방식으로 설계되어 새로운 온디맨드 접근 방식과 맞지 않습니다. 핵심 유틸리티는 제너레이터에 내장되어 있고 사용자 정의는 상당히 제한적입니다. 그래서 저는 이러한 부채를 버리고 온디맨드 접근 방식을 염두에 두고 처음부터 다시 설계하면 어떤 결과를 얻을 수 있을지 궁금해지기 시작했습니다.</p><h2 id="introducing-unocss" tabindex="-1">UnoCSS 소개 </h2><p>성능과 유연성을 극대화한 인스턴트 아토믹 CSS 엔진인<a href="https://github.com/antfu/unocss" target="_blank" rel="noopener"><strong>UnoCSS</strong></a>.</p><p>이 프로젝트는 휴가 기간 동안 무작위 실험에서 시작되었습니다. 온디맨드와 사용자로서 기대할 수 있는 유연성을 염두에 둔 실험은 여러모로 저에게 매우 유익했습니다.</p><h3 id="the-engine" tabindex="-1">엔진 </h3><p>UnoCSS는 <strong>핵심 유틸리티가 없기</strong> 때문에 <strong>프레임워크가</strong> 아닌 <strong>엔진이며</strong>, 모든 기능이 사전 설정 또는 인라인 구성을 통해 제공됩니다.</p><p>우리는 UnoCSS가 현존하는 대부분의 아토믹 CSS 프레임워크의 기능을 시뮬레이션할 수 있을 것으로 상상하고 있습니다. 그리고 새로운 아토믹 CSS 프레임워크를 만드는 엔진으로 사용될 수도 있습니다! 예를 들어</p><pre translate="no" tabindex="0"><code translate="no"><span><span>import</span><span> UnocssPlugin</span><span> from</span><span> '</span><span>@unocss/vite</span><span>'</span></span>
<span></span>
<span><span>// the following presets do not exist at this moment,</span></span>
<span><span>// contribution welcome!</span></span>
<span><span>import</span><span> PresetTachyons</span><span> from</span><span> '</span><span>@unocss/preset-tachyons</span><span>'</span></span>
<span><span>import</span><span> PresetBootstrap</span><span> from</span><span> '</span><span>@unocss/preset-bootstrap</span><span>'</span></span>
<span><span>import</span><span> PresetTailwind</span><span> from</span><span> '</span><span>@unocss/preset-tailwind</span><span>'</span></span>
<span><span>import</span><span> PresetWindi</span><span> from</span><span> '</span><span>@unocss/preset-windi</span><span>'</span></span>
<span><span>import</span><span> PresetAntfu</span><span> from</span><span> '</span><span>@antfu/oh-my-cool-unocss-preset</span><span>'</span></span>
<span></span>
<span><span>export</span><span> default</span><span> {</span></span>
<span><span>  plugins</span><span>: [</span></span>
<span><span>    UnocssPlugin</span><span>({</span></span>
<span><span>      presets</span><span>: [</span></span>
<span><span>        // PresetTachyons,</span></span>
<span><span>        PresetBootstrap</span><span>,</span></span>
<span><span>        // PresetTailwind,</span></span>
<span><span>        // PresetWindi,</span></span>
<span><span>        // PresetAntfu</span></span>
<span></span>
<span><span>        // pick one... or multiple!</span></span>
<span><span>      ]</span></span>
<span><span>    })</span></span>
<span><span>  ]</span></span>
<span><span>}</span></span>
<span></span></code></pre><p>어떻게 이런 것들이 가능했는지 살펴보겠습니다:</p><h3 id="intuitive-fully-customizable" tabindex="-1">직관적이고 완전한 커스터마이징 가능 </h3><p>UnoCSS의 주요 목표는 직관성과 사용자 정의입니다. 말 그대로 몇 초 만에 자신만의 유틸리티를 정의할 수 있습니다.</p><p>다음은 간단한 가이드입니다:</p><h6 id="static-rules" tabindex="-1">정적 규칙 </h6><p>아토믹 CSS는 그 양이 엄청나게 많을 수 있습니다. 규칙을 간단하고 읽기 쉽게 정의하는 것이 중요합니다. UnoCSS에 대한 사용자 정의 규칙을 만들려면 다음과 같이 작성하면 됩니다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>rules</span><span>:</span><span> [</span></span>
<span><span>  [</span><span>'</span><span>m-1</span><span>'</span><span>,</span><span> { </span><span>margin</span><span>: </span><span>'</span><span>0.25rem</span><span>'</span><span> }]</span></span>
<span><span>]</span></span>
<span></span></code></pre><p>사용자의 코드베이스에서 <code translate="no">m-1</code> 이 감지될 때마다 다음과 같은 CSS가 생성됩니다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>.</span><span>m-1</span><span> {</span><span> margin</span><span>:</span><span> 0.25</span><span>rem</span><span>;</span><span> }</span></span>
<span></span></code></pre><h6 id="dynamic-rules" tabindex="-1">동적 규칙 </h6><p>동적으로 만들려면 일치자를 RegExp로 변경하고 본문은 함수로 변경합니다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>rules</span><span>:</span><span> [</span></span>
<span><span>  [</span><span>/</span><span>^</span><span>m-</span><span>(</span><span>\d</span><span>+</span><span>)</span><span>$</span><span>/</span><span>,</span><span> ([,</span><span> d</span><span>])</span><span> =&gt;</span><span> ({ </span><span>margin</span><span>: </span><span>`</span><span>${</span><span>d </span><span>/</span><span> 4</span><span>}</span><span>rem</span><span>`</span><span> })],</span></span>
<span><span>  [</span><span>/</span><span>^</span><span>p-</span><span>(</span><span>\d</span><span>+</span><span>)</span><span>$</span><span>/</span><span>,</span><span> match</span><span> =&gt;</span><span> ({ </span><span>padding</span><span>: </span><span>`</span><span>${</span><span>match</span><span>[</span><span>1</span><span>]</span><span> /</span><span> 4</span><span>}</span><span>rem</span><span>`</span><span> })],</span></span>
<span><span>]</span></span>
<span></span></code></pre><p>본문 함수의 첫 번째 인수는 일치 결과이므로 이 함수를 분해하여 RegExp 일치 그룹을 가져올 수 있습니다.</p><p>예를 들어</p><pre translate="no" tabindex="0"><code translate="no"><span><span>&lt;</span><span>div</span><span> class</span><span>=</span><span>"</span><span>m-100</span><span>"</span><span>&gt;</span></span>
<span><span>  &lt;</span><span>button</span><span> class</span><span>=</span><span>"</span><span>m-3</span><span>"</span><span>&gt;</span></span>
<span><span>    &lt;</span><span>icon</span><span> class</span><span>=</span><span>"</span><span>p-5</span><span>"</span><span> /&gt;</span></span>
<span><span>    My Button</span></span>
<span><span>  &lt;/</span><span>button</span><span>&gt;</span></span>
<span><span>&lt;/</span><span>div</span><span>&gt;</span></span>
<span></span></code></pre><p>를 사용하면 해당 CSS가 생성됩니다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>.</span><span>m-100</span><span> {</span><span> margin</span><span>:</span><span> 25</span><span>rem</span><span>;</span><span> }</span></span>
<span><span>.</span><span>m-3</span><span> {</span><span> margin</span><span>:</span><span> 0.75</span><span>rem</span><span>;</span><span> }</span></span>
<span><span>.</span><span>p-5</span><span> {</span><span> padding</span><span>:</span><span> 1.25</span><span>rem</span><span>;</span><span> }</span></span>
<span></span></code></pre><p>그게 다입니다. 동일한 패턴을 사용하는 유틸리티를 더 추가하기만 하면 이제 자신만의 아토믹 CSS가 실행됩니다!</p><h3 id="variants" tabindex="-1">변형 </h3><p>UnoCSS의<a href="https://windicss.org/utilities/variants.html#variants" target="_blank" rel="noopener">변형도</a> 간단하지만 강력합니다. 다음은 몇 가지 예시입니다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>variants</span><span>:</span><span> [</span></span>
<span><span>  // support `hover:` for all rules</span></span>
<span><span>  {</span></span>
<span><span>    match</span><span>: </span><span>s</span><span> =&gt; </span><span>s</span><span>.</span><span>startsWith</span><span>(</span><span>'</span><span>hover:</span><span>'</span><span>) </span><span>?</span><span> s</span><span>.</span><span>slice</span><span>(</span><span>6</span><span>) </span><span>:</span><span> null</span><span>,</span></span>
<span><span>    selector</span><span>: </span><span>s</span><span> =&gt; </span><span>`</span><span>${</span><span>s</span><span>}</span><span>:hover</span><span>`</span><span>,</span></span>
<span><span>  },</span></span>
<span><span>  // support `!` prefix to make the rule important</span></span>
<span><span>  {</span></span>
<span><span>    match</span><span>: </span><span>s</span><span> =&gt; </span><span>s</span><span>.</span><span>startsWith</span><span>(</span><span>'</span><span>!</span><span>'</span><span>) </span><span>?</span><span> s</span><span>.</span><span>slice</span><span>(</span><span>1</span><span>) </span><span>:</span><span> null</span><span>,</span></span>
<span><span>    rewrite</span><span>: (</span><span>entries</span><span>) =&gt; {</span></span>
<span><span>      // append ` !important` to all css values</span></span>
<span><span>      entries</span><span>.</span><span>forEach</span><span>(</span><span>e</span><span> =&gt; </span><span>e</span><span>[</span><span>1</span><span>] </span><span>+=</span><span> '</span><span> !important</span><span>'</span><span>)</span></span>
<span><span>      return</span><span> entries</span></span>
<span><span>    },</span></span>
<span><span>  }</span></span>
<span><span>]</span></span>
<span></span></code></pre><p>변형의 구성은 약간 고급적일 수 있습니다. 글의 길이가 길기 때문에 여기서는 자세한 설명을 생략하고 자세한 내용은 <a href="https://github.com/antfu/unocss#custom-variants" target="_blank" rel="noopener">문서를</a> 참조하세요.</p><h3 id="presets" tabindex="-1">사전 설정 </h3><p>이제 사용자 정의 규칙과 변형을 프리셋에 담아 다른 사람들과 공유할 수도 있고, UnoCSS 위에 자신만의 아토믹 CSS 프레임워크를 만들 수도 있습니다!</p><p>한편, 빠르게 사용할 수 있도록 <a href="https://github.com/antfu/unocss#presets" target="_blank" rel="noopener">몇 가지 사전 설정이</a> 함께 제공됩니다.</p><p>한 가지 언급할 만한 점은 기본 <a href="https://github.com/antfu/unocss/tree/main/packages/preset-uno" target="_blank" rel="noopener"><code translate="no">@unocss/preset-uno</code></a> 프리셋<strong>(아직 실험</strong> 단계)은 Tailwind CSS, Windi CSS, 부트스트랩, 타키온 등 인기 있는 유틸리티 우선 프레임워크의 일반적인 상위 집합입니다.</p><p>예를 들어 <code translate="no">ml-3</code> (Tailwind), <code translate="no">ms-2</code> (부트스트랩), <code translate="no">ma4</code> (타키온), <code translate="no">mt-10px</code> (Windi CSS)가 모두 유효합니다.</p><pre translate="no" tabindex="0"><code translate="no"><span><span>.</span><span>ma4</span><span> {</span><span> margin</span><span>:</span><span> 1</span><span>rem</span><span>;</span><span> }</span></span>
<span><span>.</span><span>ml-3</span><span> {</span><span> margin-left</span><span>:</span><span> 0.75</span><span>rem</span><span>;</span><span> }</span></span>
<span><span>.</span><span>ms-2</span><span> {</span><span> margin-inline-start</span><span>:</span><span> 0.5</span><span>rem</span><span>;</span><span> }</span></span>
<span><span>.</span><span>mt-10px</span><span> {</span><span> margin-top</span><span>:</span><span> 10</span><span>px</span><span>;</span><span> }</span></span>
<span></span></code></pre><p><a href="https://github.com/antfu/unocss/tree/main/packages/preset-uno" target="_blank" rel="noopener">기본 프리셋에 대해 자세히 알아</a>보세요.</p><h3 id="flexibility" tabindex="-1">유연성 </h3><p>지금까지 UnoCSS를 사용하여 Tailwind의 동작을 모방하는 방법을 소개해 드렸지만, 사용자 입장에서는 그것만으로는 큰 차이를 느끼지 못할 것입니다.</p><p>이제 UnoCSS의 진정한 힘을 발휘해 봅시다:</p><h6 id="attributify-mode" tabindex="-1">속성 지정 모드 </h6><p>어트리뷰티<a href="https://windicss.org/posts/v30.html#attributify-mode" target="_blank" rel="noopener">모드는</a> Windi CSS에서 가장 사랑받는 기능 중 하나입니다. 속성을 사용하여 유틸리티를 더 잘 구성하고 그룹화할 수 있습니다.</p><p>이 기능을 사용하면 테일윈드 코드가 다음과 같이 바뀝니다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>&lt;</span><span>button</span><span> class</span><span>=</span><span>"</span><span>bg-blue-400 hover:bg-blue-500 text-sm text-white font-mono font-light py-2 px-4 rounded border-2 border-blue-200 dark:bg-blue-500 dark:hover:bg-blue-600</span><span>"</span><span>&gt;</span></span>
<span><span>  Button</span></span>
<span><span>&lt;/</span><span>button</span><span>&gt;</span></span>
<span></span></code></pre><p>에서:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>&lt;</span><span>button</span></span>
<span><span>  bg</span><span>=</span><span>"</span><span>blue-400 hover:blue-500 dark:blue-500 dark:hover:blue-600</span><span>"</span></span>
<span><span>  text</span><span>=</span><span>"</span><span>sm white</span><span>"</span></span>
<span><span>  font</span><span>=</span><span>"</span><span>mono light</span><span>"</span></span>
<span><span>  p</span><span>=</span><span>"</span><span>y-2 x-4</span><span>"</span></span>
<span><span>  border</span><span>=</span><span>"</span><span>2 rounded blue-200</span><span>"</span></span>
<span><span>&gt;</span></span>
<span><span>  Button</span></span>
<span><span>&lt;/</span><span>button</span><span>&gt;</span></span>
<span></span></code></pre><p>이렇게 하면 카테고리별로 더 잘 정리할 수 있을 뿐만 아니라 동일한 접두사를 반복적으로 입력하는 수고를 덜 수 있습니다.</p><p>UnoCSS에서는 총 <strong>100줄 미만의 코드에</strong> <a href="https://github.com/antfu/unocss/blob/main/packages/preset-attributify/src/variant.ts" target="_blank" rel="noopener"><strong>하나의 변형과</strong></a> <a href="https://github.com/antfu/unocss/blob/main/packages/preset-attributify/src/extractor.ts" target="_blank" rel="noopener"><strong>하나의 추출기만</strong></a> 사용하여 어트리뷰티파이 모드를 구현했습니다! 더 중요한 것은 사용자가 정의한 모든 사용자 정의 규칙에 대해 직접 작동한다는 것입니다!</p><p>Windi의 Attributify 모드 외에도 몇 줄의 변경만으로 값 없는 속성도 지원합니다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>&lt;</span><span>div</span><span> class</span><span>=</span><span>"</span><span>m-2 rounded text-teal-400</span><span>"</span><span> /</span><span>&gt;</span></span>
<span></span></code></pre><p>이제 다음과 같이 할 수 있습니다.</p><pre translate="no" tabindex="0"><code translate="no"><span><span>&lt;</span><span>div</span><span> m-2</span><span> rounded</span><span> text-teal-400</span><span> /</span><span>&gt;</span></span>
<span></span></code></pre><p>어트리뷰티 모드는 프리셋을 통해 제공됩니다. <a href="https://github.com/antfu/unocss/blob/main/packages/preset-attributify" target="_blank" rel="noopener"><code translate="no">@unocss/preset-attributify</code></a>를 통해 제공되며, 자세한 사용법은 해당 문서를 참조하세요.</p><h6 id="pure-css-icons" tabindex="-1">순수 CSS 아이콘 </h6><p>이전 글인 <a href="https://antfu.me/posts/journey-with-icons-continues">아이콘과의 여정을</a> 읽어보셨다면 제가 아이콘에 대해 매우 열정적이고 아이콘 솔루션에 대해 적극적으로 연구하고 있다는 사실을 알고 계실 것입니다. 이번에는 UnoCSS의 유연성 덕분에 순수 CSS 아이콘도 만들 수 있게 되었습니다! 네, <strong>자바스크립트 없이 순수하게 CSS로만</strong> 이루어진 아이콘입니다! 어떻게 생겼는지 한번 살펴봅시다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>&lt;!-- A basic anchor icon from Phosphor icons --&gt;</span></span>
<span><span>&lt;</span><span>div</span><span> class</span><span>=</span><span>"</span><span>i-ph-anchor-simple-thin</span><span>"</span><span> /</span><span>&gt;</span></span>
<span><span>&lt;!-- An orange alarm from Material Design Icons --&gt;</span></span>
<span><span>&lt;</span><span>div</span><span> class</span><span>=</span><span>"</span><span>i-mdi-alarm text-orange-400 hover:text-teal-400</span><span>"</span><span> /</span><span>&gt;</span></span>
<span><span>&lt;!-- A large Vue logo --&gt;</span></span>
<span><span>&lt;</span><span>div</span><span> class</span><span>=</span><span>"</span><span>i-logos-vue text-3xl</span><span>"</span><span> /</span><span>&gt;</span></span>
<span><span>&lt;!-- Sun in light mode, Moon in dark mode, from Carbon --&gt;</span></span>
<span><span>&lt;</span><span>button</span><span> class</span><span>=</span><span>"</span><span>i-carbon-sun dark:i-carbon-moon</span><span>"</span><span> /</span><span>&gt;</span></span>
<span><span>&lt;!-- Twemoji of laugh, turns to tear on hovering --&gt;</span></span>
<span><span>&lt;</span><span>div</span></span>
<span><span>  class</span><span>=</span><span>"</span><span>i-twemoji-grinning-face-with-smiling-eyes hover:i-twemoji-face-with-tears-of-joy</span><span>"</span></span>
<span><span>/</span><span>&gt;</span></span>
<span></span></code></pre><p>변형과 결합하여 호버링 상태 또는 색상 스키마에 따라 아이콘을 전환할 수도 있습니다. 위의 데모로 직접 플레이해 보세요. 멋진 <a href="https://iconify.design/" target="_blank" rel="noopener">Iconify</a> 프로젝트 덕분에 100개 이상의 인기 아이콘 세트에서 <strong>10,000개</strong> 이상의 아이콘을 <strong>온디맨드</strong> 방식으로 이용할 수 있습니다.</p><p>다시 한 번 강조하지만, 이 기능은 100줄 미만의 코드로 작성되었습니다. 프리셋의 구현을 확인해보세요. <a href="https://github.com/antfu/unocss/blob/main/packages/preset-icons" target="_blank" rel="noopener"><code translate="no">@unocss/preset-icons</code></a> 를 확인하여 마법을 배워보세요!</p><blockquote><p>업데이트: 새 글 <a href="https://antfu.me/posts/icons-in-pure-css">Icons in Pure CSS에서</a> 더 자세히 알아보세요!</p></blockquote><p>이 프리셋을 통해 UnoCSS의 유연성에 대한 대략적인 아이디어를 얻을 수 있기를 바랍니다. 아직 초기 단계이기 때문에 더 많은 가능성을 탐색할 수 있습니다.</p><h3 id="scoping" tabindex="-1">범위 지정 </h3><p>Tailwind/Windi를 사용할 때 직면한 또 다른 문제는 프리플라이트입니다. 프리플라이트는 네이티브 요소를 재설정하고 CSS 변수에 대한 몇 가지 폴백을 제공하기 때문에 Tailwind/Windi만 사용하는 새 앱을 개발할 때 유용하지만, 다른 UI 프레임워크와 함께 작동하도록 하거나 Tailwind 유틸리티를 사용하여 일부 컴포넌트를 공유하려는 경우 프리플라이트가 기존 UI를 손상시키는 많은 충돌을 유발하는 경우가 종종 있습니다.</p><p>그래서 UnoCSS는 프리플라이트 기능을 지원하지 않는 또 다른 적극적인 조치를 취했습니다. 대신 사용자(또는 UnoCSS 위에 있는 프레임워크)가 필요에 맞는 CSS 재설정을 사용할 수 있도록 CSS 재설정에 대한 제어를 완전히 맡겼습니다(Normalize.css, Reset.css 또는 UI 프레임워크의 재설정 등).</p><p>이를 통해 UnoCSS는 CSS 범위 지정에 더 많은 가능성을 가질 수 있습니다. 예를 들어, Vite 플러그인에서 실험적으로 <code translate="no">scoped-vue</code> 모드를 사용하면 각 컴포넌트에 대해 범위가 지정된 스타일을 생성할 수 있으므로 사용자의 CSS와 충돌할 걱정 없이 원자 CSS를 사용하여 컴포넌트 라이브러리로 안전하게 출시할 수 있습니다. 예를 들어</p><pre translate="no" tabindex="0"><code translate="no"><span><span>&lt;</span><span>template</span><span>&gt;</span></span>
<span><span>  &lt;</span><span>div</span><span> class</span><span>=</span><span>"</span><span>m-2 rounded</span><span>"</span><span>&gt;</span></span>
<span><span>    &lt;</span><span>slot</span><span> /</span><span>&gt;</span></span>
<span><span>  &lt;/</span><span>div</span><span>&gt;</span></span>
<span><span>&lt;/</span><span>template</span><span>&gt;</span></span>
<span></span>
<span><span>&lt;!-- the following will be inject in the bundler --&gt;</span></span>
<span><span>&lt;</span><span>style</span><span> scoped</span><span>&gt;</span></span>
<span><span>.</span><span>m-2</span><span> {</span></span>
<span><span>  margin</span><span>:</span><span> 0.5</span><span>rem</span><span>;</span></span>
<span><span>}</span></span>
<span><span>.</span><span>rounded</span><span> {</span></span>
<span><span>  border-radius</span><span>:</span><span> 0.25</span><span>rem</span><span>;</span></span>
<span><span>}</span></span>
<span><span>&lt;/</span><span>style</span><span>&gt;</span></span>
<span></span></code></pre><p>또한 웹 컴포넌트 지원, MPA를 위한 CSS 코드 분할, 모듈 수준 CSS 스코핑 등과 같은 더 많은 가능성을 실험하고 있습니다.</p><h2 id="performance" tabindex="-1">성능 </h2><p>UnoCSS가 제공하는 모든 유연성과 상상력을 고려할 때 솔직히 성능은 덜 중요할 수 있다고 생각합니다. 호기심에 성능을 비교하기 위해 <a href="https://github.com/antfu/unocss/tree/main/bench" target="_blank" rel="noopener">간단한 벤치마크를</a> 작성했습니다. 그리고 놀랍게도 결과는 다음과 같습니다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>10/21/2021, 2:17:45 PM</span></span>
<span><span>1656 utilities | x50 runs</span></span>
<span></span>
<span><span>none                            8.75 ms /    0.00 ms</span></span>
<span><span>unocss       v0.0.0            13.72 ms /    4.97 ms (x1.00)</span></span>
<span><span>windicss     v3.1.9           980.41 ms /  971.66 ms (x195.36)</span></span>
<span><span>tailwindcss  v3.0.0-alpha.1  1258.54 ms / 1249.79 ms (x251.28)</span></span>
<span></span></code></pre><p>UnoCSS가 <strong>Tailwind의 JIT 및 Windi CSS보다 200배 더 빠르다는</strong> 것이 밝혀졌습니다. 솔직히 말해서, 온디맨드 접근 방식에서는 Windi와 Tailwind JIT 모두 이미 매우 빠르기 때문에 UnoCSS의 성능 향상은 눈에 띄지 않을 수 있습니다. 하지만 오버헤드가 거의 없기 때문에 성능 저하를 걱정하지 않고 기존 프로젝트에 UnoCSS를 통합하여 점진적인 솔루션으로 다른 프레임워크와 함께 작업할 수 있습니다.</p><p>실제로 UnoCSS는 많은 성능 최적화를 수행했습니다. 궁금하신 분들을 위해 그 중 몇 가지를 소개해드리겠습니다:</p><h3 id="no-parsing-no-ast" tabindex="-1">노 파싱, 노 AST </h3><p>내부적으로 Tailwind는 PostCSS의 AST를 수정하는 데 의존했고, Windi는 사용자 정의 파서와 AST를 작성했습니다. 개발 과정에서 유틸리티의 변경은 일반적으로 예상하지 못한다는 사실을 감안하여, UnoCSS는 전체 파서 및 생성 프로세스를 도입하는 대신 매우 저렴한 문자열 연결을 통해 유틸리티를 생성합니다. 한편, UnoCSS는 생성된 CSS 문자열을 클래스 이름에 적극적으로 캐싱하여 동일한 유틸리티를 다시 볼 때 전체 매칭 및 생성 프로세스를 우회할 수 있습니다.</p><h3 id="single-pass" tabindex="-1">단일 패스 </h3><p>이전 섹션에서 언급했듯이 Windi CSS와 Tailwind JIT는 모두 파일 시스템 사전 검색에 의존하고 HMR에 fs watcher를 사용합니다. 파일 IO는 필연적으로 약간의 오버헤드를 발생시키며, 빌드 도구는 실제로 파일을 다시 한 번 로드해야 합니다. 그렇다면 개발 도구에서 이미 읽은 콘텐츠를 직접 활용하면 어떨까요?</p><p>독립적인 생성기 코어를 제외하고, UnoCSS는 의도적으로 Vite와의 최상의 통합에 집중할 수 있도록 Vite 플러그인만 제공합니다.</p><blockquote><p>업데이트: 이제 <a href="https://github.com/antfu/unocss/tree/main/packages/webpack" target="_blank" rel="noopener">웹팩 플러그인과</a> <a href="https://github.com/antfu/unocss/tree/main/packages/runtime" target="_blank" rel="noopener">CSS-in-JS 런타임도</a> 제공합니다.</p></blockquote><p>Vite에서는 <code translate="no">transform</code> 훅이 콘텐츠가 포함된 모든 파일과 함께 반복됩니다. 따라서 다음과 같이 수집하는 플러그인을 작성할 수 있습니다:</p><pre translate="no" tabindex="0"><code translate="no"><span><span>export</span><span> default</span><span> {</span></span>
<span><span>  plugins</span><span>: [</span></span>
<span><span>    {</span></span>
<span><span>      name</span><span>: </span><span>'</span><span>unocss</span><span>'</span><span>,</span></span>
<span><span>      transform</span><span>(</span><span>code</span><span>, </span><span>id</span><span>) {</span></span>
<span><span>        // filter out the files you don't want to scan</span></span>
<span><span>        if</span><span> (</span><span>!</span><span>filter</span><span>(</span><span>id</span><span>))</span></span>
<span><span>          return</span></span>
<span></span>
<span><span>        // scan the code (also handles invalidate on dev)</span></span>
<span><span>        scan</span><span>(</span><span>code</span><span>, </span><span>id</span><span>)</span></span>
<span></span>
<span><span>        // we just want the content, so we don't transform the code</span></span>
<span><span>        return</span><span> null</span></span>
<span><span>      },</span></span>
<span><span>      resolveId</span><span>(</span><span>id</span><span>) {</span></span>
<span><span>        return</span><span> id</span><span> ===</span><span> VIRTUAL_CSS_ID</span><span> ?</span><span> id</span><span> :</span><span> null</span></span>
<span><span>      },</span></span>
<span><span>      async</span><span> load</span><span>(</span><span>id</span><span>) {</span></span>
<span><span>        // generated css is provide as a virtual module</span></span>
<span><span>        if</span><span> (</span><span>id</span><span> ===</span><span> VIRTUAL_CSS_ID</span><span>)</span></span>
<span><span>          return</span><span> { </span><span>code</span><span>: </span><span>await</span><span> generate</span><span>() }</span></span>
<span><span>      }</span></span>
<span><span>    }</span></span>
<span><span>  ]</span></span>
<span><span>}</span></span>
<span></span></code></pre><p>Vite가 HMR도 처리하고 파일 변경 시 <code translate="no">transform</code> 훅을 다시 포함한다는 점을 감안하면, UnoCSS는 파일 IO와 fs 와처의 중복 없이 모든 것을 한 번에 완료할 수 있습니다. 또한 이 접근 방식에서는 파일 글로빙 대신 모듈 그래프에 의존하여 스캔을 수행합니다. 즉, 앱에 번들로 포함된 모듈만 폴더 아래의 파일 대신 생성된 CSS에 영향을 미칩니다.</p><p>더 많은 성능을 끌어내기 위해 수행한 몇 가지 트릭이 더 있습니다. 나중에 다른 포스팅을 작성할 수도 있지만, 그 전에 코드를 읽고 알아볼 수 있습니다.)</p><h2 id="can-i-use-it-now" tabindex="-1">지금 사용할 수 있나요? </h2><p>짧은 대답입니다: 예, 하지만 주의가 필요합니다.</p><p>UnoCSS는 아직 실험 중입니다. 그러나 단순성을 고려할 때 생성 결과는 이미 상당히 신뢰할 수 있습니다. 한 가지 주의해야 할 점은 API가 아직 완성되지 않았다는 점입니다. 실제로 출시될 때 Semver를 따라갈 예정이지만 변경 사항이 있을 수 있습니다.</p><p>Windi CSS 또는 Tailwind를 대체할 수 있도록 설계되지 않았습니다(Windi CSS v4를 기다려 보세요). 기존 프로젝트를 UnoCSS로 완전히 마이그레이션하는 것은 권장하지 않습니다. 새 프로젝트에서 사용해 보거나 기존 CSS 프레임워크와 함께 보완적으로 사용할 수 있습니다(예: 기본 사전 설정을 비활성화하고 순수 CSS 아이콘에만 아이콘 사전 설정을 사용하거나 사용자 정의 규칙을 만들 수 있습니다).</p><p>참고로 지금 <a href="https://github.com/antfu/antfu.me" target="_blank" rel="noopener">읽고 계신 사이트는</a> UnoCSS로만 운영되고 있으니 참고하시기 바랍니다.</p><p>한편, 여러분이 만들고 있는 프리셋을 자유롭게 공유하거나 기본 프리셋에 기여해 주세요. 여러분이 어떤 것을 만들어낼 수 있을지 기대됩니다!</p><h2 id="thanks" tabindex="-1">감사합니다 </h2><p>(A-Z)의 초기 리뷰와 피드백에 감사드립니다:</p><ul><li><a href="https://github.com/alexanderniebuhr" target="_blank" rel="noopener">알렉산더 부어</a></li><li><a href="https://github.com/ElMassimo" target="_blank" rel="noopener">엘 마시모</a></li><li><a href="https://github.com/harlan-zw" target="_blank" rel="noopener">harlan-zw</a></li><li><a href="https://github.com/QC-L" target="_blank" rel="noopener">@QC-L</a></li><li><a href="https://github.com/userquin" target="_blank" rel="noopener">유저퀸</a></li><li><a href="https://github.com/voorjaar" target="_blank" rel="noopener">@voorjaar</a></li><li><a href="https://github.com/wheatjs" target="_blank" rel="noopener">wheatjs</a></li></ul><h2 id="wrapping-up" tabindex="-1">마무리 </h2><p>읽어주셔서 감사합니다! 관심이 있으셨다면 저장소에서 자세한 내용을 확인하고 <a href="https://github.com/unocss/unocss" target="_blank" rel="noopener"><code translate="no">unocss/unocss</code></a> 에서 자세한 내용을 확인하고 <a href="https://unocss.antfu.me/" target="_blank" rel="noopener"><strong>온라인 플레이그라운드에서</strong></a> 플레이해 보세요.</p><p><a href="https://twitter.com/antfu7/status/1452802545118711812" target="_blank" rel="noopener">이 트윗에</a> 댓글을 달거나 리트윗하여 여러분의 생각을 알려주세요! 🙌</p></div></article></div>
	      </article>
			</main>
    </body>
  </html>
  