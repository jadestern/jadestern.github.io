
  <html lang="ko">
    <head>
      <meta charset="utf-8">
      <title>Why I Program in Erlang – Evan Miller</title>
      <link rel="canonical" href="https://www.evanmiller.org/why-i-program-in-erlang.html">
      <style>
        pre {
          padding: 1rem;
          background-color: #263238;
          color: #fff
        }
      </style>
    </head>
    <body>
      <article>
        <div id="readability-page-1" class="page"><div id="content">

<p>By <a href="https://www.evanmiller.org/">에반 밀러</a></p>

<p><em>2012년 10월 20일</em></p>

<p>번역: 
<a href="https://mobilemall.pk/blog/why-i-program-in-erlang/" rel="nofollow">우르두어</a> </p>




<p><a href="https://en.wikipedia.org/wiki/Erlang_(programming_language)">Erlang은</a> 25년 된 프로그래밍 언어로, 아직 인기 경연 대회에서 우승한 적이 없으며, 구문의 아름다움은 물론이고 속도에 대한 메달도 수상하지 못할 것이 거의 확실합니다. 이 언어는 느리고, 어색하고, 못생겼습니다. Erlang 코드를 리팩토링하는 것은 고통스럽습니다.</p>

<p>하지만 거의 5년 동안 저는 여가 시간의 대부분을 Erlang으로 프로그래밍했고, 이 시점에서 저는 이 언어와 함께한 시간이 천 시간이 훨씬 넘습니다. 대략적인 시간 순서에 따라 CSV 파서(웃지 마세요. 시간순이라고 했으니), 템플릿 컴파일러, 객체 관계형 매퍼, 서식 있는 텍스트 파서, 이미지 리사이저, 언어 전처리기, 웹 프레임워크 및 분산 메시지 큐를 작성하는 데 이 언어를 사용했습니다. 다음은 제가 전문적으로 사용해 본 다른 언어(C, Java, Perl, PHP, Ruby, Objective-C, JavaScript)와 비교하여 느낀 소감입니다.</p>

<p>Erlang에 대한 좋은 소식은 이것으로 요약할 수 있습니다: <em>Erlang은 25년 동안 언어와 플랫폼에 대한 올바른 설계 결정의 정점입니다.</em> Erlang의 어떤 기능이 어떻게 작동하는지 궁금할 때마다 저는 그 해답에 실망한 적이 한 번도 없었습니다. 저는 거의 항상 디자이너가 '옳은 일'을 했다는 인상을 남깁니다. 현학적인 일을 하는 Java, 어설픈 일을 하는 Perl, 잘못된 일을 두 가지 독립적으로 구현하는 Ruby, 아무 것도 하지 않는 C와는 대조적이라고 생각합니다.</p>

<p>쓰레기 수거를 예로 들어보겠습니다. 다른 언어로 가비지 컬렉션을 처리할 때가 되면 가비지 컬렉션이 실행되는 동안 전체 시스템이 중지되어야 합니다. 컴퓨터 프로그램이 한 번 실행되고 출력을 작성한 다음 종료되어야 하는 경우 이 접근 방식은 완벽하게 괜찮습니다. 그러나 데스크톱, 모바일 또는 서버 프로그램과 같이 오래 실행되는 애플리케이션의 경우 이 전략은 때때로 UI가 멈추고 응답 시간이 느려지는 결과를 초래합니다. 반면에 Erlang 프로그램은 가비지 수집이 개별적으로 이루어지는 수천 개의 독립적인 힙을 가질 수 있으며, 이러한 방식으로 가비지 수집으로 인한 성능 저하가 시간에 따라 분산되므로 오래 실행되는 애플리케이션이 가비지 수집기가 실행되는 동안 이상하게 응답이 멈추지 않습니다.</p>

<p>또는 문자열 연결을 사용하세요. Perl, Ruby 또는 JavaScript에서 문자열 연결의 구현을 열어보면 <code translate="no">if</code> 문, <code translate="no">realloc</code>, <code translate="no">memcpy</code> 을 찾을 수 있습니다. 즉, 두 문자열을 연결할 때 첫 번째 문자열을 키워서 두 번째 문자열을 위한 공간을 만든 다음 두 번째 문자열을 첫 번째 문자열에 복사하는 방식이죠. 이 접근 방식은 수십 년 동안 사용되어 왔으며 "당연한" 방식입니다. Erlang의 접근 방식은 분명하지 않으며, 저는 이것이 옳다고 생각합니다. 일반적인 경우, Erlang은 연속된 메모리 청크를 사용하여 바이트 시퀀스를 나타내지 않습니다. 그 대신 "I/O 목록"이라고 하는 비연속적인 메모리 청크의 중첩된 목록을 사용합니다. 그 결과 두 개의 문자열(I/O 리스트)을 연결하는 데 다른 언어에서는 O(N) 시간이 걸리는 데 비해 Erlang에서는 O(1)의 시간이 소요됩니다. 이것이 바로 루비, 파이썬 등의 템플릿 렌더링이 느리지만 Erlang에서는 매우 빠른 이유입니다.</p>

<p>애플리케이션 로직이 아무리 블로킹 및 동시성이 뛰어나더라도 Erlang에서는 블로킹 네트워크 호출을 하거나 여러 OS 프로세스를 생성하는 것이 불가능합니다. 이러한 설계 결정으로 인해 Erlang 서버는 운영 체제를 다운시키지 않습니다. 이전 직장에서 과부하된 운영체제로 인해 밤잠을 설친 경험이 있는 저는 Erlang의 동시성 설계가 옳다고 믿습니다.</p>

<p>Erlang 코드를 리팩토링하는 것은 고통스럽다고 언급했습니다. 다행히도 제 경험상 객체 지향 코드가 때때로 리팩터링이 필요한 것과 같은 방식으로 Erlang 코드를 리팩터링할 필요는 거의 없었습니다. Erlang에서는 각 함수에 필요한 모든 정보가 전달되며, 필요하지 않은 정보가 전달되면 컴파일러에서 경고를 표시합니다. 어떤 의미에서 리팩터링은 개발에 통합되어 있으며, 테스트 커버리지가 풍부하고 커피를 여러 잔 마셔야 하는 별개의 활동이 아닙니다. Java 또는 Objective-C 코드 리팩터링은 일반적으로 클래스에 너무 많은 인스턴스 메서드가 추가되어 개발자가 어떤 메서드에 어떤 인스턴스 변수가 필요한지, 그리고 어떻게 하면 가장 효율적으로 캐리지를 절반으로 줄일 수 있는지 파악하는 데 시간을 할애해야 하기 때문에 필요합니다. 함수형 프로그래밍에서는 이러한 문제가 발생하지 않으며, 함수를 다른 모듈로 옮기는 데 거의 손을 대지 않고도 거의 노력을 들이지 않아도 됩니다. "리팩토링"은 일반적으로 큰 함수를 작은 함수로 분해하는 것으로 구성됩니다. 정신적인 노력은 많이 들지 않지만, Erlang의 구문적 특성으로 인해 익명 함수를 명명된 함수로 변환하는 작업은 지루할 수 있습니다. 언젠가는 영리한 IDE가 이러한 지루함을 없애줄 것입니다.</p>

<p>Erlang의 모든 데이터 구조는 완전히 투명합니다. 사용 중인 라이브러리에 대해 아무것도 모르더라도 런타임에 데이터 구조의 내용을 언제든지 검사할 수 있습니다. 이 기능은 디버깅에 큰 도움이 되며, 구식 해킹에 큰 도움이 됩니다. 원래 라이브러리 작성자가 의도하지 않은 기능을 구현하기 위해 문서화되지 않은 데이터 구조를 쉽게 조작할 수 있습니다. 객체 지향 프로그래밍과 달리 원저작자가 변수 이름을 바꾸거나 서브클래스 코드를 망칠까 봐 걱정할 필요가 없으며, 기본 데이터 구조가 동일하게 유지되는 한 수정한 내용이 Erlang에서 계속 작동합니다.</p>

<p>저는 Erlang의 데이터 구조가 투명하기 때문에 프로그래밍이 훨씬 쉬워진다는 것을 알았습니다. 객체 지향 프로그래밍에서는 항상 이름을 어떻게 지어야 할지 고민하지만, Erlang에서는 데이터 구조가 인터페이스의 절반이기 때문에 일반적으로 문제가 되지 않습니다. Erlang으로 프로그래밍을 해본 적이 없다면 제가 무슨 말을 하는지 전혀 모를 것입니다.</p>

<p>이제 Erlang의 나쁜 소식에 대해 말씀드리자면, 이 언어의 장점은 백로드된다는 것입니다. 즉, 다른 언어로 몇 년을 사용한 후 Erlang으로 몇 년을 사용해야만 언어의 대부분의 이점을 누릴 수 있습니다. 확실히 초보자를 위한 언어는 아닙니다. C 디아스포라 출신 프로그래머에게는 낯선 구문입니다. 함수형 프로그래밍은 어렵고, Erlang은 설탕을 넣지 않습니다. 그래픽 툴킷은 원시적이며, Java 입문 강좌에서 볼 수 있는 코드 채우기 컴퓨터 게임도 없습니다. 사소하지 않은 Erlang 코드를 읽으려면 많은 사람들이 어렵게 생각하는 일종의 추상적 사고인 재귀에 대한 확실한 이해가 필요합니다.</p>

<p>또한 다른 언어에 비해 라이브러리도 부족합니다. 제 경험상 특정 작업에 사용할 수 있는 Erlang 라이브러리는 0개, 1개, 많아야 2개 정도입니다. 저 혼자만의 생각일 수도 있겠지만, 사실 저는 사용할 수 있는 Erlang 라이브러리가 많지 않다는 점이 마음에 듭니다. 해야 할 일이 있으면 직접 할 수 있는 핑계가 생기고, 그렇지 않았다면 발견하지 못했을 것을 발견하는 경우가 많기 때문이죠. 멍청하게 들리지만 사실입니다. 아직 아무도 해보지 않은 일을 하고 있기 때문에 생산성을 느낄 수 있고, 그 과정에서 새로운 접근 방식을 시도하고 진정한 혁신을 이룰 수 있는 자유를 누릴 수 있습니다. 저는 다른 사람의 Ruby나 C 코드를 짜깁기하면서 배운 것보다 Erlang 라이브러리를 개발하는 과정에서 더 많은 것을 배웠습니다. 저는 순전히 문제를 해결하고 잘 설계된 애플리케이션에서 발견한 것을 공유하는 즐거움을 위해 Erlang으로 프로그래밍합니다.</p>

<p>저와 같은 노련한 취미 프로그래머에게 Erlang의 유일한 단점은 속도가 느리다는 점입니다. 제가 작성한 서버 애플리케이션의 경우 언어의 속도는 문제가 되지 않았고, 동시 환경에서 가비지 컬렉션, 네트워크 I/O, 문자열 연결을 올바르게 처리하는 Erlang의 기능 덕분에 CPU 추가 비용을 충분히 만회할 수 있었습니다. 복잡성 분석의 관점에서 보면, Erlang 프로그램은 앞에 큰 상수가 있지만 점근 특성이 뛰어난 경향이 있습니다.</p>

<p>시작하고, 실행하고, 출력을 작성하고, 종료하는 프로그램과 같이 빠른 프로그램을 작성하고자 하는 프로그래머에게는 여러 가지 측면에서 희망이 있습니다. 네이티브 코드 컴파일러를 사용할 수 있으며, 수치화된 <a href="http://shootout.alioth.debian.org/">벤치마크에</a> 따르면 자바나 자바스크립트보다는 느리지만 루비, 펄, PHP보다 빠른 Erlang 프로그램을 만들 수 있습니다. 코드 실행 자체에서 정보를 수집하고 적절한 최적화를 수행하여 실행 시간을 더욱 개선할 수 있는 적시 네이티브 코드 컴파일러에 대한 <a href="http://www.erlang-factory.com/conference/SFBay2012/speakers/LukasLarsson">이야기가</a> 나오고 있습니다. 마지막으로, 용감한 사람은 <a href="http://www.erlang.org/doc/man/erl_nif.html">NIF를</a> 통해 C로 계산 집약적인 코드를 작성할 수 있지만, C 코드가 Erlang 스케줄러를 차단하고(잠재적으로 Erlang의 동시성 기능을 무효화할 수 있음) 병렬 C 코드는 작성하기 어렵기로 유명하다는 중요한 주의 사항이 있습니다.</p>

<p>제가 Erlang으로 빠른 프로그램을 작성하기 위해 선택한 대안은 Erlang 런타임의 무결성을 손상시키지 않으면서도 C 코드의 모든 이점을 제공하는 기술입니다. 바로 2008년에 Apple에서 도입한 C와 유사한 언어인 <a href="https://en.wikipedia.org/wiki/OpenCL">OpenCL입니다</a>. OpenCL은 특정 컴퓨터의 모든 프로세서 코어를 쉽게 활용할 수 있으며, Erlang과 달리 OpenCL 프로그램은 매우 빠릅니다. 실제로 OpenCL 프로그램은 일반적으로 수작업으로 조정된 어셈블러 코드가 필요한 방식으로 프로세서의 벡터 기능을 활용할 수 있기 때문에 일반적으로 C 프로그램보다 빠릅니다. OpenCL 프로그램은 <a href="https://github.com/tonyrog/cl">Erlang 코드에서 직접</a> 컴파일하고 실행할 수 있으며, 제 생각에는 더 큰 규모의 Erlang 프로그램 내에서 계산 집약적인 작업(내부 루프 실행)을 수행하는 데 완벽한 기술이라고 생각합니다.</p>

<p>면책 조항을 덧붙이자면, 저는 실제로 Erlang 프로그램 내에서 OpenCL을 사용해 본 적이 없습니다. 앞서 말했듯이 제가 작성한 Erlang 프로그램에서 속도는 문제가 되지 않았습니다. 하지만 OpenCL을 직접 사용해 본 경험은 있고 상당히 만족스러웠습니다. 저는 지도 투영 라이브러리를 OpenCL로 작성했는데, 이 라이브러리는 최첨단 Proj.4 라이브러리(C로 작성)보다 약 5배 더 빨랐습니다. 또한 다변량 통계를 처리하기 위한 OpenCL 라이브러리도 작성했는데, 기존 라이브러리와 벤치마킹하지는 않았지만 비슷한 수준으로 빠르다고 생각합니다. OpenCL 코드를 작성하는 데는 몇 가지 특이한 점이 있지만, 언젠가는 세상의 모든 타이트한 루프가 OpenCL로 다시 작성되고 Erlang으로 작성된 대규모 프로그램에서 호출되는 날이 오기를 희망합니다.</p>

<h3>변경 사항</h3>
<ul>
    <li>2012년 10월 30일 - 사소한 설명 및 수정 사항 추가</li>
</ul>


<hr>

<p><em>여러분은 수학, 기술, 사색의 무작위 모음인 <a href="https://www.evanmiller.org/">evanmiller.org를</a> 읽고 계십니다. 이 글이 마음에 드셨다면 이 글도 읽어보세요:   </em></p><ul><em>
        <li><a href="https://www.evanmiller.org/why-i-develop-for-the-mac.html">제가 Mac용으로 개발하는 이유</a>     </li><li><a href="https://www.evanmiller.org/why-im-betting-on-julia.html">내가 줄리아에 베팅하는 이유</a>     </li><li><a href="https://www.evanmiller.org/four-days-of-go.html">4일간의</a>바둑      </li><li><a href="https://www.evanmiller.org/a-taste-of-rust.html">녹의 맛</a>  </li></em></ul>

<hr>
<p><em>새 기사가 게시되면 <a href="https://www.linkedin.com/in/evanmmiller/">LinkedIn</a>, <a href="https://twitter.com/EvMill">Twitter</a> 또는 <a href="https://www.evanmiller.org/news.xml">RSS를</a> 통해 받아보세요.</em></p>

<hr>

<p><em>MySQL, PostgreSQL 또는 SQLite 데이터베이스에서 통계적 패턴을 찾고 싶으신가요? 데스크톱 통계 소프트웨어 <strong><a href="https://www.wizardmac.com/">마법사를</a></strong> 사용하면 무의미한 명령 구문으로 며칠을 고생하지 않고도 <strong>짧은 시간에 더 많은 데이터를</strong> 분석하고 <strong>발견한 내용을 시각적으로 전달할</strong> 수 있습니다. 확인해 보세요!</em></p>
<p><a href="https://www.wizardmac.com/"><img height="128" width="128" src="https://www.evanmiller.org/images/index/wizard2.png"></a><br>
<strong><a href="https://www.wizardmac.com/">마법사</a></strong><br><span>Mac 방식의 통계</span></p>


<hr>

<p><a href="https://www.evanmiller.org/">Evan Miller의 홈페이지로 돌아가기</a> - <a href="https://www.evanmiller.org/news.xml">RSS 구독</a>- <a href="https://www.linkedin.com/in/evanmmiller/">LinkedIn</a>- <a href="https://twitter.com/EvMill">Twitter</a> </p>

<hr>

</div></div>
      </article>
    </body>
  </html>
  