
  <html lang="ko">
    <head>
      <meta charset="utf-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>The Story of Elixir</title>
      <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
      <script src="//unpkg.com/alpinejs" defer></script>
    </head>
    <body x-data="{ dark: false }" x-bind:data-theme="dark ? 'dark' : 'light'">
      <main class="container">
      	<button x-on:click="dark = !dark" class="contrast outline">Switch Theme</button>
	      <article>
	        <div id="readability-page-1" class="page"><div><article><div dir="auto"><p><span>오늘날 Elixir는 수백만 명의 동시 사용자를 보유한 Discord와 같은 회사를</span> 지원합니다.<span><a data-component-name="FootnoteAnchorToDOM" id="footnote-anchor-1-140535765" href="https://osshistory.org/p/elixir#footnote-1-140535765" target="_self" rel="">1</a></span><span> </span></p><p>이 글에서는 Elixir와 그 창시자인 호세 발림의 탄생 비화를 살펴봅니다.</p><p>호세 발림은 어떻게 Elixir를 만들게 되었나요? 초창기는 어땠나요? 어떻게 성장했나요?</p><p>호세<span>발림은 브라질 출신의 소프트웨어 엔지니어로, 어릴 적부터 멀티코어 시스템에 관심을 갖게 되었습니다.</span><span><a data-component-name="FootnoteAnchorToDOM" id="footnote-anchor-2-140535765" href="https://osshistory.org/p/elixir#footnote-2-140535765" target="_self" rel="">2</a></span></p><blockquote><p>8~10살 때 처음 산 컴퓨터로 돌아가면, 당시에는 강력한 컴퓨터였지만 2년 뒤에는 그것도 아니었죠... 저는 펜티엄 100을 가지고 있었는데 학교에서 한 남자아이가 펜티엄 233을 가지고 있다고 말했어요. 그래서 저는 "왜? 이제 막 컴퓨터를 산 지 얼마 안 됐고 돈도 거의 다 냈는데요. 어떻게 내 컴퓨터보다 두 배 이상 빠른 컴퓨터를 가지고 있죠?"라고 물었습니다.</p></blockquote><p>호세는 컴퓨팅의 다음 단계는 단순히 더 강력한 단일 코어 컴퓨터가 아니라 다중 코어 컴퓨터가 될 것이라는 것을 일찍이 깨달았습니다.</p><p><strong>호세와 루비</strong></p><p>호세가 처음 능숙하게 익힌 프로그래밍 언어는 루비였습니다.</p><p>2009년 대학을 졸업한 지 1년 후, 호세는 루비 중심의 소프트웨어 개발 에이전시인 Platformatec을 설립했습니다. 플랫폼텍 설립 1년 후, 그는 Rails 핵심 팀의 일원이 되어 4년 동안 계속 기여했습니다.</p><div><p><span>Rails 프로젝트에서 호세는 레이스 조건과 관련된 재현하기 어려운 버그에 자주 부딪혔습니다. 멀티코어 시스템에서는 두 개의 코어가 메모리의 같은 위치를 수정하거나 같은 리소스를 동시에 처리하려고 시도할 수 있습니다. 루비와 같은 언어는 메모리 액세스의 부적절한 동기화로 인해 발생하는 이러한 경쟁 조건에 대해 보호하지 못했습니다.</span></p><p><span>호세는 이 문제를 어떻게 해결할 수 있을지 고민하기 시작했습니다.</span></p></div><p>이러한 호기심 때문에 Elixir를 만들게 되었습니다.</p><p>호세는 해결책을 찾는 과정에서 두 가지 중요한 점을 발견했습니다.</p><p>첫 번째는 함수형 프로그래밍, 특히 불변성을 발견한 것이었습니다. 불변성이라는 개념은 프로세스 간에 데이터가 공유되지 않는다는 것을 의미했습니다. 이로써 다른 절차적 프로그래밍 언어와 객체 지향 프로그래밍 언어가 안고 있던 문제 범주를 없앨 수 있었습니다. 두 번째는 에를랑 가상 머신의 발견입니다.</p><p>Erlang은 1986년 에릭슨 내부에서 독점 소프트웨어로 처음 개발되었습니다. 이후 1988년에 무료 오픈소스로 공개되었습니다. 이 소프트웨어는 내결함성과 배포가 필요한 전화 통신 시스템을 확장하기 위해 설계되었습니다. Erlang은 단일 시스템 내 동시성 및 시스템 간 통신을 모두 지원했습니다. 후자는 다른 언어에서는 쉽게 지원하지 않는 기능이었습니다.</p><p>함수형 프로그래밍에 대한 호세의 탐구는 Erlang에만 국한되지 않았습니다. 그는 함수형 패러다임에 대한 이해를 넓히기 위해 프링크와 클로저 같은 언어를 탐구했습니다. 하지만 궁극적으로 그에게 영감을 준 것은 Erlang VM의 기능이었습니다. </p><p>그 잠재력을 알아본 호세는 자신만의 프로그래밍 언어인 Elixir의 기초로 삼았습니다.</p><p>2011년 4월, 호세는 Elixir v0.3을 준비하여 개인 프로젝트에 사용하고 있었습니다. </p><p>하지만 초기 프로토타입은 그가 Elixir에 대해 가지고 있던 완전한 비전을 충족시키지 못했습니다.</p><p><span>Erlang VM 내에서 Ruby의 기능을 복제하려면 Erlang에 추상화 계층을 추가해야 했고, 이로 인해 Elixir의 상호 운용성이 저하되었습니다. 새로운 Erlang 릴리스의 새로운 기능이나 모듈은 모두 Elixir에서 먼저 래핑해야 했기 때문에 Elixir는 계속해서 Erlang을</span> 따라잡아야 했습니다.<span><a data-component-name="FootnoteAnchorToDOM" id="footnote-anchor-3-140535765" href="https://osshistory.org/p/elixir#footnote-3-140535765" target="_self" rel="">3</a></span></p><p>그 결과 Jose는 휴식을 취하면서 다른 언어를 공부하고 Elixir를 개선하기 위한 인사이트를 수집했습니다. 그는 Elixir에 추가된 기능에 대해 더욱 비판적이 되었습니다. 모든 기능에 대해 그 필요성과 최적의 구현에 대해 의문을 제기했습니다. </p><p>몇 달간의 연구 끝에 Elixir의 기반이 형성되었습니다. 호세는 2012년 2월에 플라타포매텍에 연락하여 Elixir의 후원 가능성을 논의했고, 긍정적인 답변을 받았습니다. 호세는 2012년 5월에 Elixir 웹사이트를 통해 Elixir v0.5를 처음 공개했습니다. </p><p><span>호세는 다른 사람들이 엘릭서에 관심을 갖도록 하기 위해 행사에 참석하고 다른 프로그래머들을 만났습니다. 그는 엘릭서에 대해 공유하고 언어에 대한 피드백을 수집했습니다. 2012년 오레데프 컨퍼런스에서 호세는 엘릭서에 대한 비전을 밝혔습니다. 그는 Elixir가 개발자의 생산성을 향상시키고 언어의 확장성을 촉진하기를 원했습니다. 또한 그는 Erlang과의 높은 수준의 호환성을 유지하기를 원했습니다. </span><span><a data-component-name="FootnoteAnchorToDOM" id="footnote-anchor-4-140535765" href="https://osshistory.org/p/elixir#footnote-4-140535765" target="_self" rel="">4</a></span></p><p>Elixir의 초기 버전에는 오늘날의 언어만큼 많은 기능이 없었습니다. 실제로 Stream 모듈은 v0.5가 출시된 지 1년 후인 2013년 7월에야 v0.10에 도입되었습니다. 엘릭서의 또 다른 이정표는 2014년 4월에 엘릭서 컨퍼런스가 발표된 것입니다.</p><p>요즘에는 주요 릴리스의 빈도가 낮아져 '삶의 질' 개선에 초점을 맞추는 경우가 많습니다. 하지만 생태계는 계속 성장하고 있으며, 최신 시스템에서 Elixir를 사용할 수 있도록 지원하고 있습니다.</p><p>Elixir의 가장 큰 강점 중 하나는 라이브러리와 프레임워크를 기여하는 개발자 커뮤니티입니다. 다음은 Elixir 생태계의 초석이 된 다섯 가지 프로젝트입니다.</p><p><a href="https://github.com/ScenicFramework/scenic" rel="">Phoenix는</a><span> 2014년에 Elixir 개발자 크리스 맥코드가 처음 개발했습니다. 피닉스는 루비 온 레일즈에서 영감을 받은 서버 측 웹 프레임워크입니다. 이 프레임워크는 Rails 프레임워크의 친숙함을 Elixir에 도입했습니다. 그 모듈 중 하나는</span><a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html" rel=""> 라이브뷰입니다</a><span>. 이 모듈은 기존의 클라이언트-서버 아키텍처를 완전히 뒤집습니다. 클라이언트-서버 HTTP 요청 대신 영구 웹 소켓/롱 폴링을 사용합니다. 이를 통해 지연 시간을 줄이고 HTTP 요청의 네트워크 오버헤드를 제거합니다.</span></p><p><a href="https://github.com/ScenicFramework/scenic" rel="">Scenic은</a><span> 클라이언트 애플리케이션 라이브러리입니다. Scenic은 고정 화면 연결 장치를 위한 GUI를 제공합니다. 이러한 장치는 사물 인터넷(IoT)에서 자주 사용됩니다. Scenic의 개발자인 보이드 멀터러는 Xbox Live의 책임자이기도 합니다. 그는 Xbox One 운영 체제를 개발하는 팀을 설립하고 이끌었습니다.</span></p><p><a href="https://nerves-project.org/" rel="">Nerves는</a><span> Elixir로 임베디드 시스템을 구축하기 위한 오픈 소스 플랫폼입니다. 이 플랫폼은 BEAM 가상 머신을 실행하는 특수 환경을 생성합니다. 이를 통해 임베디드 시스템에 Elixir와 BEAM VM의 모든 이점을 제공합니다.</span></p><p><a href="https://github.com/elixir-nx/nx" rel="">Nx</a><span> (또는 Numerical Elixir)는 다차원 텐서 라이브러리로, CPU/GPU에 대한 다단계 컴파일을 활용합니다. Elixir 에코시스템에 새로 추가된 라이브러리로, Elixir에 AI/ML 기능을 제공하기 위한 시도입니다.</span></p><p><a href="https://membrane.stream/" rel="">Membrane은</a> 다양한<span> 멀티미디어 유형을 지원하는 멀티미디어 처리 프레임워크입니다. Zoom과 같은 실시간 커뮤니케이션 애플리케이션을 개발하는 데 사용할 수 있습니다.</span></p><p><span>엘릭서에 대한 관심은 언어와 에코시스템이 성숙해짐에 따라 수년에 걸쳐 증가해 왔습니다. 스택 오버플로 개발자 설문조사에 따르면 Elixir는 '개발자가 가장 사랑하는 언어' 상위 3위에 꾸준히 이름을 올렸습니다. 또한 Phoenix는 2022년과 2023년에 가장 사랑받는 웹 프레임워크가 되었습니다. </span><span><a data-component-name="FootnoteAnchorToDOM" id="footnote-anchor-5-140535765" href="https://osshistory.org/p/elixir#footnote-5-140535765" target="_self" rel="">5</a></span></p><p>기업들 사이에서도 Elixir의 인기가 높아졌습니다. Discord와 같은 회사는 Elixir를 사용하여 5백만 명의 동시 사용자를 지원하고 있습니다. 또한 임베디드 시스템 및 웹 개발과 같은 분야에서도 Elixir의 사용 사례가 증가하고 있습니다.</p><p>임베디드 시스템 프로그래밍은 C나 C++와 같은 저수준 언어가 주를 이룹니다. 이는 사물 인터넷(IoT) 기기의 처리 능력이 제한되어 있기 때문에 성능이 뛰어나야 하기 때문입니다. 하지만 Elixir는 임베디드 시스템 분야에서 틈새 시장을 찾아냈습니다. Elixir는 고성능 시스템 작성 외의 문제 해결에 중점을 둡니다.</p><p>IoT 장치는 네트워크 연결 및 물리적 접근성과 같은 외부 요인이 있는 영역에서 사용될 수 있습니다. 이러한 요소는 이러한 디바이스의 유지보수성에 영향을 미칩니다. 이러한 경우 임베디드 시스템을 구축할 때 성능만 고려하는 것은 아닙니다. 이러한 시나리오에서 Elixir는 디바이스와 중앙 서버 간의 연결을 유지하는 데 도움을 줄 수 있습니다. 이를 통해 이러한 시스템에 필요한 수동 개입의 양을 줄일 수 있습니다.</p><p><span>Farmbot의 전 임베디드 시스템 엔지니어인 Connor Rigby는 Elixir를 사용하여 저대역폭 영역에서 잘 작동하는 간결한 시스템을 구축할 수 있었던 방법에 대해 언급했습니다. </span><span><a data-component-name="FootnoteAnchorToDOM" id="footnote-anchor-6-140535765" href="https://osshistory.org/p/elixir#footnote-6-140535765" target="_self" rel="">6</a></span></p><p>Elixir는 Phoenix의 출시와 함께 웹 개발 분야에서도 성장했습니다. 헤로쿠와 모질라 같은 회사들이 Elixir를 채택했습니다. 이들은 웹 애플리케이션과 핵심 서비스를 개발하고 마이그레이션하는 데 사용합니다.</p><p><span>Elixir를 사용하면서 Heroku의 분석 서비스는 초당 3,000~4,000건의 요청을 처리할 수 있게 되었습니다. 평균 응답 시간도 약 1ms로 단축되었습니다.</span><span><a data-component-name="FootnoteAnchorToDOM" id="footnote-anchor-7-140535765" href="https://osshistory.org/p/elixir#footnote-7-140535765" target="_self" rel="">7</a></span><span> Mozilla는 Phoenix를 사용하여 REST 엔드포인트를 구축하고, 채팅 메시징을 구현하고, 실시간 아바타 추적 기능을 생성합니다</span>.</p><p>Elixir는 업계에서 채택률이 낮습니다. 대부분의 팀에서 웹 개발을 위해 자바스크립트와 같은 언어를 여전히 사용하고 있습니다. 이는 이러한 언어에 사용할 수 있는 도구의 다양성 때문인 것으로 보입니다.</p><p>함수형 프로그래밍 패러다임은 또한 Elixir를 배우는 사람들에게 학습 곡선을 도입합니다. Elixir의 모듈 시스템과 불변성은 Java와 같은 명령형 언어에서 벗어난 것입니다. 이는 개발자가 새로운 문제 해결 방식에 적응하는 데 시간이 걸린다는 것을 의미합니다.</p><p>또한 Elixir는 다른 언어에 비해 교육 리소스가 부족합니다. 따라서 자바스크립트처럼 더 많은 리소스가 있는 언어에 익숙한 사람들이 언어를 배우기가 더 까다로울 수 있습니다.</p><div><p><span>엘릭서는 언어의 성장이 커뮤니티에 달려 있다는 증거입니다. </span></p><p><span>크리스 맥코드, 프랭크 헌레스, 보이드 멀터러와 같은 사람들이 커뮤니티를 위해 라이브러리는 물론 자신의 시간과 전문 지식을 기부했습니다. 이러한 기여가 Elixir의 생태계를 형성했습니다.</span></p></div><p>Elixir의 개발은 또한 소프트웨어 개발에서 높은 수준의 목표를 유지하는 것이 얼마나 중요한지를 강조합니다. 프로젝트의 모든 기능은 항상 "왜 필요한가?"와 "이를 수행하는 가장 좋은 방법은 무엇인가?"라는 두 가지 질문으로 접근해야 합니다. 이는 프로젝트를 간결하고 집중력 있게 유지하는 데 도움이 됩니다.</p></div></article></div></div>
	      </article>
			</main>
    </body>
  </html>
  