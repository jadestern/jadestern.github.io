
  <html lang="ko">
    <head>
      <meta charset="utf-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>Zed에서 로컬 샌드박스가 적용된 백그라운드 에이전트를 위한 컨테이너 사용 - Zed 블로그</title>
      <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
      <script src="//unpkg.com/alpinejs" defer></script>
      <style>
        video {
          width: 100%;
        }
        
        /* Ensure body background is applied */
        body {
          background-color: var(--background-color);
          color: var(--color);
        }
      </style>
    </head>
    <body x-data="{ dark: false }" x-bind:data-theme="dark ? 'dark' : 'light'">
      <main class="container">
      	<button x-on:click="dark = !dark" class="contrast outline">Switch Theme</button>
	        <h1>Zed에서 로컬 샌드박스가 적용된 백그라운드 에이전트를 위한 컨테이너 사용 - Zed 블로그</h1>
	        <div id="readability-page-1" class="page"><article><p>대부분의 사람들이 AI 코딩 에이전트로 신과 같은 10배의 개발자 능력을 갖추지는 못했지만, 많은 사람들이 실험하고 절충점을 찾아가고 있습니다. 어떤 경우에는 에이전트가 로컬 파일에서 직접 작업하기를 원하며, 일반적으로 동기식 AI "부조종사"로서 포그라운드에서 작업합니다. Zed 에이전트 패널과 기본 제공 도구는 이를 위해 필요한 모든 것을 제공합니다.</p>
<p>다른 경우에는 에이전트가 백그라운드에서 비동기식으로 문제를 해결하기를 원할 수도 있습니다. 특히 모든 에이전트가 동일한 코드 기반(예: 모노레포)에서 작업하는 경우 백그라운드 에이전트가 포그라운드 작업을 방해하는 것은 절대 원치 않을 것입니다. 코드 기반의 다른 부분에 대해 에이전트가 병렬로 작업하는 것 외에도 단일 프롬프트에서 세 가지 가능한 솔루션을 생성하는 Claude 4 같은 병렬 지원 모델이 필요할 수 있습니다. 이상적으로는 모든 것을 원할 것입니다.</p>
<p>하지만 이러한 에이전트를 병렬로 작업하려면 일반적으로 리포지토리의 복제본으로 여러 디렉터리를 관리하거나 <code translate="no">git stash</code> 와 씨름해야 합니다. <code translate="no">git worktree</code> 의 놀라운 기능을 발견했을 수도 있지만, 그러면 격리된 샌드박스 없이 여전히 로컬 컴퓨터에서 신뢰할 수 없는 AI 생성 코드를 실행하고 있는 셈이죠.
컨테이너는 격리에 적합한 기술처럼 보이지만, 모든 사용 사례를 포괄하는(그리고 훌륭한 DX를 제공하는) 완벽한 솔루션을 위해 컨테이너를 Git Worktrees와 어떻게 통합해야 할까요? 아마도 가입한 것보다 더 많은 것을 원할 것입니다.</p>
<p>하지만 이상적으로는 Zed 포그라운드 에이전트 환경과 격리된 백그라운드 병렬 에이전트를 모두 원하실 것입니다. Zed + <a href="https://container-use.com/">Container Use를</a> 사용하면 이 모든 것을 가질 수 있습니다.</p>
<h2 id="what-is-container-use"><a href="#what-is-container-use" aria-label="Copy heading link"><span><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" x2="20" y1="9" y2="9"></line><line x1="4" x2="20" y1="15" y2="15"></line><line x1="10" x2="8" y1="3" y2="21"></line><line x1="16" x2="14" y1="3" y2="21"></line></svg></span><span>컨테이너 사용이란 무엇인가요?</span></a></h2>
<div><figure><img src="https://zed.dev/img/post/container-use/what-is-container-use.webp" alt="An overview of Container Use"><figcaption>컨테이너 사용 개요</figcaption></figure></div>
<p>Container Use는 코딩 에이전트가 오케스트레이션을 통해 자체 컨테이너화된 샌드박스 환경을 제공하는 간단한 DX를 갖춘 오픈 소스 프로젝트입니다:</p>
<ul>
<li>시스템과의 격리를 위한 컨테이너, 터미널 액세스, 서비스 터널링( <a href="https://dagger.io/">Dagger에서</a> 제공)</li>
<li>쉽게 병합할 수 있는 병렬<a href="https://git-scm.com/docs/git-worktree">Git</a> 히스토리를 위한<a href="https://git-scm.com/docs/git-worktree">Git Worktrees</a> </li>
</ul>
<h2 id="how-does-container-use-work"><a href="#how-does-container-use-work" aria-label="Copy heading link"><span><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" x2="20" y1="9" y2="9"></line><line x1="4" x2="20" y1="15" y2="15"></line><line x1="10" x2="8" y1="3" y2="21"></line><line x1="16" x2="14" y1="3" y2="21"></line></svg></span><span>컨테이너 사용은 어떻게 작동하나요?</span></a></h2>
<p><code translate="no">ubuntu</code> MCP를 통해 <a href="https://container-use.com/agent-integrations#zed">컨테이너 사용을 구성한 Zed를</a> 사용하면, 에이전트 작업을 시작하면 격리용 Dagger 컨테이너( <code translate="no">git</code> 및 <code translate="no">curl</code> 같은 도구가 기본적으로 <a href="https://container-use.com/environment-configuration#default-environment-configuration">제공되지만 사용자 지정할 수 있음</a>)와 컨테이너 사용으로 관리되는 Git 워크트리로 임의의 이름의 새 환경이 생성됩니다. 원하는 만큼 많은 환경을 가질 수 있고 <code translate="no">container-use list</code> 에서 모두 확인할 수 있습니다.</p>
<p><code translate="no">container-use</code> CLI를 사용하여<code translate="no">container-use watch</code>, <code translate="no">container-use log &lt;env name&gt;</code>, <code translate="no">container-use diff &lt;env name&gt;</code> 와 같은 명령을 통해 에이전트의 진행 상황을 확인할 수도 있습니다.</p>
<p>Dagger 컨테이너는 임시 서비스 및 터미널 디버깅을 기본적으로 지원하므로 프롬프트를 통해 환경에서 실행 중인 서비스에 연결할 URL을 요청하면 <code translate="no">localhost</code> 에서 샌드박스 컨테이너로 연결되는 터널을 얻을 수 있으며, <code translate="no">container-use terminal &lt;env name&gt;</code> 을 실행하여 대화형 터미널 세션으로 이동하여 명령을 실행할 수도 있습니다.</p>
<h2 id="how-to-set-up-container-use-with-zed-in-an-optimal-way"><a href="#how-to-set-up-container-use-with-zed-in-an-optimal-way" aria-label="Copy heading link"><span><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" x2="20" y1="9" y2="9"></line><line x1="4" x2="20" y1="15" y2="15"></line><line x1="10" x2="8" y1="3" y2="21"></line><line x1="16" x2="14" y1="3" y2="21"></line></svg></span><span>Zed에서 컨테이너 사용을 최적의 방식으로 설정하는 방법</span></a></h2>
<p><a href="https://container-use.com/">컨테이너 사용 문서는</a> 새로운 <a href="https://zed.dev/extensions/mcp-server-container-use">컨테이너 사용용 Zed 확장</a> 프로그램을 사용하거나 <a href="https://container-use.com/agent-integrations#zed">수동으로 구성하여</a> 시작하고 실행하는 데 도움이 됩니다. 그 외에도 포그라운드 및 백그라운드 에이전트를 최대한 활용하기 위해 설정해야 할 가장 중요한 것은 Zed의 에이전트 패널 <a href="https://zed.dev/docs/ai/agent-panel#custom-profiles">사용자 지정 프로필입니다</a>.</p>
<p>이러한 사용자 구성 프로필은 상담원 패널의 기본 제공 쓰기, 질문 및 최소 프로필을 뛰어넘는 것입니다. <code translate="no">foreground</code> 및 <code translate="no">container-use</code> (또는 원하는 경우 <code translate="no">background</code>)의 두 가지 프로필을 추천합니다.</p>
<p>→ <code translate="no">foreground</code> 프로필에는 기본 제공 Zed 도구가 모두 활성화되어 있습니다.</p>
<div><figure><img src="https://zed.dev/img/post/container-use/foreground-profile.webp" alt="Foreground profile"><figcaption>포그라운드 프로필</figcaption></figure></div>
<p>→ <code translate="no">container-use</code> 프로필에는 기본 제공 도구가 하나도 활성화되어 있지 않고 컨테이너 사용 도구만 활성화되어 있습니다.</p>
<div><figure><img src="https://zed.dev/img/post/container-use/container-use-profile.webp" alt="Container Use profile"><figcaption>컨테이너 사용 프로필</figcaption></figure></div>
<p>이 시스템의 장점은 이제 포그라운드와 백그라운드 에이전트가 충돌하지 않는다는 것입니다. <code translate="no">container-use</code> 프로필로 전환하여 백그라운드 병렬 에이전트 실험을 시작한 다음(세 가지 새로운 UI 디자인을 요청할 수도 있음) <code translate="no">foreground</code> 프로필로 전환하여 에이전트 지원을 통해 까다로운 서버 로직을 대화형으로 편집할 수 있습니다.</p>
<p>Zed에서 눈을 떼고 웹 브라우저에서 조사를 하고 있더라도 백그라운드 에이전트의 작업이 완료되면 Zed로부터 멋진 알림을 받을 수 있습니다.</p>
<p>또한 사용자 지정 프로필과 함께 <a href="https://zed.dev/docs/ai/rules#rules-library">Zed 규칙 라이브러리를</a> 사용하는 것이 좋습니다. 이렇게 하면 컨테이너 사용 규칙을 사용자 지정하여 백그라운드 작업에 포함시킬 수 있습니다.</p>
<div><figure><img src="https://zed.dev/img/post/container-use/container-use-rules.webp" alt="Zed Rules Library"><figcaption>Zed 규칙 라이브러리</figcaption></figure></div>
<h2 id="what-next"><a href="#what-next" aria-label="Copy heading link"><span><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" x2="20" y1="9" y2="9"></line><line x1="4" x2="20" y1="15" y2="15"></line><line x1="10" x2="8" y1="3" y2="21"></line><line x1="16" x2="14" y1="3" y2="21"></line></svg></span><span>다음 단계는 무엇인가요?</span></a></h2>
<p>에이전트를 백그라운드에 두고 포그라운드에서 완전한 수동 작업을 하든, 완전한 에이전트 작업을 하든, 아니면 그 중간 정도의 작업을 하든, Container Use는 Zed 에이전트 워크플로에 적합합니다. 시작하려면 Container Use 문서에서 <a href="https://container-use.com/quickstart">빠른 시작</a> 및 <a href="https://container-use.com/agent-integrations#zed">Zed 설정을</a> 사용해 보세요. 또는 <a href="https://www.youtube.com/watch?v=wUDhxVwp-Jw">동영상 데모를</a> 확인해 보세요.</p>
<p>그리고 성공 사례와 제안 사항을 <a href="https://discord.gg/dagger-io">Dagger Discord 서버의</a> <code translate="no">#container-use</code> 채널에서 공유해 주세요. 곧 뵙겠습니다!</p><hr></article></div>
	        <hr>
	        <a href="https://zed.dev/blog/container-use-background-agents" target="_blank" role="button" class="outline">Container Use for Locally Sandboxed, Background Agents in Zed - Zed Blog</a>
			</main>
    </body>
  </html>
  