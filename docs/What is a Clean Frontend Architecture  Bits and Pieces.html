
  <html lang="ko">
    <head>
      <meta charset="utf-8">
      <title>What is a Clean Frontend Architecture? | Bits and Pieces</title>
      <link rel="canonical" href="https://medium.com/bitsrc/clean-frontend-architecture-2995c68702fb">
      <style>
        pre {
          padding: 1rem;
          background-color: #263238;
          color: #fff
        }
      </style>
    </head>
    <body>
      <article>
        <div id="readability-page-1" class="page"><div><div><h2 id="7fff">프론트엔드 아키텍처 살펴보기: 깔끔한 프론트엔드 아키텍처(SOLID, KISS, DRY, DDD 등)와 관련된 몇 가지 원칙에 대한 개요입니다.</h2><div><a href="https://medium.com/@robert.maiersilldorff?source=post_page-----2995c68702fb--------------------------------" rel="noopener follow"><div aria-hidden="false"><p><img alt="Robert Maier-Silldorff" src="https://miro.medium.com/v2/resize:fill:88:88/1*9Sx7w15fMG6MpTPgltTZJg.jpeg" width="44" height="44" loading="lazy" data-testid="authorPhoto"></p></div></a><a href="https://blog.bitsrc.io/?source=post_page-----2995c68702fb--------------------------------" rel="noopener  ugc nofollow"><div aria-hidden="false"><p><img alt="Bits and Pieces" src="https://miro.medium.com/v2/resize:fill:48:48/1*7jl7ls1SeoNkYU742b9j1Q.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto"></p></div></a></div></div><p id="fa67">이전 게시물 중 하나에서 <em>시그널과</em> 아직 누락된 부분에 대해 이야기했습니다<a href="https://medium.com/bitsrc/a-closer-look-on-signals-and-whats-still-missing-ba816b963a78" rel="noopener">[1</a>]. 이번에는 좀 더 일반적인 주제, 즉 <em>클린 프론트엔드 아키텍처에</em> 대해 이야기하고자 합니다. 이 주제에는 많은 원칙이 있습니다:</p><blockquote><p id="71ea"><em>SOLID, KISS</em> (짧고 단순하게 유지), <em>DRY</em> (반복하지 않기), <em>DDD</em> (도메인 중심 디자인) 등이 있습니다.</p></blockquote><p id="628b">이 글에서는 이러한 개념 중 몇 가지에 대해 이야기하겠습니다. 하지만 먼저 <em>프론트엔드 아키텍처에</em> 대해 이야기하고 싶은 이유는 무엇일까요? 글쎄요, 저에게는 지극히 개인적인 주제입니다. 왜일까요? <em>프론트엔드 아키텍처</em> 가 <em>백엔드 아키텍처</em>만큼 중요하다는 것을 경영진뿐만 아니라 개발팀에게도 설득하기 위해 매일매일 정말 열심히 싸워야 하기 때문입니다.</p><h2 id="d49c">프론트엔드 아키텍처가 필요한 이유는 무엇일까요?</h2><p id="e2a4"><em>기능적</em>, <em>비기능적</em> 요구사항은 백엔드뿐만 아니라 프론트엔드에도 적용되어야 합니다. 따라서 <em>프론트엔드 아키텍처를</em> 통해 <em>비즈니스 요구사항을</em> <em>충족할</em> 수 있습니다. 또한 프로젝트의 복잡성을 더 잘 이해할 수 있어 프로젝트의 위험, 시간, 비용을 줄일 수 있습니다. 하지만 제 생각에 <em>프론트엔드 아키텍처의</em> 가장 중요한 이유는 모든 프로젝트의 <em>유지보수성과</em> <em>확장성입니다</em>.</p><h2 id="cced">그렇다면 프론트엔드 아키텍처는 어떤 모습일까요?</h2><p id="cee5">제 경험상 대부분의 경우 <em>레이어드 아키텍처가</em> 사용됩니다. 하지만 헥사곤 아키텍처를 적용한 프로젝트도 몇 개 접한 적이 있습니다.</p><p id="7e4e">다음 그림은 간단한 <em>TripAgency</em> 프로젝트의 예시입니다.</p><figure><figcaption>레이어드 프론트엔드 아키텍처</figcaption></figure><h2 id="9556">어떤 레이어가 사용되나요?</h2><ul><li id="08e0"><em>API</em>: <em>오픈 API 생성기로</em> 생성된 <em>DTO</em> 및 <em>서비스</em> </li><li id="e2d9"><em>서비스</em>: <em>매퍼</em> (DTO에서 프런트엔드 모델로, 또는 그 반대로) 및 <em>REST</em> 엔드포인트를 통해 API와 통신하는 <em>서비스를</em> 포함합니다.</li><li id="a10a"><em>스토어</em>: <em>서비스</em> 계층에서 검색된 모든 데이터가 포함된 글로벌 스토어입니다.</li><li id="d5b9"><em>예약</em>: <em>모델</em> 및 <em>컴포넌트를</em> 포함하는 <em>도메인</em>. 스마트 컴포넌트는 스토어와 직접 상호 작용하며, 덤 컴포넌트는 둘 이상의 컨텍스트에 적용될 수 있는 컴포넌트일 뿐이므로 훨씬 더 간단합니다.</li></ul><h2 id="2ce2">그렇다면 이런 종류의 아키텍처에서 무엇이 잘못될 수 있을까요?</h2><p id="ebaf">정의된 규칙이 없다면 개발자가 컴포넌트에서 직접 <em>DTO를</em> 사용하거나 스토어 없이 <em>서비스 계층과</em> 통신할 수 있습니다. 또는 더 나쁜 경우, 멍청한 컴포넌트가 서비스 계층과 통신할 수도 있습니다.</p><h2 id="7a87">이러한 실수를 방지하려면 어떻게 해야 할까요?</h2><p id="d517">이런 일이 발생하지 않도록 몇 가지 규칙을 정의하기만 하면 됩니다. 가장 일반적인 접근 방식 중 하나는 프로젝트에 Bit 또는 Nx를 도입하는 것입니다. 비트가 무엇인가요? Nx는 무엇인가요?</p><blockquote><p id="5959">Bit와 Nx는 개발자 생산성 향상, CI 성능 최적화, 코드 품질 유지를 위한 도구와 기술을 제공하는 강력한 오픈 소스 빌드 시스템입니다<a href="https://bit.dev/docs/quick-start/hello-world" rel="noopener ugc nofollow" target="_blank">[2</a>]<a href="https://nx.dev/getting-started/intro" rel="noopener ugc nofollow" target="_blank">[3</a>].</p></blockquote><p id="1f4e">따라서 Bit 또는 Nx를 사용하면 종속성 규칙을 적용할 수 있습니다. 따라서 개발자는 잘못된 레이어를 사용하면 오류가 발생합니다.</p><p id="b361">이는 유효한 접근 방식이지만 위의 예제에서 <em>예약 도메인의</em> 경우 <em>도메인</em> 자체가 유지 관리 가능한 상태를 유지한다는 것을 어떻게 확신할 수 있을까요?</p><p id="b064"><em>예약 도메인에</em> 일부 <a rel="noopener ugc nofollow" target="_blank" href="https://medium.com/domain-driven-design-with-react-building-scalable-and-maintainable-applications-8aa854f18a69"><em>DDD(도메인 중심 디자인)</em></a><em> </em>개념(<em> </em>)을 적용할 수 있습니다. 따라서 <em>예약 도메인을</em> 몇 개의 <em>하위 도메</em>인으로 분할합니다. 각 <em>하위 도메인에는</em> 고유한 <em>바운드 컨텍스트와</em> <em>유비쿼터스 언어가</em> 있습니다. 이는 아래 그림과 같이 보일 수 있습니다.</p><figure><figcaption>DDD 개념 적용</figcaption></figure><p id="af56">각 <em>하위 도메인은</em> <em>계층화된 아키텍처를</em> 사용하며 이러한 <em>하위 도메인</em> 간의 상호 작용을 위해 API가 사용됩니다. <em>기능에는</em> 스마트 컴포넌트 및 서비스, <em>UI는</em> 덤 컴포넌트, <em>도메인은</em> 모델, <em>유틸리티는</em> 모든 유틸리티 기능이 포함되며, 이 <em>바운드 컨텍스트</em> 내에서 사용됩니다.</p><p id="a19e">이제 어떻게든 깔끔한 <em>아키텍처를</em> 갖추었죠? 거의 다 왔지만 아직은 아닙니다. 아키텍처를 갖추는 것만으로는 충분하지 않으며, 기본 구성 요소와 비즈니스 로직도 <em>클린 코드</em> 원칙을 사용해야 합니다. 이제 <em>기능</em> 및 <em>UI</em> 레이어를 자세히 살펴봅시다.</p><p id="2095"><strong>이것도 보세요:</strong></p><figure></figure><h2 id="60e2">컴포넌트에 어떤 원칙을 적용해야 할까요?</h2><p id="f83d">가장 먼저 <em>SOLID</em> 원칙이 있습니다. 각 컴포넌트는 하나의 책임만 가져야 합니다<em>(단일 책임 원칙</em>). 상속보다 구성을 사용하세요<em>(개방형-폐쇄형 원칙</em>). 컴포넌트가 적합하지 않은 인터페이스, 즉 모든 메서드가 합리적이지 않은 인터페이스를 구현하도록 강요하지 마세요<em>(인터페이스 분리</em>). 그리고 컴포넌트가 하위 레벨 서비스에 직접적으로 의존해서는 안 된다는 점을 명심하세요(<em>의존성 반전</em>).</p><p id="0b64">둘째, <em>컴포넌트</em>, <em>서비스</em> 또는 <em>유틸리티에</em> 비즈니스 로직을 적용할 때 <em>KISS</em> 원칙을 잊지 말아야 합니다. 코드를 가능한 짧고 단순하게 유지하세요. 왜 그렇게 해야 할까요? 코드가 간단할수록 유지 관리가 더 쉬워지기 때문입니다.</p><p id="f980">셋째, 같은 내용을 반복하지 마세요<em>(DRY</em> 원칙). 공통 로직은 <em>유틸리티나</em> <em>서비스로</em> 옮기세요.</p><blockquote><p id="d370">참고: 이러한 원칙은 <a href="https://bit.cloud/" rel="noopener ugc nofollow" target="_blank"><strong>Bit를</strong></a> 사용하면 쉽게 구현할 수 있습니다. <a href="https://bit.dev/docs/getting-started/installing-bit/start-bit-workspace/" rel="noopener ugc nofollow" target="_blank"><strong>비트 워크스페이스</strong></a> 내에서 재사용 가능한 컴포넌트(함수, UI 요소 또는 데이터 모델)를 독립적으로 빌드, 테스트, 버전 관리 및 문서화할 수 있으며, 이를 비트의 <a href="https://bit.cloud/components" rel="noopener ugc nofollow" target="_blank"><strong>컴포넌트 공유 플랫폼에</strong></a> 게시하여 본인 또는 다른 사람이 여러 프로젝트로 쉽게 가져올 수 있습니다.</p></blockquote><h2 id="89b8">자세히 알아보기:</h2><p id="b43f">그럴듯하게 들립니다. 하지만 무엇을 피해야 하는지 어떻게 알 수 있을까요? 간단히 말해, <em>안티 패턴이란</em> 무엇인가요?</p><h2 id="5e52">안티 패턴</h2><p id="718b">시간이 지남에 따라 몇 가지 일반적인 실수를 발견했습니다. 가장 흔한 실수는 무엇인가요?</p><ul><li id="5bd1">번들 크기를 부풀리는 불필요한 라이브러리 가져오기</li><li id="6a11">중첩된 구독 사용</li><li id="304f">템플릿에 비즈니스 로직 추가</li><li id="3863">테스트되지 않은 비즈니스 로직</li></ul><p id="0b36">이것이 바로 안티패턴입니다. 하지만 코드가 유지 관리 가능한 상태로 유지되려면 어떻게 해야 할까요? 아시다시피 비즈니스 로직은 시간이 지남에 따라 성장합니다. 요컨대, 다음과 같은 말을 자주 듣게 됩니다.</p><blockquote><p id="31aa">코드는 역사적으로 성장해 왔습니다. 처음에는 클린 코드였지만 지금은 이전처럼 쉽게 유지 관리할 수 없는 코드가 되었습니다.</p></blockquote><p id="85b0">예, 이것은 매우 흔한 문제입니다. 하지만 다음과 같은 간단한 규칙을 따르면 유지보수를 유지하는 데 도움이 될 수 있습니다.</p><ul><li id="7128"><em>eslint 규칙</em> 정의하기</li><li id="6bd8"><em>스타일린트</em> 사용</li><li id="78d5">비즈니스<em> 로직</em> 테스트하기</li><li id="816f">재사용 가능한 작은 컴포넌트 빌드하기</li><li id="d1af"><em>ES6</em> 및 <em>타입스크립트 기능</em>사용하기</li></ul><h2 id="b8d3">요약</h2><p id="ed0e">지금까지 <em>클린 아키텍처의</em> 예시를 소개하고 적용할 수 있는 몇 가지 원칙에 대해 간략하게 설명했습니다. 또한 <em>DDD를</em> <em>프론트엔드 아키텍처에</em> 적용하는 방법을 설명했습니다. 그리고 마지막으로 코드의 유지보수가 용이하도록 컴포넌트를 만들고 비즈니스 로직을 추가할 때 몇 가지 규칙을 제시했습니다.</p><p id="cee4">그러나 개발자 팀은 <em>코드 리뷰와</em> 새로운 <em>기능</em> 추가에 있어 높은 기준을 가지고 있어야 하며, 그렇지 않으면 <em>클린 아키텍처만으로는</em> 유지보수를 유지하기에 충분하지 않을 수 있습니다.</p><p id="b51d">이 글이 더 깔끔한 <em>프론트엔드 아키텍처를</em> 구축하는 데 도움이 되길 바랍니다.</p><h2 id="44f9">링크</h2><p id="6116">[1] <a href="https://medium.com/bitsrc/a-closer-look-on-signals-and-whats-still-missing-ba816b963a78" rel="noopener">https://medium.com/bitsrc/a-closer-look-on-signals-and-whats-still-missing-ba816b963a78</a></p><p id="9477">[2] <a href="https://bit.dev/docs/quick-start/hello-world/" rel="noopener ugc nofollow" target="_blank">https://bit.dev/docs/quick-start/hello-world/</a></p><p id="ef3a">[3] <a href="https://nx.dev/getting-started/intro" rel="noopener ugc nofollow" target="_blank">https://nx.dev/getting-started/intro</a></p></div><div><h2 id="f66f">레고처럼 재사용 가능한 컴포넌트로 깔끔한 프론트엔드 구축하기</h2><figure></figure><p id="0302"><a href="https://bit.cloud/" rel="noopener ugc nofollow" target="_blank"><strong>Bit</strong></a><strong> </strong>는 컴포저블 소프트웨어 개발을 위한 오픈소스 툴체인입니다.</p><p id="81f2">Bit를 사용하면 최신 웹 앱, UI 컴포넌트, 백엔드 서비스, CLI 스크립트 등 모든 소프트웨어를 독립적이고 재사용 가능하며 컴포저블한 소프트웨어 단위로 개발할 수 있습니다. 애플리케이션 전반에서 모든 구성 요소를 공유하여 더 쉽게 협업하고 더 빠르게 빌드할 수 있습니다.</p><p id="ad36"><strong>100,000명 이상의 개발자가 함께 컴포저블 소프트웨어를 구축하는 대열에 합류하세요.</strong></p><p id="c4b2">다음 튜토리얼로 시작하세요:</p><h2 id="f7cc">→ 마이크로 프론트엔드 <a href="https://youtu.be/zBuBlExo3xA" rel="noopener ugc nofollow" target="_blank">비디오</a> // <a rel="noopener ugc nofollow" target="_blank" href="https://medium.com/how-we-build-micro-front-ends-d3eeeac0acfc">가이드</a></h2><h2 id="753d">→ 코드 공유: <a href="https://youtu.be/9vS86xgG3ak" rel="noopener ugc nofollow" target="_blank">비디오</a> // <a href="https://bit.cloud/blog/how-to-reuse-react-components-across-your-projects-l4pz83f4" rel="noopener ugc nofollow" target="_blank">가이드</a></h2><h2 id="e0b0">→ 현대화: <a href="https://www.youtube.com/watch?v=c4X1HkFfq1k" rel="noopener ugc nofollow" target="_blank">비디오</a> // <a rel="noopener ugc nofollow" target="_blank" href="https://medium.com/modernizing-frontend-applications-a-guide-b0bac99be932">가이드</a></h2><h2 id="95cd">→ 모노레포: <a href="https://www.youtube.com/watch?v=5wxyDLXRho4&amp;t=2041s" rel="noopener ugc nofollow" target="_blank">비디오</a> // <a href="https://bit.dev/blog/painless-monorepo-dependency-management-with-bit-l4f9fzyw/" rel="noopener ugc nofollow" target="_blank">가이드</a></h2><h2 id="5fc5">→ 마이크로 서비스: <a href="https://youtu.be/5wxyDLXRho4" rel="noopener ugc nofollow" target="_blank">비디오</a> // <a href="https://bit.dev/blog/component-driven-microservices-with-nodejs-and-bit-l64shurc/" rel="noopener ugc nofollow" target="_blank">가이드</a></h2><h2 id="701a">→ 디자인 시스템: <a href="https://youtu.be/YG4kpUXRlG4" rel="noopener ugc nofollow" target="_blank">비디오</a> // <a rel="noopener ugc nofollow" target="_blank" href="https://medium.com/how-we-build-our-design-system-15713a1f1833">가이드</a></h2></div></div>
      </article>
    </body>
  </html>
  