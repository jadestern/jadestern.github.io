
  <html lang="ko">
    <head>
      <meta charset="utf-8">
      <title>The World Before Git</title>
      <link rel="canonical" href="https://osshistory.org/p/the-world-before-git?r=7fC">
      <style>
        pre {
          padding: 1rem;
          background-color: #263238;
          color: #fff
        }
      </style>
    </head>
    <body>
      <article>
        <div id="readability-page-1" class="page"><div><article><div dir="auto"><p><span>수십 년 동안 코드를 작성해 온 사람이 아니라면</span><span> Git 외에 </span><span><a data-component-name="FootnoteAnchorToDOM" id="footnote-anchor-1-139457354" href="https://osshistory.org/p/the-world-before-git#footnote-1-139457354" target="_self" rel="">VCS1을</a></span><span>사용해 본 적이</span> 없을 것입니다.<span> 하지만 Git이 최초의 중요한 VCS는 아닙니다. </span></p><p>이 글에서는 Git이 만들어지기까지 VCS의 역사를 추적합니다.</p><p>1970년대 초, 개발자들은 파일 사본을 수동으로 저장하여 버전을 관리했습니다. 반복 작업이 중요하다고 생각되면 사본을 저장했습니다. 표준 관행이 없었고 모든 개발자가 개인적인 기술을 사용했습니다.</p><p>컴퓨터의 성능이 향상됨에 따라 소프트웨어는 더욱 복잡해졌고, 이를 만드는 과정도 복잡해졌습니다. 개발자들은 더 많은 작업을 반복했고, 이전 버전의 코드를 저장하고 검색할 수 있는 전용 도구가 필요했습니다.</p><p><span>최초의 공식적인 VCS는</span><span> 1972년 벨 연구소의 마크 J. 로치킨드가 출시한 </span><span><a data-component-name="FootnoteAnchorToDOM" id="footnote-anchor-2-139457354" href="https://osshistory.org/p/the-world-before-git#footnote-2-139457354" target="_self" rel="">SCCS2였습니다</a></span>.<span> 오늘날 우리가 당연하게 여기는 많은 개념을 개척했습니다. </span></p><p><span>예를 들어, SCCS는 </span><em>자동</em><span> 리비전 추적 </span> 기능을<span>최초로 도입했습니다 </span>.<span> 이제 개발자는 명령을 작성하여 파일의 현재 버전을 자동으로 저장할 수 있습니다. 그리고 다른 명령을 실행하여 과거 버전을 검색할 수도 있었습니다. 이후 버전의 SCCS는 브랜칭과 병합도 지원했습니다. </span></p><p>SCCS는 개발자 워크플로에 있어 큰 도약이었습니다.</p><p><span>그 기능 중 가장 독특한 것은 저장 메커니즘이었습니다. 버전 관리 중인 파일의 전체 복제본을 저장하는 대신 변경 사항만 저장했습니다. 파일의 첫 번째 버전을 기본 버전으로 취급하여 전체 내용을 저장했습니다. 이후 업데이트의 경우, 변경 사항만 </span><span> SCCS 내부 파일 내에</span><em>'델타</em>'<span>로 저장했습니다 </span>.</p><p>이 기법은 파일 저장 공간을 최적화하는 데 매우 효과적이었습니다.</p><p>하지만 도구의 사용량이 늘어나면서 SCCS에서 사용하는 델타 저장 기법이 성능에 적합하지 않다는 것이 분명해졌습니다. 특정 버전에 대한 파일을 재구성하려면 기본 버전부터 시작한 다음 델타를 순차적으로 적용해야 했습니다. 이것이 바로 '포워드 델타'라고 불리는 이유이기도 합니다.</p><p>포워드 델타는 전체 그림을 보고 싶을 때마다 직소 퍼즐을 처음부터 다시 조립하는 것과 같았습니다. 일반적인 사용 패턴에서는 비효율적이었습니다.</p><p><span>10년 후인 1982년, 퍼듀 대학교의 월터 티치(Walter F. Tichy</span>)는<span> SCCS를 대체할 수 있는 더 뛰어난 성능의</span><span><a data-component-name="FootnoteAnchorToDOM" id="footnote-anchor-3-139457354" href="https://osshistory.org/p/the-world-before-git#footnote-3-139457354" target="_self" rel="">RCS3를</a></span><span>출시했습니다</span>.</p><div><p><span>월터는 델타 스토리지의 개념은 유지했지만 '역델타' 방식으로 메커니즘을 뒤집었습니다. 그는 첫 번째 버전을 기본으로 사용하는 대신 최신 버전을 현명하게 선택했습니다. RCS 델타는 최신 버전의 코드와 비교하여 변경 사항을 비교했습니다. </span></p><p><span>개발자가 파일 히스토리에서 너무 멀리 거슬러 올라가는 경우가 거의 없기 때문에 일반적인 작업에 훨씬 더 효율적이었습니다. 성능 개선 외에도 RCS는 더 간단한 명령어로 사용자 환경을 개선하고, 당시 개발자에게 더 직관적인 분기 및 병합 시스템을 도입했습니다. </span></p></div><p>프로그램이 계속 복잡해지면서 SCCS와 RCS는 더 이상 개발자의 요구를 충족할 수 없게 되었습니다. 두 시스템 모두 단일 머신의 프로젝트에 가장 적합했습니다. 둘 다 전체 프로젝트가 아닌 개별 파일만 버전 관리가 가능했습니다. 한 개발자가 파일을 편집하면 같은 네트워크에서 다른 개발자가 동시에 편집할 수 없도록 파일이 잠겼습니다.</p><p><span>이러한 단점을 극복하기 위해 딕 그루네는</span><span> 네덜란드 브리헤 대학교에서 근무하던 1986년</span><span><a data-component-name="FootnoteAnchorToDOM" id="footnote-anchor-4-139457354" href="https://osshistory.org/p/the-world-before-git#footnote-4-139457354" target="_self" rel="">CVS4를</a></span><span>출시했습니다</span>.</p><p>CVS는 여전히 백엔드에서 RCS를 사용했지만 다중 파일 지원을 추가하고 클라이언트-서버 협업 모델을 도입했습니다. 즉, 코드베이스를 중앙 서버에 저장하고 서로 다른 위치의 개발자가 액세스하여 공동 작업을 용이하게 할 수 있게 되었습니다. 전성기 시절 CVS는 큰 도약을 이루었습니다.</p><p>1990년대 중반, 소프트웨어 세계는 많은 새로운 독점적 VCS가 등장하여 다양한 영역에서 혁신을 이루었습니다.</p><p>Atria Software의 ClearCase는 강력한 브랜칭 모델과 기업 내 개별 팀의 선호도에 맞게 워크플로를 구성할 수 있는 기능을 도입했습니다. 사용자 친화적인 인터페이스로 유명한 One Tree Software의 SourceSafe는 Microsoft에 인수되었습니다. Perforce는 뛰어난 성능으로 유명했습니다.</p><p>오픈 소스 VCS 생태계는 대부분 조용했습니다.</p><p><span>2000년에</span><span><a data-component-name="FootnoteAnchorToDOM" id="footnote-anchor-5-139457354" href="https://osshistory.org/p/the-world-before-git#footnote-5-139457354" target="_self" rel="">BitKeeper5가</a></span><span> 등장했습니다. 독점적이긴 했지만, 이 제품은 이후 Git의 역사에서 중요한 역할을 하게 됩니다. 또한 2000년에는</span><span> CVS에 이어 차세대 주요 오픈 소스 VCS가</span> 될 <span><a data-component-name="FootnoteAnchorToDOM" id="footnote-anchor-6-139457354" href="https://osshistory.org/p/the-world-before-git#footnote-6-139457354" target="_self" rel="">SVN6에</a></span><span> 대한 작업이 시작되었습니다</span>.</p><p>SVN은 칼 포겔과 짐 블랜디의 주요 공헌으로 콜라보넷(CollabNet Inc.)에서 만들었습니다. CVS의 단점을 극복하기 위해 설계되었으며, 오픈 소스 커뮤니티에서 큰 인기를 얻었습니다. 일부 개발자는 현재까지도 이를 사용하고 있습니다.</p><p>SVN이 도입한 핵심 아이디어는 원자 커밋입니다. CVS에서는 커밋 작업이 중간에 실패하면 데이터가 손상될 수 있었습니다. 파일의 일부는 저장되고 일부는 손실될 수 있었죠. SVN의 커밋은 전부 아니면 전무 접근 방식을 채택하여 안정성을 보장합니다.</p><p>SVN은 데이터 저장 메커니즘에도 혁신을 가져왔습니다. CVS에서는 브랜치를 만들면 기본적으로 해당 시점의 원본 브랜치에 있는 모든 파일의 전체 복사본을 만들었습니다. 이는 특히 대규모 프로젝트의 경우 저장 공간을 많이 차지했습니다. SVN에서 브랜치를 만들면 모든 파일을 복제하지 않습니다. 대신 처음에는 원본 파일에 대한 참조만 있는 브랜치에 대한 새 디렉터리를 만들었습니다. 새 브랜치에서 변경 사항이 발생하면 SVN은 해당 변경 사항만 저장합니다.</p><p>SVN은 그 이전까지 다른 모든 VCS와 마찬가지로 중앙 집중식이었습니다. 개발자는 로컬에서 코드를 작성하지만 버전 관리 정보는 중앙 리포지토리에 의존해야 했습니다. 히스토리 보기, 변경 사항 커밋, 브랜치 생성 등의 작업은 중앙 서버에 연결해야 하며 오프라인에서는 불가능했습니다.</p><div><p><span>비트키퍼는 최초의 대중적인 분산형 VCS라는 점에서 의미가 있습니다. SVN과 달리 개발자가 작업 중인 프로젝트의 전체 로컬 복사본을 가질 수 있었는데, 이는 당시로서는 새로운 개념이었습니다. 일부 기업 환경에서는 SVN의 제한적인 접근 방식이 장점으로 여겨지기도 했지만, 비트키퍼의 분산 모델은 오픈소스 협업의 특성에 더 적합했습니다.</span></p><p><span>이러한 이유로 가장 주목할 만한 사용자인 Linux 커널 프로젝트에서 채택되었습니다.</span></p></div><p>기술적인 측면에서 BitKeeper는 커널 프로젝트에 완벽했습니다. 하지만 오픈 소스 소프트웨어는 아니었습니다. 라이너스 토발즈는 BitKeeper가 마음에 들어 이를 채택했지만 커널 코어 팀의 반발로 인해 계속 사용할 수 없었습니다.</p><p>독점 시스템을 사용하는 것은 플래그십 무료 프로젝트의 원칙에 어긋나는 것으로 여겨졌기 때문입니다. 당시 다른 VCS도 있었지만 커널만큼 복잡한 프로젝트의 성능 요구 사항을 충족하는 것은 없었습니다.</p><p><span>실제로 그렇게 하고 싶지는</span><span><a data-component-name="FootnoteAnchorToDOM" id="footnote-anchor-7-139457354" href="https://osshistory.org/p/the-world-before-git#footnote-7-139457354" target="_self" rel="">않았지만7</a></span><span>, 라이너스는 자신만의 도구를 만들기로 결심했고, 결국 2주 만에 Git을 출시했습니다. 그는 Git을 "멍청한 콘텐츠 트래커"라고 묘사했습니다 </span>.<span><a data-component-name="FootnoteAnchorToDOM" id="footnote-anchor-8-139457354" href="https://osshistory.org/p/the-world-before-git#footnote-8-139457354" target="_self" rel="">8</a></span></p><p>나머지는 다들 아시다시피 역사입니다.</p><p>이 글에 도움을 주신 Tyler Von Harz에게 특별히 감사드립니다.</p></div></article></div></div>
      </article>
    </body>
  </html>
  