
  <html lang="ko">
    <head>
      <meta charset="utf-8">
      <title>10 Best Practices in Front-end Development (React) - Renan Olovics - Medium</title>
      <link rel="canonical" href="https://medium.com/@renanolovics/10-best-practices-in-front-end-development-react-5277a671e2df">
    </head>
    <body>
      <article>
        <div id="readability-page-1" class="page"><div><div><a rel="noopener follow" href="https://medium.com/@renanolovics?source=post_page-----5277a671e2df--------------------------------"><div aria-hidden="false"><p><img alt="Renan Olovics" src="https://miro.medium.com/v2/da:true/resize:fill:88:88/0*HfHlVKGGwETJa-GQ" width="44" height="44" loading="lazy" data-testid="authorPhoto"></p></div></a></div><figure></figure><p id="8fe0">새로운 직장에 취직하여 설레는 마음으로 일을 시작하게 되는 상황은 누구나 경험해 보셨을 것입니다. 면접관들이 회사에 대해 밝고 매력적인 그림을 그려주면 이전 직장을 그만두기로 결심하게 됩니다. '휴가'라고만 표현할 수 있는 일주일간의 시간이 지나고, 대부분의 경우 일상에서 잠시 벗어난 휴식의 시간이 지나면 드디어 새로운 직업적 여정을 시작할 때가 됩니다. 기대에 부풀어 프로젝트를 컴퓨터에 복제하고 나면 갑자기 울고 싶을 정도로 엉망인 임시방편 솔루션, 표준의 부재, 나름의 논리가 있는 것처럼 보이는 코드와 마주하게 됩니다. '도대체 이게 뭐지'라는 생각이 들 정도입니다. 어떻게 작동하는지도 모르겠고, 조금만 변경해도 모든 것이 중단될 것 같아서 조금이라도 변경하기가 두렵습니다.</p><p id="14c3">이러한 상황은 생각보다 흔하지 않은 일처럼 보이지만, 생각보다 매우 흔한 일입니다. 이런 일이 발생하지 않도록 하려면 개발자, 특히 고위직에 있는 개발자가 앞장서야 합니다. 최고 경영진, 기술 책임자, 제품 소유자 등의 전문가들은 코드 품질에 관계없이 회사에 가치와 결과를 제공하는 데 더 신경을 쓰기 때문에 코드 세부 사항에 집중할 시간이나 우선순위가 없는 경우가 많기 때문입니다. 이러한 문제를 피하기 위해 저는 제 프로젝트에 필수적이라고 생각하며 모두가 채택해야 한다고 생각하는 구체적인 관행을 도입했습니다. 모든 사람이 여러분의 코드를 기억하지는 못하겠지만, 코드 리뷰를 수행하는 사람들은 분명 여러분의 세심한 주의를 알아채고 칭찬할 것입니다. 이는 회사에서 눈에 띄는 가장 효과적인 방법 중 하나가 될 수 있으며, 어쩌면 승진할 수 있는 좋은 기회가 될 수도 있습니다.</p><h2 id="d284"><strong>1. 상대 경로 대신 절대 경로 사용</strong></h2><p id="1d0c">새 프로젝트에 들어가면 "../../../.../.../."로 채워진 경로를 흔히 접하게 됩니다. 이러한 경로는 상대 경로로 알려져 있으며, 파일을 가져오는 방법이지만 가장 권장되는 방법은 아닙니다. 이상적인 방법은 파일의 전체 경로를 제공하는 절대 경로를 사용하는 것입니다. 프로젝트에서 이를 구현하려면 몇 가지 구성이 필요하며, 특히 Webpack 또는 TypeScript를 사용하는 경우 더욱 그렇습니다.</p><p id="4629">Webpack(create-react-app) 설정:</p><p id="383a">create-react-app를 사용하는 경우, 절대 경로를 구성하는 것은 비교적 간단합니다. 먼저 프로젝트의 루트에 "jsconfig.json"이라는 파일을 생성하고 다음 내용을 추가합니다:</p><pre translate="no"><span id="677e">{<br>  "compilerOptions": {<br>    "baseUrl": "src"<br>  },<br>  "include": ["src"]<br>}</span></pre><p id="d9fb">TypeScript 설정:</p><p id="d760">TypeScript를 사용하는 경우 "tsconfig.json" 파일에 다음 구성을 추가합니다:</p><pre translate="no"><span id="90b5">{<br>  "compilerOptions": {<br>    "baseUrl": "src",<br>    "paths": {<br>      "@/*": ["src/*"]<br>    }<br>  },<br>  "include": ["src"]<br>}</span></pre><p id="6e55">이렇게 하면 다음과 같은 코드 스니펫을 다음과 같이 변형할 수 있습니다:</p><pre translate="no"><span id="e9a1">import { Button } from '../../../../components/Button'<br>import { Icon } from '../../../../components/Icon'<br>import { Input } from '../../../../components/Input'</span></pre><p id="ae37">다음과 같이 더 깔끔하고 읽기 쉬운 형태로 변환할 수 있습니다:</p><pre translate="no"><span id="e617">import { Button } from '@/components/Button'<br>import { Icon } from '@/components/Icon'<br>import { Input } from '@/components/Input'</span></pre><h2 id="0d13"><strong>2. 모듈 구성에 "내보내기 배럴" 사용</strong></h2><p id="16af">앞서 언급한 코드를 살펴보면서 코드 가독성과 유지보수를 크게 향상시킬 수 있는 기술인 "내보내기 배럴", 즉 "다시 내보내기"가 떠올랐습니다. 이 접근 방식은 폴더 내에 "index.js"(또는 TypeScript를 사용하는 경우 "index.ts")라는 파일을 만들고 이 파일에서 폴더에 있는 모든 모듈을 내보내는 것입니다.</p><p id="6e54">예를 들어 "components"라는 이름의 폴더에 다음과 같은 파일이 있다고 가정해 보겠습니다: "Button.tsx", "Icon.tsx", "Input.tsx". "내보내기 배럴" 기법을 사용하면 "index.ts" 파일을 만들어 다음과 같이 채울 수 있습니다:</p><pre translate="no"><span id="4ecf">export * from './Button'<br>export * from './Icon'<br>export * from './Input'</span></pre><p id="c7f5">이렇게 하면 페이지나 다른 모듈에서 이러한 컴포넌트를 사용하고자 할 때 이렇게 한 번에 모두 가져올 수 있습니다:</p><pre translate="no"><span id="68f0">import { Button, Icon, Input } from '@/components'</span></pre><p id="4694">이렇게 하면 각 컴포넌트를 개별적으로 나열할 필요가 없으므로 코드 구성이 간소화되고 유지 관리가 개선됩니다. 또한 코드를 더 깔끔하고 이해하기 쉽게 만들 수 있어 중대형 프로젝트에서 매우 중요합니다.</p><h2 id="5704"><strong>3. "내보내기 기본값"과 "명명된 내보내기" 중에서 선택하기</strong></h2><p id="008e">"내보내기 배럴"에 대한 주제를 살펴볼 때 "내보내기 기본값"의 사용과 충돌할 수 있다는 점에 유의해야 합니다. 명확하지 않은 경우 예제를 통해 상황을 설명하겠습니다:</p><p id="1f5b">컴포넌트로 돌아가 보겠습니다:</p><pre translate="no"><span id="a851">export const Button = () =&gt; {<br>  return &lt;button&gt;Button&lt;/button&gt;<br>}<br>export default Button</span></pre><pre translate="no"><span id="5135">export const Icon = () =&gt; {<br>  return &lt;svg&gt;Icon&lt;/svg&gt;<br>}<br>export default Icon</span></pre><pre translate="no"><span id="8d3b">export const Input = () =&gt; {<br>  return &lt;input /&gt;<br>}<br>export default Input</span></pre><p id="44ab">각 컴포넌트가 별도의 파일에 있고 이 모든 컴포넌트를 한꺼번에 가져오고 싶다고 가정해 보겠습니다. 기본 가져오기에 익숙하다면 다음과 같은 방법을 시도할 수 있습니다:</p><pre translate="no"><span id="b135">import Button from '@/components'<br>import Icon from '@/components'<br>import Input from '@/components'</span></pre><p id="2869">하지만 자바스크립트가 사용할 '내보내기 기본값'을 결정할 수 없어 오류가 발생하기 때문에 이 방법은 작동하지 않습니다. 다음과 같은 작업을 수행해야 합니다:</p><pre translate="no"><span id="b4a7">import Button from '@/components/Button'<br>import Icon from '@/components/Icon'<br>import Input from '@/components/Input'</span></pre><p id="58ef">그러나 이렇게 하면 "내보내기 배럴"의 장점이 무효화됩니다. 이 딜레마를 어떻게 해결할 수 있을까요? 해결책은 간단합니다. '기본값' 없이 내보내는 '명명된 내보내기'를 사용하면 됩니다:</p><pre translate="no"><span id="63cc">import { Button, Icon, Input } from '@/components'</span></pre><p id="3ed9">'기본 내보내기'와 관련된 또 다른 중요한 문제는 가져오는 파일의 이름을 변경하는 기능입니다. 제 경력 초기에 있었던 실제 사례를 공유하겠습니다. 저는 이전 개발자가 모든 항목에 '기본값 내보내기'를 사용하던 React Native 프로젝트를 물려받았습니다. "로그인", "등록", "비밀번호 찾기"라는 이름의 화면이 있었습니다. 하지만 세 화면은 모두 약간의 수정만 가한 서로의 복사본이었습니다. 문제는 각 화면 파일의 마지막에 "기본 로그인 내보내기"가 있다는 것이었습니다. 이로 인해 경로 파일이 올바르게 가져와서 혼동을 일으켰습니다:</p><pre translate="no"><span id="1bfb">import Login from '../../screens/Login'<br>import Register from '../../screens/Register'<br>import ForgotPassword from '../../screens/ForgotPassword'<p>// Further down, the usage in routes:</p><p>  {<br>    ResetPassword: { screen: ResetPassword },<br>    Login: { screen: LoginScreen },<br>    Register: { screen: RegisterScreen },<br>  }</p></span></pre><p id="ea92">그러나 화면 파일을 열면 모두 같은 이름으로 내보내졌습니다:</p><pre translate="no"><span id="083c">const login() {<br>  return &lt;&gt;tela de login&lt;/&gt;<br>}<br>export default Login</span></pre><pre translate="no"><span id="529d">const login() {<br>  return &lt;&gt;tela de registro&lt;/&gt;<br>}<br>export default Login</span></pre><pre translate="no"><span id="b5f6">const login() {<br>  return &lt;&gt;tela de esqueci minha senha&lt;/&gt;<br>}<br>export default Login</span></pre><p id="95e2">이로 인해 계속되는 혼란과 오류를 피하기 위해 극도의 주의를 기울여야 하는 유지 관리의 악몽이 발생했습니다.</p><p id="60a0">요약하자면, 프로젝트에서 대부분의 경우 "이름 지정 내보내기"를 사용하고 꼭 필요한 경우에만 "기본 내보내기"를 사용하는 것이 좋습니다. Next.js 경로 및 React.lazy와 같이 "내보내기 기본값"을 사용해야 하는 상황이 있을 수 있습니다. 그러나 코드의 명확성과 특정 요구 사항 준수 사이의 균형을 맞추는 것이 중요합니다.</p><h2 id="36b2"><strong>4. 적절한 파일 이름 지정 규칙</strong></h2><p id="86f9">다음과 같은 파일이 있는 컴포넌트 폴더가 있다고 가정해 보겠습니다:</p><pre translate="no"><span id="65b1">--components:<br>----Button.tsx<br>----Icon.tsx<br>----Input.tsx</span></pre><p id="8624">이제 이러한 컴포넌트의 스타일, 로직 또는 유형을 별도의 파일로 분리하고 싶다고 가정해 봅시다. 이 파일들의 이름은 어떻게 지을까요? 분명한 접근 방식은 다음과 같을 수 있습니다:</p><pre translate="no"><span id="02f4">--components:<br>----Button.tsx<br>----Button.styles.css<br>----Icon.tsx<br>----Icon.styles.css<br>----Input.tsx<br>----Input.styles.css</span></pre><p id="709b">물론 이러한 접근 방식은 다소 무질서해 보이고 이해하기 어려울 수 있으며, 특히 로직이나 유형과 같이 컴포넌트를 별도의 파일로 더 나누려고 할 때 더욱 그렇습니다. 그렇다면 어떻게 하면 구조를 체계적으로 유지할 수 있을까요? 여기에 해결책이 있습니다:</p><pre translate="no"><span id="4665">--components:<br>----Button<br>------index.ts (exports everything necessary)<br>------types.ts<br>------styles.css<br>------utils.ts<br>------component.tsx<br>----Icon<br>------index.ts (exports everything necessary)<br>------types.ts<br>------styles.css<br>------utils.ts<br>------component.tsx<br>----Input<br>------index.ts (exports everything necessary)<br>------types.ts<br>------styles.css<br>------utils.ts<br>------component.tsx</span></pre><p id="917a">이 방법을 사용하면 각 파일의 용도를 쉽게 파악할 수 있고 필요한 항목을 쉽게 검색할 수 있습니다. 또한 Next.js 또는 이와 유사한 프레임워크를 사용하는 경우 파일 이름을 조정하여 컴포넌트가 클라이언트용인지 서버용인지를 나타낼 수 있습니다. 예를 들어</p><pre translate="no"><span id="87f2">--components:<br>----RandomComponent<br>------index.ts (exports everything necessary)<br>------types.ts<br>------styles.css<br>------utils.ts<br>------component.tsx<br>----RandomComponent2<br>------index.ts (exports everything necessary)<br>------types.ts<br>------styles.css<br>------utils.ts<br>------component.server.tsx</span></pre><p id="d418">이렇게 하면 확인을 위해 코드를 열지 않고도 컴포넌트가 클라이언트용인지 서버용인지 구분하는 것이 매우 간단해집니다. 파일 이름을 체계화하고 표준화하는 것은 개발 프로젝트의 명확성과 효율성을 유지하는 데 필수적입니다.</p><h2 id="af8f"><strong>5. 코드 표준화를 위한 ESLint의 올바른 사용과 예뻐지기</strong></h2><p id="3ff8">10명이 넘는 동료와 함께 프로젝트를 진행하면서 각자의 과거 경험에서 우러나온 코딩 스타일을 가지고 있다고 상상해 보세요. 바로 이때 ESLint와 Prettier가 필요합니다. 팀 전체에서 코드 일관성을 유지하는 데 중요한 역할을 합니다.</p><p id="850c">Prettier는 코드 서식의 일종의 '수호자' 역할을 하여 모든 사람이 프로젝트에 설정된 스타일 가이드라인을 준수하도록 합니다. 예를 들어 프로젝트의 표준에서 큰따옴표를 사용하도록 지시하는 경우, Prettier가 자동으로 작은따옴표로 대체하기 때문에 그냥 작은따옴표를 선택할 수 없습니다. 그 외에도 코드 정렬, 문 끝에 세미콜론 추가 등 다양한 수정 및 서식 지정 작업을 수행할 수 있습니다. 구체적인 프리티어 규칙은 공식 문서에서 확인할 수 있습니다: Prettier 옵션에서 확인할 수 있습니다.</p><p id="b061">반면에 ESLint는 코드에 특정 규칙을 적용하여 일관성 있고 일관된 코드베이스를 유지하는 데 도움을 줍니다. 예를 들어, 일반 함수보다 화살표 함수를 사용하도록 강제하고, React 종속성 배열이 제대로 채워졌는지 확인하고, "let" 및 "const" 대신 "var" 선언을 사용하지 못하도록 하며, camelCase와 같은 명명 규칙을 적용할 수 있습니다. 구체적인 ESLint 규칙은 공식 문서에서 확인할 수 있습니다: ESLint 규칙.</p><p id="bb90">ESLint와 Prettier를 함께 사용하면 소스 코드의 일관성을 유지하는 데 도움이 됩니다. 이러한 도구가 없으면 개발자마다 각자의 스타일을 따를 수 있으며, 이는 향후 충돌과 유지 관리의 어려움으로 이어질 수 있습니다. 이러한 도구를 설정하는 것은 코드를 체계적이고 이해하기 쉽게 유지하는 데 도움이 되므로 프로젝트의 수명을 늘리는 데 필수적입니다. 팀과 프로젝트 전체에 큰 도움이 되므로 아직 ESLint와 Prettier를 사용하고 있지 않다면 워크플로에 통합하는 것을 진지하게 고려해 보세요.</p><h2 id="0f89"><strong>6. 허스키와 린트 단계별: 코드 표준화 강화</strong></h2><p id="b18c">ESLint와 Prettier에 이미 익숙하다면 어떤 상황에서는 이러한 도구에 정의된 규칙을 우회하는 것이 가능하다는 것을 알고 계실 것입니다. 확립된 코드 가이드라인을 준수하고 서식 지정 문제를 방지하려면 허스키와 Lint-Staged를 사용하는 것이 좋습니다.</p><p id="78f7">이 두 도구는 개발 워크플로에서 중요한 역할을 하며, 커밋하기 전에 ESLint와 Prettier를 실행하도록 설정할 수 있습니다. 즉, 코드가 설정한 규칙을 준수하지 않으면 커밋할 수 없습니다. 또한 리포지토리에 푸시하기 전에 코드를 검사하도록 이러한 도구를 구성할 수도 있습니다.</p><p id="0022">또한 Husky는 커밋 또는 푸시 전에 다른 스크립트나 작업을 실행할 수 있도록 지원하므로 검증 작업을 자동화하고 코드 품질을 보장할 수 있는 가능성이 넓어집니다.</p><p id="dc02">Husky와 Lint-Staged의 또 다른 장점은 GitHub와 같은 코드 호스팅 플랫폼과의 통합입니다. 이를 통해 풀 리퀘스트를 수락하기 전에 자동화된 테스트 및 품질 검사를 설정할 수 있습니다. 이렇게 하면 제출된 코드가 설정된 규칙을 준수하는지 확인하여 문제를 최소화하고 일관성을 보장할 수 있습니다.</p><p id="110e">이러한 도구는 개발자가 명백한 문제가 있는 커밋을 하는 것을 방지하고 코드가 항상 정해진 가이드라인에 부합하는지 확인하는 데 필수적입니다. ESLint, Prettier, Husky, Lint-Staged의 조합은 프로젝트에서 코드 품질과 표준화를 유지하는 데 매우 효과적인 방법입니다.</p><h2 id="3542"><strong>7. 로직 재사용성을 위한 커스텀 훅</strong></h2><p id="7b1e">React로 작업할 때 react-router-dom, Next.js 또는 react-navigation(React Native의 경우)과 같은 라이브러리에서 제공하는 탐색 훅을 사용하는 것이 일반적입니다. 그러나 이러한 일반적인 탐색 후크는 애플리케이션의 특정 페이지에 대한 지식이 부족하여 제한이 발생할 수 있습니다. 효과적인 해결책은 애플리케이션의 모든 페이지를 인식하는 사용자 정의 탐색 훅을 만들어 페이지 사이를 쉽게 탐색할 수 있도록 하는 것입니다.</p><p id="3810">다음은 사용자 정의 탐색 후크 생성의 예입니다:</p><pre translate="no"><span id="3ee0">import { useCallback } from 'react'<br>import { useNavigate } from 'react-router-dom'<br>import type { Routes } from '@/types'<p>export const useRouter = () =&gt; {<br>  const navigate = useCallback((path: Routes) =&gt; goTo(path), [goTo])</p><p>  return { navigate }<br>}</p></span></pre><p id="4a6e">탐색 훅을 추상화하는 것이 복잡해 보이기 때문에 처음에는 약간의 저항이 있을 수 있습니다. 하지만 장기적으로 볼 때 이 접근 방식은 몇 가지 장점을 제공합니다. 후크 호출을 단순화하고 함수에 대한 자동 완성 기능을 제공하므로 코드가 더 깔끔하고 이해하기 쉬워집니다. 또한 나중에 탐색 라이브러리를 변경해야 하는 경우 탐색 훅이 사용되는 모든 곳에서 변경하는 것이 아니라 사용자 정의 훅에서만 변경하면 되므로 유지 관리가 간소화됩니다.</p><p id="eaa4">이와 같은 사용자 정의 훅을 만드는 아이디어는 쿠키, 로컬 저장소(localStorage), API 호출 등 애플리케이션의 다른 측면에도 적용할 수 있습니다. 이 접근 방식을 사용하면 프로젝트의 여러 위치에서 로직을 쉽게 재사용할 수 있으므로 모듈성을 높이고 코드 유지 관리를 간소화할 수 있습니다.</p><h2 id="d5d0"><strong>8. 훅과 유틸리티 함수의 차이점</strong></h2><p id="f2c8">훅과 유틸리티 함수를 만드는 것의 차이점을 이해하는 것은 매우 중요하지만, 개발자들은 종종 이 두 개념을 혼동하기도 합니다. 이 차이를 설명하기 위해 제가 프로젝트에서 사용했던 경험이 적은 접근 방식을 반영한 실제 예제를 공유하겠습니다.</p><p id="edf0">Hooks 폴더 내부:</p><pre translate="no"><span id="3363">export const useFormat = () =&gt; {<br>  const formatHour = (date: number) =&gt; {<br>    return new Date(date).toLocaleTimeString('pt', { timeStyle: 'short' })<br>  }<br>  // Other date/time formatting functions<br>  return { formatHour }<br>}</span></pre><p id="4b64">이 예제에서는 실제로 유틸리티 함수를 포함하는 훅을 만들었습니다. 이 접근 방식은 훅을 사용하는 컴포넌트가 렌더링될 때마다 새 훅이 생성되어 성능에 영향을 줄 수 있으므로 가장 효율적이지 않습니다. 또한 후크는 컴포넌트에 한정되어 있어 다른 컨텍스트에서 쉽게 재사용할 수 없습니다.</p><p id="c596">올바른 접근 방식은 "Utils"와 같은 전용 디렉터리에 유틸리티 함수를 만드는 것입니다:</p><p id="9c30">Utils 폴더 안에:</p><pre translate="no"><span id="2fb8">export const formatHour = (date: number) =&gt; {<br>  return new Date(date).toLocaleTimeString('pt', { timeStyle: 'short' })<br>}</span></pre><p id="379b">이 경우 유틸리티 함수는 한 번만 생성되며 컨텍스트에 관계없이 프로젝트의 어느 곳에서나 사용할 수 있습니다. 특정 컴포넌트에 묶여 있지 않으며 렌더링할 때마다 후크를 생성하는 오버헤드를 발생시키지 않습니다.</p><p id="2dd3">근본적인 차이점은 후크는 시각적인 부분이 없는 컴포넌트로서 React 외부에서 생성되고 특정 컴포넌트 내에서 호출되는 반면, 유틸리티 함수는 React 컨텍스트 외부에서 한 번만 생성되고 어디서나 사용할 수 있다는 점입니다. 후크와 유틸리티 함수 중 어떤 것을 선택할지는 프로젝트의 특정 요구사항과 코드 재사용에 대한 고려사항을 기반으로 결정해야 합니다.</p><h2 id="a667"><strong>9. 성능 최적화를 위해 useCallback과 useMemo 사용하기</strong></h2><p id="420e">사용 콜백, 사용 메모를 사용하는 것과 사용하지 않는 것의 차이는 React 애플리케이션의 성능 최적화에 큰 영향을 미칠 수 있습니다. 기본적으로 사용콜백은 함수를 메모하는 데 사용되는 반면, 사용메모는 값을 메모하는 데 사용됩니다. 두 가지 모두 컴포넌트가 렌더링될 때마다 함수나 값이 다시 생성되는 것을 방지하는 데 사용됩니다.</p><p id="c4cd">이는 렌더링 중에 함수와 값이 자주 다시 생성되는 React의 본질적인 문제 때문에 특히 중요합니다. React는 효율적이지만 이렇게 자주 재생성하면 자식 컴포넌트가 불필요하게 다시 렌더링되어 잠재적으로 성능 저하를 초래할 수 있습니다. 이 문제는 React가 설계된 방식 때문에 발생하며, 쉽게 변경할 수 있는 것이 아니라는 점에 유의해야 합니다.</p><p id="e43c">이 문제에 대한 해결책은 사용콜백과 사용메모를 신중하게 사용하는 것입니다. 이를 통해 함수와 값을 자주 재생성하는 것을 피할 수 있으므로 애플리케이션의 성능을 향상시킬 수 있습니다. 그러나 과도하게 사용하면 오히려 역효과가 발생하여 성능이 저하될 수 있으므로 신중하게 사용하는 것이 중요합니다. 사용콜백이나 사용메모를 사용할 때마다 함수나 값을 생성하는 작업과 메모하는 작업의 두 가지 작업이 포함됩니다. 또한 일부 함수나 값은 메모하는 것보다 다시 만드는 것이 더 효율적일 수 있습니다.</p><p id="df38">이 문제에 이미 익숙하다면 사용 콜백 및 사용 메모를 사용하는 방법을 알고 있을 것입니다. 그러나 과도하게 사용하면 성능이 저하되고 심지어 추적하기 어려운 버그가 발생할 수도 있으므로 주의해야 합니다(이러한 버그는 원치 않을 것입니다).</p><p id="cd15">이 문제에 익숙하지 않다면, React 애플리케이션에서 성능 문제와 디버깅 문제를 일으킬 수 있는 중요한 문제이므로 이 주제에 대한 다양한 기사를 읽어보시길 적극 권장합니다.</p><h2 id="3438"><strong>10. 논리 분리</strong></h2><p id="ae9c">후크와 유틸리티 함수의 구분을 고려하는 것 외에도 페이지를 가능한 한 단순하게 유지하고 가능한 경우 로직을 분리하는 것이 중요합니다. 이렇게 하면 코드의 구성과 유지보수성을 향상시킬 수 있습니다. 다음은 고려해야 할 몇 가지 사례입니다:</p><p id="623b">토스트 로직: 페이지에 건배사를 표시해야 하는 경우 건배사를 표시하기 위한 별도의 컴포넌트와 전용 함수를 만드는 것이 좋습니다. 이렇게 하면 페이지의 프레젠테이션과 로직을 분리할 수 있습니다.</p><p id="c5f2">API 호출: 페이지에서 API 호출을 하는 경우 React Query와 같은 라이브러리를 사용하고 이러한 호출과 관련된 로직을 외부 훅에 보관하는 것이 좋습니다. 그러면 페이지 자체에서 이 훅을 사용하여 페이지가 더 깔끔하게 유지되고 프레젠테이션에 집중할 수 있습니다.</p><p id="dc68">재사용 가능한 컴포넌트: 애플리케이션의 여러 부분에서 재사용할 수 있는 컴포넌트의 경우 글로벌 컴포넌트 디렉토리에 배치하세요. 이런 식으로 구성이 혼란스러우면 원자 설계와 같은 컴포넌트 디자인 패턴을 채택할 수 있습니다. 그러나 소프트웨어 개발은 역동적이며 언제든지 새로운 접근 방식이 등장할 수 있다는 점을 기억하세요. 특정 상황에 맞는 이러한 접근 방식의 품질과 효과를 평가하세요.</p><p id="3226">이러한 코드 정리 관행을 따르고 지속적으로 학습하려는 마음가짐을 가지면 작업의 품질과 효율성을 개선하는 동시에 코드를 더 쉽게 이해하고 유지 관리할 수 있습니다. 이는 결과적으로 개발자로서의 업무 가치를 더욱 높여줄 것입니다.</p><h2 id="5d68"><strong>결론</strong></h2><p id="4c27">소프트웨어 개발은 끊임없이 진화하는 분야이므로 지속적으로 적응하고 학습하는 능력이 매우 중요하다는 점을 기억하세요. 여기서 설명한 각 사례와 개념은 코드를 보다 효율적이고 가독성이 높으며 유지 관리하기 쉽게 만드는 것을 목표로 합니다. 이러한 가이드라인을 구현하고 지속적으로 개선점을 모색함으로써 작업의 품질을 높이고 개발자로서의 커리어에 더 많은 가치를 더할 수 있습니다. 이 역동적이고 도전적인 분야에서 성공하기 위해서는 지속적인 학습이 중요하므로 최신 정보를 얻고 새로운 접근 방식을 계속 탐구하세요.</p><p id="050a">궁금한 점이 있거나, 기사에 대한 의견이나 제안이 있으면 언제든지 문의해 주세요.</p><p id="1305"><a href="https://www.linkedin.com/in/renan-olovics/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a></p></div></div>
      </article>
    </body>
  </html>
  