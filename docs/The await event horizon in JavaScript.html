
  <html lang="ko">
    <head>
      <meta charset="utf-8">
      <title>The await event horizon in JavaScript</title>
      <link rel="canonical" href="https://frontside.com/blog/2023-12-11-await-event-horizon/">
      <style>
        pre {
          padding: 1rem;
          background-color: #263238;
          color: #fff
        }
      </style>
    </head>
    <body>
      <article>
        <div id="readability-page-1" class="page"><div><p>모든 블랙홀 주변에는 중력에서 벗어나는 데 필요한 속도가 광속을 초과하는 경계가 있습니다. 빛 자체를 포함한 모든 물체가 이 한계점을 통과하면 블랙홀의 신비한 내부에 영원히 갇히게 됩니다. 탈출할 수도 없고 우주의 나머지 부분으로 돌아갈 수도 없습니다. 이 경계를 블랙홀의 사건 지평선이라고 합니다.</p>
<p>모든 자바스크립트 프로미스에도 비슷한 경계가 존재하며, 실행 흐름이 이 경계를 넘어가면 강제로 탈출하거나 원점으로 돌아갈 수 있는 방법이 없습니다. 저는 이 경계를 프로미스의 <code translate="no">await</code> 이벤트 지평선이라고 부릅니다.</p>
<p>비동기 함수는 프로미스의 결과를 기다리며 일시 정지할 때마다 <code translate="no">await</code> 이벤트 지평선을 통과합니다. 그렇게 되면 해당 프로미스가 안정화될 때까지 제어가 다시 돌아올 수 없으며, 해당 프로미스(또는 모든 프로미스)가 안정화될 것이라고 보장할 수 있는 방법은 전혀 없습니다. 이벤트 루프의 다음 틱에서 발생할 수도 있고, 최악의 경우 전혀 해결되지 않을 수도 있습니다. 그렇게 되면 불쌍한 대기 함수는 호박 속에 갇힌 벌레처럼 영원히 무기력하게 갇히게 됩니다.</p>
<p>이것은 이론적인 문제가 아닙니다. 이것은 중요하고 실용적인 문제입니다. 예를 들어, 몇 가지 설정을 하고 연산을 수행한 다음 필요한 해체를 수행하는 매우 일반적인 패턴을 구현하는 이 비동기 함수를 생각해 봅시다. 아래 코드에서 비동기 함수는 잠금을 획득하고, 인자로 받은 함수를 기다린 다음, 해당 연산이 완료되면 잠금을 해제합니다.</p>
<div data-language="jsx"><pre translate="no"><code translate="no"><span>async</span> <span>function</span> <span>protect</span><span>(</span><span>work</span><span>)</span> <span>{</span>
  <span>let</span> lock <span>=</span> <span>await</span> <span>acquireLock</span><span>(</span><span>)</span><span>;</span>
  <span>try</span> <span>{</span>
    <span>await</span> <span>work</span><span>(</span><span>)</span><span>;</span>
  <span>}</span> <span>finally</span> <span>{</span>
    <span>release</span><span>(</span>lock<span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre></div>
<p>하지만 <code translate="no">work()</code> 에서 반환한 Promise가 정착되지 않으면 어떻게 될까요? 정답은 <code translate="no">protect()</code> 함수가 <code translate="no">await</code> 이벤트 지평선을 넘어가서 다시 시작되지 않는다는 것입니다. 그 결과, 시작 시 획득한 잠금이 해제되지 않으므로 잠금이 "유출"되었다고 말합니다.</p>
<blockquote>
<p>리소스 유출은 추적하기 어렵고 시스템에 과중한 작업 부하가 걸리기 전까지 숨어 있는 경우가 많기 때문에 많은 사람들이 소프트웨어에서 가장 교활한 버그 유형으로 간주합니다.</p>
</blockquote>
<p>물론 일반적으로 대부분의 <em>약속은</em> 충분히 오래 방치하면 해결되기 때문에 대부분의 경우 약속이 <em>지켜질</em> 것이라는 행복한 상식을 따릅니다. 하지만 행복한 가정이 대규모로 실현되는 경우는 드뭅니다. 사실, 시간이 오래 걸리는 약속만이 문제가 되는 것이 아니라는 것을 금방 알 수 있습니다.</p>
<p>명령줄 인터페이스 내에서 <code translate="no">protect()</code> 함수를 호출하고 사용자가 CTRL-C를 누르면 프로세스를 종료한다고 가정해 보겠습니다. 작업하는 데 10초가 걸리는데 사용자가 9.5초 후에 CTRL-C를 누르면 <code translate="no">await</code> 이벤트 지평선 너머에서 제어권이 돌아오지 않고 잠금이 다시 한 번 유출됩니다.</p>
<p>여기서 말하는 약속은 절대 지켜지지 않는 약속이 아닙니다. 곧바로 해결될 수 있는 약속이었지만 500밀리초의 차이만 있었을 뿐 누출이 발생했습니다.</p>
<h2 id="is-explicit-resource-management-a-solution"><a href="#is-explicit-resource-management-a-solution" aria-label="is explicit resource management a solution permalink"></a>명시적 리소스 관리가 해결책일까요?</h2>
<p>한마디로 '아니요'입니다.</p>
<p>이 글을 쓰는 현재 3단계 TC39 제안인<a href="https://github.com/tc39/proposal-explicit-resource-management" target="_blank" rel="nofollow noopener noreferrer">명시적 리소스 관리를</a> 사용하면 설정 및 해체 코드를 함께 번들링할 수 있습니다. 이를 통해 <code translate="no">try/catch</code> 블록의 세레모니를 거치지 않아도 되며, 실수로 리소스를 유출하는 것이 훨씬 더 어려워집니다. 가상의 잠금 메커니즘에 이 기능이 내장되어 있다면 <code translate="no">protect()</code> 함수를 훨씬 더 명확하게 작성할 수 있을 것입니다.</p>
<div data-language="jsx"><pre translate="no"><code translate="no"><span>export</span> <span>async</span> <span>function</span> <span>protect</span><span>(</span><span>work</span><span>)</span> <span>{</span>
  using lock <span>=</span> <span>await</span> <span>acquireLock</span><span>(</span><span>)</span><span>;</span>
  <span>await</span> <span>work</span><span>(</span><span>)</span><span>;</span>
<span>}</span></code></pre></div>
<p><code translate="no">protect()</code> 이 완료되고 <code translate="no">lock</code> 이 범위를 벗어나면 미리 번들로 제공되는 할당 해제 로직에 따라 자동으로 해제됩니다.</p>
<p>이는 편리한 개선이지만 <code translate="no">await</code> 이벤트 지평선의 근본적인 물리학을 바꾸지는 못합니다. 일단 흐름 제어가 이 지점을 통과하면 <code translate="no">work()</code> 가 안정화될 때까지는 다시 돌아올 수 없습니다. 이 시간이 너무 오래 걸리면 <code translate="no">protect()</code> 역시 너무 오래 걸리게 되고, 그 결과 <code translate="no">lock</code> 리소스의 자동 소멸이 트리거되지 않습니다. 즉, 유출되는 것입니다.</p>
<h2 id="does-abortsignal-help"><a href="#does-abortsignal-help" aria-label="does abortsignal help permalink"></a>AbortSignal이 도움이 되나요?</h2>
<p>이론적으로는 그렇지만 실제로는 그렇지 않습니다. 중단 신호는 규율에 따라 적용하면 문제를 어느 정도 개선할 수 있지만 문제를 해결할 수는 없습니다.  이 문제는 <code translate="no">AbortSignal</code> 을 전달했을 때 약속을 '취소'하는 합의된 방법이 없다는 현실에서 시작됩니다. 사실 이 문제는 <a href="https://github.com/tc39/proposal-cancelable-promises/issues/70" target="_blank" rel="nofollow noopener noreferrer">거의 10년 전에</a> T39가 두 <a href="https://github.com/tc39/proposal-cancelable-promises/issues/70" target="_blank" rel="nofollow noopener noreferrer">손을</a> 들게 만든 매우 까다로운 문제이며, 만약 당신이 그 답을 알고 있다고 생각한다면 <a href="https://news.ycombinator.com/item?id=13214487" target="_blank" rel="nofollow noopener noreferrer">충분히 오래 생각하지</a> 않았을 가능성이 높습니다. 하지만 꼭 해야 한다면, 모든 약속을 <code translate="no">safe()</code> 함수로 감싸서 <code translate="no">await</code> 이벤트 지평선으로부터 우리를 보호하는 장벽 역할을 하는 것도 한 가지 방법입니다.</p>
<div data-language="tsx"><pre translate="no"><code translate="no"><span>export</span> <span>function</span> <span>safe</span><span>(</span>promise<span>,</span> signal<span>)</span> <span>{</span>
  <span>return</span> <span>Promise</span><span>.</span><span>race</span><span>(</span><span>[</span>
    promise<span>,</span>
    <span>new</span> <span><span>Promise</span></span><span>(</span><span>(</span>_<span>,</span>reject<span>)</span> <span>=&gt;</span> signal<span>.</span><span>addEventListener</span><span>(</span><span>"abort"</span><span>,</span> reject<span>)</span><span>)</span><span>,</span>
  <span>]</span><span>)</span>
<span>}</span></code></pre></div>
<p><code translate="no">promise</code> 이 안정화되기 전에 <code translate="no">signal</code> 이 실행되면 안전 함수가 즉시 거부하고 오류를 발생시켜 호출자에게 제어권을 반환합니다. 이 메커니즘을 사용하면 <code translate="no">protect()</code> 함수를 다시 작성하여 전체 계산에 걸쳐 중단 신호를 스레드할 수 있습니다.</p>
<div data-language="jsx"><pre translate="no"><code translate="no"><span>export</span> <span>async</span> <span>function</span> <span>protect</span><span>(</span><span>work<span>,</span> signal</span><span>)</span> <span>{</span>
  <span>let</span> lock <span>=</span> <span>await</span> <span>safe</span><span>(</span><span>acquireLock</span><span>(</span><span>)</span><span>,</span> signal<span>)</span><span>;</span>

  <span>try</span> <span>{</span>
    <span>await</span> <span>safe</span><span>(</span><span>work</span><span>(</span>signal<span>)</span><span>,</span> signal<span>)</span><span>;</span>
  <span>}</span> <span>finally</span> <span>{</span>
    <span>release</span><span>(</span>lock<span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre></div>
<p>이제 이 함수는 <code translate="no">safe()</code> 을 사용하여 모든 <code translate="no">await</code> 표현식을 보호 원으로 감싸서 실행이 이벤트 지평선 너머로 갇히는 것을 방지합니다. 또한 <code translate="no">signal</code> 을 <code translate="no">work()</code> 으로 전달하여 이 함수와 이 함수가 호출하는 모든 함수가 동일한 작업을 수행할 수 있도록 합니다. 이제 <code translate="no">signal</code> 이 실행되면 <code translate="no">work()</code> 이 멈춰 있더라도 <code translate="no">protect()</code> 함수가 종료되고 잠금이 해제됩니다. 그러나 이 접근 방식에는 여전히 심각하고 피할 수 없는 경고가 있습니다. 중단 신호는 제약이 아니라 희망사항이라는 것입니다.</p>
<p>추가 중단 신호는 사용과 전달이 번거롭다는 것만이 아닙니다. 맞습니다. <code translate="no">work()</code> 또는 <em>이</em> 함수가 호출하는 함수 중 하나라도 <code translate="no">signal</code> 및 <code translate="no">safe</code>()를 사용하지 못하면 호출 트리에 비동기 함수가 <code translate="no">await</code> 이벤트 지평선 너머에 갇혀 결과적으로 리소스가 누수되는 것과 같은 상황이 다시 발생합니다.</p>
<p>추상화의 힘, 즉 <code translate="no">work()</code> 을 블랙박스라고 생각하고 내부적으로 <code translate="no">work()</code> 을 어떻게 구성하든 가장 필요할 때 호출자에게 제어권을 돌려줄 수 있다는 확신을 가질 수 있는 자유가 근본적으로 결여된 것입니다. 중단 신호를 사용하면 이를 달성할 수 있는 유일한 방법은 소스 코드와 모든 전이 종속성의 소스 코드를 읽어 중단 신호 규율을 준수하는지 확인하는 것입니다. 실제로는 아무도 그렇게 하지 않으며, 중단 신호를 실제로 통합하는 라이브러리가 드물다는 것은 아무도 그렇게 하지 않는다는 것을 보여줍니다. 규율의 적용을 통해 장애물을 피할 수는 있지만 완전히 사라지게 할 수는 없습니다. 제어권이 <code translate="no">await</code> 이벤트 지평선을 통과하면 다시 되돌릴 수 없다는 사실은 변함이 없습니다.</p>
<h2 id="structured-concurrency-and-the-await-event-horizon"><a href="#structured-concurrency-and-the-await-event-horizon" aria-label="structured concurrency and the await event horizon permalink"></a>구조화된 동시성과 대기 이벤트 지평선</h2>
<p>이 문제를 해결할 수 있는 방법은 여러 가지가 있지만, 대부분 중단 신호를 약간 변형하는 것입니다. 그러나 <code translate="no">await</code> 이벤트 호라이즌은 그 메커니즘이 런타임의 핵심에 내장되어 있기 때문에 공리적으로 남아 있습니다. 이를 안정적으로 뚫을 수 있는 방법은 없습니다.</p>
<p>그 결과 주어진 <code translate="no">async</code> 함수의 <em>최소</em> 수명은 <em>내부에</em> 있는 약속의 수명에 의해서만 결정됩니다. 다시 말해, <code translate="no">async</code> 함수의 자연 수명은 내부에서 외부로 결정됩니다.</p>
<p><code translate="no">protect()</code> 는 <code translate="no">work()</code> 가 안정될 때까지 계속될 수 없습니다... 그것이 언제가 되었든 간에. 따라서 <code translate="no">protect()</code> 이 계속될 수 있는 시기를 결정하는 것은 <code translate="no">work()</code> 이고, 주요 함수의 자연 수명을 결정하는 것은 <code translate="no">protect()</code> 입니다. 프로세스의 출구를 초과하는 모든 것은 유출될 수 있는 "위험 영역"에 있습니다. 여기에는 가상의 잠금이 포함됩니다.</p>
<figure><img src="https://frontside.com/img/2023-12-11-await-event-horizon/leak-zone.png"><figcaption>필요 이상으로 오래 실행되는 모든 코드는 유출될 위험이 있습니다.</figcaption></figure>
<p>사실 이것은 구조적 동시성 시스템에서 요구하는 것과는 정반대입니다. 즉, 함수의 <em>최대</em> 수명은 함수를 호출하는 함수의 수명에 의해 제한된다는 것입니다. 구조적 동시성 시스템은 계산 결과에 영향을 주지 않는 비동기 연산이 완료될 때까지 기다리는 대신, 해당 함수가 더 이상 필요하지 않게 되는 순간 즉시 해당 함수에서 반환합니다. 명령줄 인터페이스의 예시에서는 사용자가 ctrl-c를 누르자마자 다른 모든 작업은 즉시 무의미해집니다.</p>
<p>이 경우 원하는 것은 <code translate="no">protect()</code> 함수로 제어권을 강제로 <em>되돌려</em> <code translate="no">finally</code> 블록을 실행하여 잠금이 누출되지 않고 프로세스가 정상적으로 종료되도록 하는 것입니다.</p>
<figure><img src="https://frontside.com/img/2023-12-11-await-event-horizon/graceful-shutdown.png"><figcaption>제대로 동작하는 오퍼레이션은 항상 반환됩니다.</figcaption></figure>
<p>그러나 이러한 관련 없는 함수의 종료를 강제하기 위해서는 위에서 아래로 제어권 반환을 강제할 수 있는 메커니즘이 있어야 합니다. 하지만 <code translate="no">async</code> 함수에서 제어권이 <code translate="no">await</code> 이벤트 호라이즌을 통과하면 다시 되돌릴 수 없다는 것을 방금 살펴보았습니다. 이러한 이유로 <code translate="no">async</code> 함수를 기반으로 하는 프리미티브는 구조적 동시성을 기대할 수는 있지만 결코 보장할 수는 없습니다.</p>
<h2 id="structured-concurrency-and-javascript"><a href="#structured-concurrency-and-javascript" aria-label="structured concurrency and javascript permalink"></a>구조적 동시성과 자바스크립트</h2>
<p>이쯤 되면 자바스크립트에서 구조적 동시성은 <code translate="no">async</code> 함수로 달성할 수 없기 때문에 쓸모없는 것이라고 생각할 수도 있습니다. 전혀 그렇지 않습니다! 구조적 동시성은 가능할 뿐만 아니라 오늘날 이미 <a href="https://frontside.com/effection" target="_blank" rel="nofollow noopener noreferrer">Effect</a>, <a href="http://effects.js.org/" target="_blank" rel="nofollow noopener noreferrer">Effect-TS</a>, <a href="https://github.com/neurosnap/starfx" target="_blank" rel="nofollow noopener noreferrer">StarFX와</a> 같은 프로젝트에서 구조적 동시성을 찾아볼 수 있습니다(몇 가지 예를 들자면). 이러한 라이브러리는 다양한 형태와 크기로 제공되지만 한 가지 공통점은 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="nofollow noopener noreferrer">제너레이터 함수를</a> 핵심 기술로 채택하고 있다는 점입니다.</p>
<p>이는 자바스크립트의 제너레이터 함수가 <code translate="no">await</code> 이벤트 지평에 의해 제한되지 않기 때문입니다. 제너레이터 함수는 본격적인 구분된 <a href="https://en.wikipedia.org/wiki/Delimited_continuation" target="_blank" rel="nofollow noopener noreferrer">연속을</a> 나타내며, 이는 가장 강력한(가장 강력한 것은 아니지만) 흐름 제어 프리미티브 중 하나입니다. 구분된 연속이 무엇인지 자세히 설명하지 않더라도 <code translate="no">while</code> 루프부터 <code translate="no">try/catch</code> 블록, 대수 효과 핸들러에 이르기까지 구현하려는 다른 <em>모든</em> 제어 메커니즘을 표현하는 데 사용할 수 있다고 말하면 충분합니다. 사실 본질적으로 <code translate="no">async</code> 함수 자체는 프로미스 처리라는 특정 영역에 국한된 제너레이터 함수의 축소 버전에 불과합니다.</p>
<p>이 사용 사례에서 중요한 점은 제너레이터 함수를 사용하면 명시적인 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return" target="_blank" rel="nofollow noopener noreferrer"><code translate="no">return()</code></a> 를 사용하여 현재 실행 중인 위치에서 <em>즉시</em> 종료하도록 신호를 보냅니다. 하지만 그렇게 하더라도 <code translate="no">finally {}</code> 블록이나 명시적 리소스 메서드와 같은 중요한 코드 경로를 따라가게 됩니다.</p>
<p>먼 미래의 언젠가 <code translate="no">async</code> 함수가 프로그래머에게 <code translate="no">await</code> 이벤트 지평선을 벗어날 수 있는 메커니즘을 제공하겠지만, 그때까지는 <code translate="no">async/await</code> 기반의 구조화된 동시성 모델은 공상 과학 소설에 불과할 것입니다.</p></div></div>
      </article>
    </body>
  </html>
  