
  <html lang="ko">
    <head>
      <meta charset="utf-8">
      <title>Thinking in StyleX | StyleX</title>
      <link rel="canonical" href="https://stylexjs.com/docs/learn/thinking-in-stylex/">
      <style>
        pre {
          padding: 1rem;
          background-color: #263238;
          color: #fff
        }
      </style>
    </head>
    <body>
      <article>
        <div id="readability-page-1" class="page"><div><h2 id="core-principles">핵심 <a href="#core-principles" aria-label="Direct link to Core Principles" title="Direct link to Core Principles">원칙</a></h2><p>StyleX의 존재 이유와 그 결정의 근거를 이해하려면 이를 안내하는 기본 원칙을 숙지하는 것이 도움이 될 수 있습니다. 이를 통해 StyleX가 자신에게 적합한 솔루션인지 판단하는 데 도움이 될 수 있습니다.</p><p>이러한 원칙은 StyleX를 위한 새로운 API를 설계할 때에도 도움이 될 것입니다.</p><h3 id="co-location"><a href="#co-location" aria-label="Direct link to Co-location" title="Direct link to Co-location">코로케이션</a></h3><p>드라이 코드의 이점이 있긴 하지만 스타일 작성에 있어서는 일반적으로 그렇지 않다고 생각합니다. 스타일을 작성하는 가장 좋고 가독성이 좋은 방법은 마크업과 동일한 파일에 작성하는 것입니다.</p><p>StyleX는 스타일을 로컬에서 작성, 적용 및 추론할 수 있도록 설계되었습니다.</p><h3 id="deterministic-resolution">결정론적<a href="#deterministic-resolution" aria-label="Direct link to Deterministic resolution" title="Direct link to Deterministic resolution">해상도</a></h3><p>CSS는 강력하고 표현력이 풍부한 언어입니다. 하지만 때때로 취약하게 느껴질 수 있습니다. 이 중 일부는 CSS 작동 방식에 대한 오해에서 비롯된 것이지만, 대부분은 서로 다른 특성을 가진 CSS 선택자가 충돌하지 않도록 하는 데 필요한 규율과 조직에서 비롯된 것입니다.</p><p>이 문제에 대한 대부분의 기존 솔루션은 규칙과 규칙에 의존합니다.</p><details><summary>BEM 및 OOCSS 규칙BEM</summary>및 OOCSS는 이러한 문제를 방지하기 위해 명명 규칙을 도입하여 개발자가 규칙을 일관되게 따르도록 하고, 스타일을 병합하지 않는 경우가 많습니다. 이로 인해 CSS가 비대해질 수 있습니다.</details><details><summary>유틸리티 클래스테일윈드</summary>CSS 및 타키온과 같은<summary>원자적인</summary>유틸리티 클래스 이름은 동일한 요소에 충돌하는 클래스 이름이 적용되지 않도록 하기 위해 규칙과 린트 규칙에 의존합니다. 이러한 툴링은 스타일을 적용할 수 있는 위치와 방법에 제약을 가하여 스타일링에 아키텍처적 제한을 가합니다.</details><p>StyleX는 스타일의 일관성과 예측 가능성<em>,</em> 표현력을 모두 개선하는 것을 목표로 합니다. 이는 빌드 툴을 통해 가능하다고 생각합니다.</p><p>스타일엑스는 파일 전반에서 작동하는 완전히 예측 가능하고 결정론적인 스타일링 시스템을 제공합니다. 여러 선택기를 병합할 때뿐만 아니라 여러 속기 및 장문 속성을 병합할 때에도 결정론적인 결과를 생성합니다. (예: <code translate="no">margin</code> 대 <code translate="no">margin-top</code>).</p><blockquote><p>"마지막으로 적용된 스타일이 항상 승리합니다."</p></blockquote><h3 id="low-cost-abstractions">저비용 <a href="#low-cost-abstractions" aria-label="Direct link to Low-cost abstractions" title="Direct link to Low-cost abstractions">추상화</a></h3><p>스타일엑스의 성능 비용과 관련해서는 스타일엑스가 특정 패턴을 구현하는 가장 빠른 방법이어야 한다는 것이 저희의 기본 원칙입니다. 일반적인 패턴은 런타임 비용이 없어야 하고, 고급 패턴은 가능한 한 빨라야 합니다. 따라서 런타임 성능을 개선하기 위해 빌드 시 더 많은 작업을 수행하는 것을 감수합니다.</p><p>실제로는 다음과 같이 진행됩니다:</p><h4 id="1-styles-created-and-applied-locally">1. <a href="#1-styles-created-and-applied-locally" aria-label="Direct link to 1. Styles created and applied locally" title="Direct link to 1. Styles created and applied locally">로컬에서</a> 생성 및 적용되는 스타일</h4><p>동일한 파일 내에서 스타일을 작성하고 사용할 때 StyleX의 비용은 0입니다. 이는 StyleX가 <code translate="no">stylex.create</code> 호출을 컴파일하는 것 외에도 가능한 경우 <code translate="no">stylex.props</code> 호출도 컴파일하기 때문입니다.</p><p>그래서</p><div><pre translate="no" tabindex="0"><code translate="no"><span><span>import</span><span> </span><span>*</span><span> </span><span>as</span><span> stylex</span><span> </span><span>from</span><span> </span><span>'stylex'</span><span>;</span><span></span><br></span><span><span></span><span>const</span><span> styles </span><span>=</span><span> stylex</span><span>.</span><span>create</span><span>(</span><span>{</span><span></span><br></span><span><span>  red</span><span>:</span><span> </span><span>{</span><span>color</span><span>:</span><span> </span><span>'red'</span><span>}</span><span>,</span><span></span><br></span><span><span></span><span>}</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>let</span><span> a </span><span>=</span><span> stylex</span><span>.</span><span>props</span><span>(</span><span>styles</span><span>.</span><span>red</span><span>)</span><span>;</span><br></span></code></pre></div><p>아래로 컴파일됩니다:</p><div><ul role="tablist" aria-orientation="horizontal"><li role="tab" tabindex="0" aria-selected="true">JS 출력</li><li role="tab" tabindex="-1" aria-selected="false">CSS 출력</li></ul><div role="tabpanel"><pre translate="no" tabindex="0"><code translate="no"><span><span>import</span><span> </span><span>*</span><span> </span><span>as</span><span> stylex</span><span> </span><span>from</span><span> </span><span>'stylex'</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>let</span><span> a </span><span>=</span><span> </span><span>{</span><span>className</span><span>:</span><span> </span><span>'x1e2nbdu'</span><span>}</span><span>;</span><br></span></code></pre></div></div><p>여기에는 런타임 오버헤드가 없습니다.</p><h4 id="2-using-styles-across-files">2.<a href="#2-using-styles-across-files" aria-label="Direct link to 2. Using styles across files" title="Direct link to 2. Using styles across files">파일</a> 간 스타일 사용</h4><p>파일 경계를 넘어 스타일을 전달하면 추가적인 성능과 표현력을 위해 약간의 비용이 발생합니다. <code translate="no">stylex.create</code> 호출은 완전히 삭제되지 않고 대신 클래스 이름에 키를 매핑하는 객체를 남깁니다. 그리고 <code translate="no">stylex.props()</code> 호출은 런타임에 실행됩니다.</p><p>이 코드를 예로 들어보겠습니다:</p><div><pre translate="no" tabindex="0"><code translate="no"><span><span>import</span><span> </span><span>*</span><span> </span><span>as</span><span> stylex</span><span> </span><span>from</span><span> </span><span>'@stylexjs/stylex'</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>const</span><span> styles </span><span>=</span><span> stylex</span><span>.</span><span>create</span><span>(</span><span>{</span><span></span><br></span><span><span>  foo</span><span>:</span><span> </span><span>{</span><span></span><br></span><span><span>    color</span><span>:</span><span> </span><span>'red'</span><span>,</span><span></span><br></span><span><span>  </span><span>}</span><span>,</span><span></span><br></span><span><span>  bar</span><span>:</span><span> </span><span>{</span><span></span><br></span><span><span>    backgroundColor</span><span>:</span><span> </span><span>'blue'</span><span>,</span><span></span><br></span><span><span>  </span><span>}</span><span>,</span><span></span><br></span><span><span></span><span>}</span><span>)</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>function</span><span> </span><span>MyComponent</span><span>(</span><span>{</span><span>style</span><span>}</span><span>)</span><span> </span><span>{</span><span></span><br></span><span><span>  </span><span>return</span><span> </span><span>&lt;</span><span>div</span><span> </span><span>{</span><span>...</span><span>stylex</span><span>.</span><span>props</span><span>(</span><span>styles</span><span>.</span><span>foo</span><span>,</span><span> styles</span><span>.</span><span>bar</span><span>,</span><span> style</span><span>)</span><span>}</span><span> </span><span>/&gt;</span><span>;</span><span></span><br></span><span><span></span><span>}</span><br></span></code></pre></div><p>로 컴파일됩니다:</p><div><pre translate="no" tabindex="0"><code translate="no"><span><span>import</span><span> </span><span>*</span><span> </span><span>as</span><span> stylex</span><span> </span><span>from</span><span> </span><span>'@stylexjs/stylex'</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>const</span><span> styles </span><span>=</span><span> </span><span>{</span><span></span><br></span><span><span>  foo</span><span>:</span><span> </span><span>{</span><span></span><br></span><span><span>    color</span><span>:</span><span> </span><span>'x1e2nbdu'</span><span>,</span><span></span><br></span><span><span>    $$css</span><span>:</span><span> </span><span>true</span><span>,</span><span></span><br></span><span><span>  </span><span>}</span><span>,</span><span></span><br></span><span><span>  bar</span><span>:</span><span> </span><span>{</span><span></span><br></span><span><span>    backgroundColor</span><span>:</span><span> </span><span>'x1t391ir'</span><span>,</span><span></span><br></span><span><span>    $$css</span><span>:</span><span> </span><span>true</span><span>,</span><span></span><br></span><span><span>  </span><span>}</span><span>,</span><span></span><br></span><span><span></span><span>}</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>function</span><span> </span><span>MyComponent</span><span>(</span><span>{</span><span>style</span><span>}</span><span>)</span><span> </span><span>{</span><span></span><br></span><span><span>  </span><span>return</span><span> </span><span>&lt;</span><span>div</span><span> </span><span>{</span><span>...</span><span>stylex</span><span>.</span><span>props</span><span>(</span><span>styles</span><span>.</span><span>foo</span><span>,</span><span> styles</span><span>.</span><span>bar</span><span>,</span><span> style</span><span>)</span><span>}</span><span> </span><span>/&gt;</span><span>;</span><span></span><br></span><span><span></span><span>}</span><br></span></code></pre></div><p>코드가 조금 더 많지만 <code translate="no">stylex.props()</code> 함수가 매우 빠르기 때문에 런타임 비용은 여전히 최소화됩니다.</p><p>대부분의 다른 스타일링 솔루션은 파일 경계를 넘어 스타일을 구성할 수 없습니다. 최신 기술은 클래스 이름 목록을 결합하는 것입니다.</p><h3 id="small-api-surface">작은 API<a href="#small-api-surface" aria-label="Direct link to Small API surface" title="Direct link to Small API surface">표면</a></h3><p>우리의 목표는 StyleX를 가능한 한 최소화하고 배우기 쉽게 만드는 것입니다. 따라서 너무 많은 API를 개발하지 않으려 합니다. 대신 가능한 한 일반적인 자바스크립트 패턴에 의존하고 가능한 한 가장 작은 API 표면을 제공하고자 합니다.</p><p>StyleX의 핵심은 두 가지 함수로 요약할 수 있습니다:</p><ol><li><code translate="no">stylex.create</code></li><li><code translate="no">stylex.props</code></li></ol><p><code translate="no">stylex.create</code> 는 스타일을 생성하는 데 사용되며 <code translate="no">stylex.props</code> 는 해당 스타일을 요소에 적용하는 데 사용됩니다.</p><p>이 두 함수 내에서 우리는 StyleX를 위한 고유한 API나 패턴을 도입하기보다는 일반적인 JS 패턴을 사용하기로 결정했습니다. 예를 들어 조건부 스타일을 위한 API는 없습니다. 대신 부울 또는 삼항식 표현식을 사용하여 조건부로 스타일을 적용하는 것을 지원합니다.</p><p>JavaScript 객체와 배열을 다룰 때 예상대로 작동해야 하며, 예상치 못한 일이 발생하지 않아야 합니다.</p><h3 id="type-safe-styles">유형 안전<a href="#type-safe-styles" aria-label="Direct link to Type-Safe styles" title="Direct link to Type-Safe styles">스타일</a></h3><p>타입스크립트가 제공하는 경험과 안전성으로 인해 큰 인기를 얻고 있습니다. 그러나 스타일은 대부분 유형화되지 않았고 신뢰할 수 없는 상태로 남아있었습니다.<a href="https://vanilla-extract.style/" target="_blank" rel="noopener noreferrer">바닐라 익스트랙트와</a> 같은 일부 획기적인 프로젝트를 제외하고는 대부분의 스타일 솔루션에서 스타일은 문자열의 집합에 불과합니다.</p><p>StyleX는 강력한 정적 유형으로 Flow에서 작성되었습니다. NPM의 패키지는 Flow와 TypeScript 모두에 대해 자동 생성된 유형과 함께 제공됩니다. 두 유형 시스템 간에 비호환성이 있는 경우, 당사는 시간을 들여 원래의 Flow와 동일한 수준의 성능과 안전성을 달성하기 위해 사용자 정의 TypeScript 유형을 작성합니다.</p><p><em>모든 스타일은 타이핑됩니다</em>. 스타일을 프롭으로 허용할 때 유형을 사용하여 허용되는 스타일을 제한할 수 있습니다. 스타일은 다른 컴포넌트 프롭과 마찬가지로 유형 안전해야 합니다.</p><p>StyleX API는 강력하게 유형화되어 있습니다. StyleX로 정의된 스타일도 유형이 지정됩니다. 이는 JavaScript 객체를 사용하여 원시 스타일을 작성하기 때문에 가능합니다. 이것이 바로 우리가 템플릿 문자열 대신 객체를 선택한 큰 이유 중 하나입니다.</p><p>그런 다음 이러한 유형을 활용하여 컴포넌트가 허용할 스타일에 대한 컨트랙트를 설정할 수 있습니다. 예를 들어, 컴포넌트 소품은<code translate="no">color</code> 및 <code translate="no">backgroundColor</code> 스타일만 허용하고 다른 스타일은 허용하지 않도록 정의할 수 있습니다.</p><div><pre translate="no" tabindex="0"><code translate="no"><span><span>import</span><span> </span><span>type</span><span> </span><span>{</span><span>StyleXStyles</span><span>}</span><span> </span><span>from</span><span> </span><span>'@stylexjs/stylex'</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>type</span><span> </span><span>Props</span><span> </span><span>=</span><span> </span><span>{</span><span></span><br></span><span><span>  </span><span>//...</span><span></span><br></span><span><span>  style</span><span>?</span><span>:</span><span> StyleXStyles</span><span>&lt;</span><span>{</span><span>color</span><span>?</span><span>:</span><span> </span><span>string</span><span>;</span><span> backgroundColor</span><span>?</span><span>:</span><span> </span><span>string</span><span>}</span><span>&gt;</span><span>;</span><span></span><br></span><span><span>  </span><span>//...</span><span></span><br></span><span><span></span><span>}</span><span>;</span><br></span></code></pre></div><p>또 다른 예로, 다른 모든 스타일은 허용하면서 여백은 허용하지 않는 프로퍼티를 정의할 수도 있습니다.</p><div><pre translate="no" tabindex="0"><code translate="no"><span><span>import</span><span> </span><span>type</span><span> </span><span>{</span><span>StyleXStylesWithout</span><span>}</span><span> </span><span>from</span><span> </span><span>'@stylexjs/stylex'</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>type</span><span> </span><span>Props</span><span> </span><span>=</span><span> </span><span>{</span><span></span><br></span><span><span>  </span><span>//...</span><span></span><br></span><span><span>  style</span><span>?</span><span>:</span><span> StyleXStylesWithout</span><span>&lt;</span><span>{</span><span></span><br></span><span><span>    margin</span><span>:</span><span> </span><span>unknown</span><span>;</span><span></span><br></span><span><span>    marginBlock</span><span>:</span><span> </span><span>unknown</span><span>;</span><span></span><br></span><span><span>    marginInline</span><span>:</span><span> </span><span>unknown</span><span>;</span><span></span><br></span><span><span>    marginTop</span><span>:</span><span> </span><span>unknown</span><span>;</span><span></span><br></span><span><span>    marginBottom</span><span>:</span><span> </span><span>unknown</span><span>;</span><span></span><br></span><span><span>    marginLeft</span><span>:</span><span> </span><span>unknown</span><span>;</span><span></span><br></span><span><span>    marginRight</span><span>:</span><span> </span><span>unknown</span><span>;</span><span></span><br></span><span><span>    marginBlockStart</span><span>:</span><span> </span><span>unknown</span><span>;</span><span></span><br></span><span><span>    marginBlockEnd</span><span>:</span><span> </span><span>unknown</span><span>;</span><span></span><br></span><span><span>    marginInlineStart</span><span>:</span><span> </span><span>unknown</span><span>;</span><span></span><br></span><span><span>    marginInlineEnd</span><span>:</span><span> </span><span>unknown</span><span>;</span><span></span><br></span><span><span>  </span><span>}</span><span>&gt;</span><span>;</span><span></span><br></span><span><span>  </span><span>//...</span><span></span><br></span><span><span></span><span>}</span><span>;</span><br></span></code></pre></div><p>스타일을 입력하면 <strong>런타임 비용</strong> 없이 컴포넌트의 스타일을 사용자 정의하는 방법에 대한 매우 정교한 규칙을 만들 수 있습니다.</p><h3 id="shareable-constants">공유 가능한 <a href="#shareable-constants" aria-label="Direct link to Shareable constants" title="Direct link to Shareable constants">상수</a></h3><p>CSS 클래스 이름, CSS 변수 및 기타 CSS 식별자는 전역 네임스페이스에 정의됩니다. CSS 문자열을 자바스크립트로 가져오는 것은 타입 안전성과 컴포저블성을 잃는다는 것을 의미할 수 있습니다.</p><p>당사는 스타일이 유형 안전성을 유지하기를 원하기 때문에 이러한 문자열을 자바스크립트 상수에 대한 참조로 대체하는 API를 개발하는 데 많은 시간을 투자해 왔습니다. 그 결과 다음 API에 반영되었습니다:</p><ol><li><code translate="no">stylex.create</code> 생성된 클래스 이름을 완전히 추상화합니다. "불투명한" JavaScript 객체를 강력한 타입으로 처리하여 객체가 나타내는 스타일을 표시합니다.</li><li><code translate="no">stylex.defineVars</code> 생성된 CSS 변수의 이름을 추상화하여 상수로 가져와 스타일 내에서 바로 사용할 수 있습니다.</li><li><code translate="no">stylex.keyframes</code> 키프레임 애니메이션의 이름을 추상화합니다. 대신 상수로 선언하고 참조로 사용합니다.</li></ol><p><code translate="no">container-name</code> 및 <code translate="no">@font-face</code> 같은 다른 CSS 식별자도 유형 안전성을 확보할 수 있는 방법을 연구 중입니다.</p><h3 id="framework-agnostic"><a href="#framework-agnostic" aria-label="Direct link to Framework-agnostic" title="Direct link to Framework-agnostic">프레임워크에</a> 구애받지 않는</h3><p>StyleX는 CSS-in-React 솔루션이 아닌 CSS-in-JS 솔루션입니다. 스타일엑스는 현재 React와 가장 잘 작동하도록 조정되었지만, 자바스크립트로 마크업을 작성할 수 있는 모든 자바스크립트 프레임워크와 함께 사용할 수 있도록 설계되었습니다. 여기에는 JSX, 템플릿 문자열 등을 사용하는 프레임워크가 포함됩니다.</p><p><code translate="no">stylex.props</code> <code translate="no">className</code> 및 <code translate="no">style</code> 속성을 가진 객체를 반환합니다. 이를 다양한 프레임워크에서 작동하도록 변환하려면 래퍼 함수가 필요할 수 있습니다.</p><h3 id="encapsulation"><a href="#encapsulation" aria-label="Direct link to Encapsulation" title="Direct link to Encapsulation">캡슐화</a></h3><blockquote><p>요소의 모든 스타일은 해당 요소 자체의 클래스 이름에 의해 발생해야 합니다.</p></blockquote><p>CSS를 사용하면 "원거리 스타일"을 유발할 수 있는 방식으로 스타일을 매우 쉽게 작성할 수 있습니다:</p><ul><li><code translate="no">.className &gt; *</code></li><li><code translate="no">.className ~ *</code></li><li><code translate="no">.className:hover &gt; div:first-child</code></li></ul><p>이러한 모든 패턴은 강력하지만 스타일을 취약하고 예측하기 어렵게 만듭니다. 한 요소에 클래스명을 적용하면 완전히 다른 요소에 영향을 미칠 수 있습니다.</p><p><code translate="no">color</code> 같은 상속 가능한 스타일은 여전히 상속되지만, 이는 StyleX가 허용하는<em>유일한</em> 형태의 원거리 스타일입니다. 이러한 경우에도 요소에 직접 적용된 스타일은 항상 상속된 스타일보다 우선합니다.</p><p>복합 선택기를 사용할 때는 그렇지 않은 경우가 많은데, 복합 선택기는 일반적으로 요소에 직접 적용되는 스타일에 사용되는 단순 클래스 선택기보다 특이성이 더 높기 때문입니다.</p><p>StyleX는 이 전체 선택기 클래스를 허용하지 않습니다. 이로 인해 현재 특정 CSS 패턴은 StyleX로 구현할 수 없습니다. 우리의 목표는 스타일 캡슐화를 희생하지 않고 이러한 패턴을 지원하는 것입니다.</p><p>StyleX는 CSS 전처리기가 아닙니다. 빠르고 예측 가능한 시스템을 구축하기 위해 의도적으로 CSS 선택기의 성능에 제약을 가하는 것입니다. 템플릿 문자열 대신 JavaScript 객체를 기반으로 하는 API는 이러한 제약이 자연스럽게 느껴지도록 설계되었습니다.</p><h3 id="readability--maintainability-over-terseness"><a href="#readability--maintainability-over-terseness" aria-label="Direct link to Readability &amp; maintainability over terseness" title="Direct link to Readability &amp; maintainability over terseness">간결함을</a> 뛰어넘는 가독성 및 유지보수성</h3><p>최근의 일부 유틸리티 기반 스타일링 솔루션은 매우 간결하고 작성하기 쉽습니다. StyleX는 간결함보다 가독성과 유지보수성을 우선시합니다.</p><p>StyleX는 가독성과 얕은 학습 곡선을 우선시하기 위해 익숙한 CSS 속성 이름을 사용하기로 결정했습니다. <em>(편의를 위해 케밥 케이스 대신 낙타 케이스를 사용하기로 결정했습니다.)</em></p><p>또한 스타일이 사용되는 HTML 요소와 분리된 객체에서 스타일을 작성하도록 하고 있습니다. HTML 마크업의 가독성을 높이고 적절한 이름의 스타일이 그 목적을 나타낼 수 있도록 하기 위해 이러한 결정을 내렸습니다. 예를 들어 <code translate="no">styles.active</code> 같은 이름을 사용하면 <em>어떤</em> 스타일이 적용되는지 자세히 살펴볼 필요 없이 스타일이 적용되는 <em>이유를</em> 강조할 수 있습니다.</p><p>이 원칙 때문에 스타일을 작성할 때 다른 솔루션보다 StyleX에서 더 많은 타이핑이 필요할 수 있다는 단점이 있습니다.</p><p>하지만 시간이 지남에 따라 가독성이 개선된다면 이러한 비용은 감수할 가치가 있다고 생각합니다. 각 HTML 요소에 의미론적 이름을 부여하면 스타일 자체보다 훨씬 더 많은 것을 전달할 수 있습니다.</p><div><p><span><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>정보</p><div><p>스타일을 인라인으로 사용하는 대신 스타일에 대한 참조를 사용할 때의 한 가지 이점은 <strong>테스트 가능성입니다</strong>. 단위 테스트 환경에서 모든 원자 스타일을 제거하고 실제 스타일이 아닌 스타일의 소스 위치를 나타내는 단일 디버깅 클래스 이름만 출력하도록 StyleX를 구성할 수 있습니다.</p><p>스타일이 변경될 때마다 스냅샷 테스트가 변경되지 않으므로 스냅샷 테스트의 복원력이 향상된다는 장점이 있습니다.</p></div></div><h3 id="modularity-and-composability">모듈성 및 <a href="#modularity-and-composability" aria-label="Direct link to Modularity and composability" title="Direct link to Modularity and composability">컴포저빌리티</a></h3><p>NPM을 사용하면 프로젝트 간에 코드를 매우 쉽게 공유할 수 있습니다. 하지만 CSS 공유는 여전히 어려운 과제였습니다. 타사 컴포넌트에는 사용자 정의가 어렵거나 불가능한 스타일이 기본으로 제공되거나 스타일이 전혀 지정되지 않은 경우가 많았습니다.</p><p>패키지 간에 스타일을 예측 가능하게 병합하고 구성할 수 있는 좋은 시스템이 없다는 점도 패키지 내에서 스타일을 공유할 때 장애물이었습니다.</p><p>StyleX는 NPM의 패키지 내에서 컴포넌트와 함께 스타일을 쉽고 안정적으로 공유할 수 있는 시스템을 만드는 것을 목표로 합니다.</p><h3 id="avoid-global-configuration">전역<a href="#avoid-global-configuration" aria-label="Direct link to Avoid global configuration" title="Direct link to Avoid global configuration">구성</a> 피하기</h3><p>StyleX는 프로젝트 전반에서 유사하게 작동해야 합니다. StyleX의 구문이나 동작을 변경하는 프로젝트별 구성을 생성하는 것은 피해야 합니다. 우리는 단기적인 편의성보다 구성 가능성과 일관성을 우선시하기로 결정했습니다.</p><p>당사는 편의성과 사용자 지정 가능성을 제공하기 위해 툴링에 의존하고 있습니다. 예를 들어, 프로젝트 내에서 특정 CSS 속성을 허용하거나 허용하지 않도록 StyleX ESlint 규칙을 구성할 수 있습니다. 이를 정적 유형과 함께 사용하여 프로젝트에 대한 스타일링 규칙을 만들 수 있습니다.</p><h3 id="one-small-file-over-many-smaller-files">여러 개의 작은<a href="#one-small-file-over-many-smaller-files" aria-label="Direct link to One small file over many smaller files" title="Direct link to One small file over many smaller files">파일</a> 위에 하나의 작은 파일</h3><p>많은 양의 CSS를 다룰 때 지연 로딩 CSS는 페이지의 초기 로드 시간을 단축하는 방법입니다. 하지만 업데이트 시간 또는 <em>다음 페인트에 대한 상호 작용(INP)</em> 메트릭이 느려지는 대가를 치러야 합니다. 페이지에서 CSS를 지연 로드하면 전체 페이지의 스타일이 다시 계산됩니다.</p><p>StyleX는 미리 로드되는 고도로 최적화된 단일 CSS 번들을 생성하는 데 최적화되어 있습니다. 우리의 목표는 CSS의 총량이 충분히 적어서 성능에 눈에 띄는 영향을 주지 않고 모든 CSS를 미리 로드할 수 있는 시스템을 만드는 것입니다.</p><p>'중요 CSS'와 같이 초기 로드 시간을 단축하는 다른 기법도 StyleX와 호환되지만 일반적으로는 불필요합니다.</p></div></div>
      </article>
    </body>
  </html>
  