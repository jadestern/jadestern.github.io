
  <html lang="ko">
    <head>
      <meta charset="utf-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>Outshift | Qwik vs. Next.js: Which framework is right for your next web project?</title>
      <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
      <script src="//unpkg.com/alpinejs" defer></script>
    </head>
    <body x-data="{ dark: false }" x-bind:data-theme="dark ? 'dark' : 'light'">
      <main class="container">
      	<button x-on:click="dark = !dark" class="contrast outline">Switch Theme</button>
	      <article>
	        <div id="readability-page-1" class="page"><div><p>Qwik은 웹 개발 프로젝트에서 Next.js보다 제가 선호하는 프레임워크입니다. 이 글에서는 Qwik과 Next.js의 차이점, 장단점을 살펴보겠습니다. 하지만 저는 Builder.io에서 만든 Qwik이 웹 개발의 미래가 될 잠재력을 가지고 있다고 생각합니다.</p><h2>Qwik이 제가 선택한 프레임워크인 이유</h2><p>개발자 경험, 신호, 제어 수준, 광범위한 React 에코시스템 사용 기능, Qwik 프레임워크의 미래 지향적 기능 등 다양한 이유로 인해 궁극적으로 <a target="_blank" rel="noopener noreferrer" href="https://nextjs.org/">Next.js</a> 대신 <a target="_blank" rel="noopener noreferrer" href="https://qwik.dev/">Qwik을</a> 선택했습니다. Next.js는 경이로운 프레임워크이며 주저 없이 추천하고 싶습니다. 하지만 Qwik은 매우 매력적인 개발자 경험과 참신한 디자인을 제공하기 때문에 코딩을 할 때마다 흥분됩니다!</p><h2>배경: jQuery에서 Qwik 프레임워크까지</h2><p>저는 20년 가까이 풀스택 엔지니어로 소프트웨어 엔지니어링에 종사해 왔습니다. 프론트엔드 여정은 약 15년 전에 시작되었습니다. 일반 JavaScript와 jQuery로 시작해서 KnockoutJS, AngularJS, GWT로 옮겨갔죠. 2013년에 React가 등장했을 때 저는 얼리어답터였고 그 매력에 푹 빠졌습니다. React는 10년 가까이 제 라이브러리 역할을 해왔습니다. 그 과정에서 다른 다양한 프레임워크와 라이브러리도 사용했지만, 올해 Qwik을 발견하기 전까지는 사실상 프론트엔드 라이브러리 역할을 해왔습니다.</p><h2>Qwik이란 무엇인가요?</h2><p>Qwik 문서에서 스스로를 어떻게 정의하는지 살펴봅시다: "Qwik은 재개할 수 있고(열성적인 JS 실행과 수화 없이), 엣지를 위해 구축되었으며, React 개발자에게 친숙한 새로운 종류의 프레임워크입니다." 그렇다면 이는 무엇을 의미할까요? 자세히 살펴봅시다.</p><p>Qwik은 JSX를 활용하므로 React와 비슷하게 느껴지지만, 그 특징 중 하나는 재개 가능성입니다.<a target="_blank" rel="noopener noreferrer" href="https://qwik.dev/docs/concepts/resumable/">"재개성은</a> 모든 애플리케이션 로직을 다시 재생하고 다운로드할 필요 없이 서버에서 실행을 일시 중지하고 클라이언트에서 실행을 재개하는 것입니다." 즉, 렌더링, 일시 중지, 재개, 렌더링, 일시 중지, 재개 등을 의미합니다.</p><p>대부분의 경우 개발자는 복잡성을 추가할 필요 없이 이 모든 과정을 투명하게 처리할 수 있습니다. 이것이 Qwik과 다른 프레임워크의 근본적인 차이점입니다. 예를 들어, React에서는 페이지가 서버에서 렌더링된 다음 클라이언트에서 수화된 다음 필요한 모든 JavaScript가 다운로드되면 페이지가 대화형으로 표시됩니다. 동적 임포트를 사용하는 경우는 예외이지만, 이는 재개 가능성과는 여전히 다릅니다.</p><p>Qwik은 클라이언트/서버 경계가 거의 문제가 되지 않도록 설계되었습니다. 기본적으로, 클라이언트에서만 렌더링을 적용하기 위해 <a target="_blank" rel="noopener noreferrer" href="https://qwik.dev/docs/guides/qwik-nutshell/#isbrowser-conditional">isBrowser와</a> 결합된 <a target="_blank" rel="noopener noreferrer" href="https://qwik.dev/docs/components/tasks/#usevisibletask">useVisibleTask$와</a> 같은 함수를 특별히 사용하지 않는 한 모든 것이 서버에서 렌더링됩니다. 그렇지 않으면 몇 가지 예외를 제외하고 모든 서버 렌더링이 보편적으로 작동합니다.</p><p>하지만 이것은 빙산의 일각에 불과합니다. 다른 프레임워크가 계속 완화해야 하는 문제를 해결하기 위한 정말 독특한 프레임워크인 만큼 아래에 링크된 Qwik 문서의 개념 페이지를 읽어보시기 바랍니다.</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://qwik.dev/docs/concepts/think-qwik/">Qwik 생각하기</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://qwik.dev/docs/concepts/resumable/">재개 가능</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://qwik.dev/docs/concepts/progressive/">프로그레시브</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://qwik.dev/docs/concepts/reactivity/">반응성</a></li></ul><p>Qwik은 출시된 지 몇 년 밖에 되지 않은 아주 새로운 프레임워크입니다. 지금까지 개발자들에게 거의 노출되지 않았습니다. 저는 최근에야 <a target="_blank" rel="noopener noreferrer" href="https://2023.allthingsopen.org/">올씽스 오픈 컨퍼런스에서</a> 이 프레임워크를 알게 되었습니다. Qwik 프레임워크를 처음 접하는 분이라면 시간을 내어 문서를 읽어보세요. 그만한 가치가 있습니다.</p><h2>Next.js란 무엇인가요?</h2><p>Next.js에 대해서는 많은 글이 있으므로 짧고 간결하게 설명하겠습니다. Next.js는 React 라이브러리를 감싸고 있는 중요한 프레임워크입니다. 현재 React에서 가장 많이 사용되는 프레임워크입니다. 문서에서 인용하자면, "Next.js는 풀스택 웹 애플리케이션을 구축하기 위한 React 프레임워크입니다. 사용자 인터페이스를 구축하려면 React 컴포넌트를 사용하고, 추가 기능과 최적화를 위해서는 Next.js를 사용합니다. 내부적으로 Next.js는 번들링, 컴파일 등 React에 필요한 툴링을 추상화하고 자동으로 구성합니다. 따라서 구성에 시간을 소비하는 대신 애플리케이션을 빌드하는 데 집중할 수 있습니다."</p><h2>Qwik과 Next.js 비교하기</h2><p>Qwik과 Next.js를 비교하면서 평가한 7가지 주요 영역이 있습니다. 각각에 대해 가장 중요한 것을 기준으로 각 기능을 평가할 수 있도록 승자의 이름을 지정했습니다.</p><h3>서버 대 클라이언트</h3><p>Next.js는 서버와 클라이언트 컴포넌트를 매우 명확하게 구분하는 반면, Qwik은 대부분의 경우 이러한 구분이 전혀 문제가 되지 않습니다. 모든 것이 기본적으로 서버에서 렌더링되므로 전반적으로 좋은 점이라고 생각합니다.</p><p><strong>승자: </strong>우위는 Qwik에게 돌아갑니다.</p><p>다음은 Next.js <a target="_blank" rel="noopener noreferrer" href="https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns#moving-client-components-down-the-tree">문서의</a> 예시입니다:</p><pre translate="no"><code translate="no">// Next.js code below

// SearchBar is a Client Component
import SearchBar from './searchbar'
// Logo is a Server Component
import Logo from './logo'
 
// Layout is a Server Component by default
export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    &lt;&gt;
      &lt;nav&gt;
        &lt;Logo /&gt;
        &lt;SearchBar /&gt;
      &lt;/nav&gt;
      &lt;main&gt;{children}&lt;/main&gt;
    &lt;/&gt;
  )
}

// ---
'use client'

export default function SearchBar({ children }: { children: React.ReactNode }) {
  return (
    &lt;&gt;
      &lt;main&gt;Search!&lt;/main&gt;
    &lt;/&gt;
  )
}

// ---
'use client'

export default function Logo({ children }: { children: React.ReactNode }) {
  return (
    &lt;&gt;
      &lt;main&gt;Logo!&lt;/main&gt;
    &lt;/&gt;
  )
}</code></pre><p>Qwik에서는 '클라이언트 사용'을 정의할 필요가 없습니다:</p><pre translate="no"><code translate="no">// Qwik code below
import { component$ } from '@builder.io/qwik';

import SearchBar from './searchbar'
import Logo from './logo'
 
export default component$(() =&gt; {
  return (
    &lt;&gt;
      &lt;nav&gt;
        &lt;Logo /&gt;
        &lt;SearchBar /&gt;
      &lt;/nav&gt;
      &lt;slot /&gt;
    &lt;/&gt;
  )
});

// ---
// SearchBar.tsx
export default component$(() =&gt; {
  return (
    &lt;&gt;
      &lt;main&gt;Search!&lt;/main&gt;
    &lt;/&gt;
  )
});

// ---
// Logo.tsx
import { component$ } from '@builder.io/qwik';
export default component$(() =&gt; {
  return (
    &lt;&gt;
      &lt;main&gt;Logo!&lt;/main&gt;
    &lt;/&gt;
  )
});</code></pre><p>코드는 매우 비슷해 보이며 이는 예상된 결과입니다. <strong>여기서 중요한 점은 모든 것이 기본적으로 서버에서 렌더링되므로 Qwik에서는 '사용 클라이언트' 또는 '사용 서버'를 정의할 필요가 없다는 것입니다.</strong> <strong>이는 개발자 경험을 극적으로 단순화하고 개선합니다.</strong> 위의 예는 사소한 예이지만 Next.js로 작업해 본 적이 있다면 서버와 클라이언트 컴포넌트 간에 작업하는 것이 지속적인 디자인 선택 및 구현 고려 사항이라는 것을 알고 있을 것입니다.</p><h3>캐싱</h3><p>Next.js는 캐싱에 대해 훨씬 더 많은 제어 기능을 제공합니다. Qwik에는 캐싱이 있으며 기간을 제어할 수는 있지만 무효화를 직접 제어할 수는 없습니다. 이것이 거래를 방해하는 요소인지 아닌지는 아직 밝혀지지 않았습니다. 실제로는 큰 문제가 되지 않았지만 문제가 될 수 있다고 예상할 수 있습니다.</p><p><strong>승자</strong> Next.js</p><p>Next.js를 사용하면 다음과 같이 캐시를 무효화할 수 있습니다:</p><pre translate="no"><code translate="no">// Next.js code below

export default async function Page() {
  const res = await fetch('https://...', { next: { tags: ['collection'] } })
  const data = await res.json()
  // ...
}

'use server'
 
import { revalidateTag } from 'next/cache'
 
export default async function action() {
  revalidateTag('collection')
}</code></pre><p>이 기능은 훌륭하지만 Qwik에서 크게 누락된 기능입니다. Qwik의 접근 방식은 변형을 일으킬 수 있는 서버 작업이 발생하면 모든 routeLoader$(현재 페이지 계층 구조에서 호출을 가져오는 것)를 다시 실행하는 것입니다. 이 방식은 작동하지만 세밀한 제어 기능이 없습니다.</p><h3>React 에코시스템</h3><p>Next.js는 전체 React 에코시스템과 자연스럽게 통합됩니다. Qwik은 <a target="_blank" rel="noopener noreferrer" href="https://qwik.dev/docs/integrations/react/">qwikify$</a> 함수를 통해 더 광범위한 React 에코시스템에 액세스할 수 있으며, Qwik 문서에서는 이를 <a target="_blank" rel="noopener noreferrer" href="https://qwik.dev/docs/integrations/react/#use-qwikify-as-a-migration-strategy">마이그레이션 전략으로</a> 고려해야 한다고 말합니다. 이는 qwikify$로 래핑된 모든 React 컴포넌트가 서로 분리되어 렌더링되고 수화되어 성능에 영향을 줄 수 있기 때문입니다. 그러나 여기서 반대되는 점은 이러한 하이드레이션이 발생할 때 Qwik이 많은 유연성을 제공한다는 것입니다. 예를 들어 브라우저가 <a target="_blank" rel="noopener noreferrer" href="https://qwik.dev/docs/integrations/react/#clientidle">유휴</a> 상태가 될 때까지 React 컴포넌트의 하이드레이션을 기다리도록 Qwik에 지시할 수 있습니다. 유휴 상태 외에도 다른 많은 제어 메커니즘이 있습니다.</p><p>Qwik의 또 다른 멋진 기능은 컴포넌트가 포함된 페이지가 렌더링될 때까지 React 라이브러리를 끌어내리지 않는다는 것입니다. B 페이지에 qwik화된 React 컴포넌트가 있는 경우, 브라우저에서 B 페이지를 모두 누르고 페이지에 표시되는 등 다양한 조건이 충족될 때까지(아직 표시되지 않는 모달을 생각해보세요) React 라이브러리가 로드되지 않습니다. Qwik은 Next.js보다 훨씬 더 많은 제어 기능을 제공합니다. qwikify$는 마이그레이션 전략으로 간주되지만 잘 작동하며 잠재적인 성능 문제를 완화할 수 있는 다양한 수단이 있습니다.</p><p><strong>승자:</strong> Edge, Qwik으로 전환</p><pre translate="no"><code translate="no">// Next.js code below

'use client'
 
import { Carousel } from 'acme-carousel'
 
export default Carousel

// ---

import Carousel from './carousel'
 
export default function Page() {
  return (
    &lt;div&gt;
      &lt;p&gt;View pictures&lt;/p&gt;
 
      {/*  Works, since Carousel is a Client Component */}
      &lt;Carousel /&gt;
    &lt;/div&gt;
  )
}</code></pre><p>Next.js를 사용하면 서버 컴포넌트에서 클라이언트 컴포넌트를 기본적으로 사용할 수 없으므로 타사 컴포넌트를 '클라이언트 사용'이 있는 다른 컴포넌트로 래핑해야 합니다.</p><p>Qwik도 비슷하지만 제어 수준이 더 높습니다. 제가 Qwik의 접근 방식에서 정말 마음에 드는 점은 수화 제어입니다. Next.js는 여기에 대한 제어 기능이 없거나 거의 없는 반면, Qwik에서는 <a target="_blank" rel="noopener noreferrer" href="https://qwik.dev/docs/integrations/react/#adding-interactivity">로드, 유휴, 호버 등을</a> 통해 하이드레이션을 제어할 수 있습니다.</p><pre translate="no"><code translate="no">// Qwik code below

/** @jsxImportSource react */
import { qwikify$ } from '@builder.io/qwik-react';
import { Carousel } from 'acme-carousel'
 
export default qwikify$(Carousel, { eagerness: 'hover' })

// ---
// SomeComponent.tsx
import { component$ } from '@builder.io/qwik';
import Carousel from './carousel'
 
export default component$(() =&gt; {
  return (
    &lt;div&gt;
      &lt;p&gt;View pictures&lt;/p&gt;
      &lt;Carousel /&gt;
    &lt;/div&gt;
  )
});</code></pre><h3>차트 작성</h3><p>이 글을 쓰는 시점에서 Qwik에는 기본 차트 라이브러리가 없습니다. React에서는 수많은 라이브러리에 액세스할 수 있으며, 선택의 폭이 너무 넓습니다. 그렇긴 하지만, 클라이언트 측에서만 렌더링되기는 하지만 <a target="_blank" rel="noopener noreferrer" href="https://www.chartjs.org/docs/latest/getting-started/">Chart.js와</a> 같은 것을 Qwik에 통합하는 것은 간단할 것입니다. Qwik의 모든 기능을 활용하려면 서버 측에서 렌더링할 수 있는 차트 라이브러리를 만들어야 합니다. 그 전까지는 어떤 차트 라이브러리와도 쉽게 통합할 수 있지만 모두 클라이언트에서만 렌더링됩니다. 사용자 경험은 괜찮지만 네이티브 서버 측 렌더링 옵션이 없다는 점은 여전히 아쉬운 점입니다. 참고로, 서버 측 렌더링을 위해 svg 차트 라이브러리 또는 수동 svg를 사용할 수도 있지만 아직 이 작업을 수행하는 공식적인 Qwik 차트 라이브러리는 없습니다.</p><p><strong>승자:</strong> React 에코시스템의 네이티브 차트 라이브러리로 인한 Next.js</p><h3>상태 관리</h3><p>Qwik에는 기본적으로 신호가 있습니다. 그리고 시그널을 사용해 본 적이 있다면 React useState와 비교할 수 없습니다. 시그널이 손을 들어줍니다. Next.js에서 시그널을 가져오는 <a target="_blank" rel="noopener noreferrer" href="https://github.com/vercel/next.js/issues/45054">문제는</a> 아직 해결되지 않았지만, 결론은 React 라이브러리 자체에서 처리해야 한다는 것입니다. 일부 사용자가 Preact 신호를 Next.js에 몽키 패칭하는 데 성공했다고 보고했지만 결과는 엇갈리는 것 같습니다.</p><p><strong>승자:</strong> Qwik</p><pre translate="no"><code translate="no">// Next.js code below

'use client'

function HomePage() {
  // ...
  const [likes, setLikes] = React.useState(0);
 
  function handleClick() {
    setLikes(likes + 1);
  }
 
  return (
    &lt;div&gt;
      {/* ... */}
      &lt;button onClick={handleClick}&gt;Likes ({likes})&lt;/button&gt;
    &lt;/div&gt;
  );
}
// Qwik code below

export default component$(() =&gt; {
  // ...
  const likes = useSignal(0);
 
  return (
    &lt;div&gt;
      {/* ... */}
      &lt;button onClick={() =&gt; likes += 1}&gt;Likes ({likes})&lt;/button&gt;
    &lt;/div&gt;
  );
})</code></pre><p>시그널을 자식 컴포넌트에 프롭으로 전달하고 거기서 변경할 수도 있습니다. 콜백 함수 없이는 React에서 직접적으로 가능하지 않습니다.</p><pre translate="no"><code translate="no">// Qwik code below

// Parent.tsx
export default component$(() =&gt; {
  // ...
  const likes = useSignal(0);
 
  return (
    &lt;div&gt;
      &lt;Child likes={likes} /&gt;
    &lt;/div&gt;
  );
})

// Child.tsx
type Props = {
  likes: Signal&lt;number&gt;;
};
export default component$&lt;Props&gt;((props) =&gt; {
  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; props.likes += 1}&gt;Likes ({props.likes})&lt;/button&gt;
    &lt;/div&gt;
  );
})</code></pre><h3>개발 서버</h3><p>Qwik은 <a target="_blank" rel="noopener noreferrer" href="https://vitejs.dev/">Vite를</a> 사용하며, Vite는 개발 서버 프론트엔드 작업의 주요 요소 중 하나가 되고 있습니다. Vite에는 내장된 리버스 프록시, 매우 효율적인 모듈 처리 및 핫 모듈 재로딩과 같은 놀라운 기능이 있습니다. 자세한 내용은 <a target="_blank" rel="noopener noreferrer" href="https://vitejs.dev/guide/why.html">Vite를 사용해야 하는 이유를</a> 참조하세요. Next.js는 여전히 <a target="_blank" rel="noopener noreferrer" href="https://nextjs.org/docs/architecture/nextjs-compiler">SWC로</a> 빌드하는 것이 매우 빠르며 개발은 <a target="_blank" rel="noopener noreferrer" href="https://nextjs.org/docs/app/api-reference/next-config-js/turbo">Turbo로</a> 하는 것이 더 빠르지만 여기서는 Vite가 우위에 있습니다.</p><p><strong>승자:</strong> 엣지 투 퀵</p><h3>서버 측 렌더링</h3><p>서버 대 클라이언트 섹션에서 이 문제를 다루었지만 여기서는 서버 측 렌더링에 대해 더 자세히 살펴보고자 합니다.</p><p>서버 컴포넌트 렌더링과 브라우저가 프레임워크에서 첫 번째 HTML을 수신할 때를 생각하면 이야기가 매우 빠르게 복잡해집니다. Next.js와 Qwik은 방식은 다르지만 동일한 작업을 수행합니다. 결과는 사실상 액면 그대로 동일하지만 프레임워크별로 다른 개발자 경험을 제공하는 제어 메커니즘이 있습니다. <a target="_blank" rel="noopener noreferrer" href="https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming">Next.js의 로딩 UI 및 스트리밍 문서를</a> 읽어보면, React Suspense를 활용하여 UI를 '즉시' 로딩한 다음 점진적으로 해상도를 변경할 수 있습니다. 이는 매우 훌륭하며 Qwik에는 이에 대한 즉각적인 아날로그가 없지만 여전히 동일한 작업을 수행할 수 있습니다.</p><p>Next.js에 따르면 " <a target="_blank" rel="noopener noreferrer" href="https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#how-routing-and-navigation-works">서버 중심 라우팅을</a>사용하더라도 탐색이 즉각적으로 이루어집니다." 여기서 핵심 문제를 좀 더 자세히 설명하겠습니다. 서버 측 렌더링을 사용하면 구성 요소가 먼저 외부 소스(대부분)에서 제품 목록을 로드합니다. 다음으로 프레임워크가 구성 요소를 렌더링하고 HTML을 생성하며 백엔드에서 제품을 완전히 로드하고 HTML을 렌더링할 때까지 렌더링된 페이지가 표시되지 않습니다. 따라서 캐시가 없고 외부 API가 느린 경우 5초라고 가정하면 사용자는 5초 동안 렌더링된 제품 페이지의 HTML을 전혀 볼 수 없습니다. 이는 좋지 않은 사용자 경험이라는 데 동의할 수 있습니다. 브라우저가 아무것도 하지 않거나 응답하지 않는 것처럼 보입니다.</p><p>Next.js가 이 문제를 처리하는 방법은 <a target="_blank" rel="noopener noreferrer" href="https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming">loading.js를</a> 사용하여 React Suspense를 활용하도록 지시하는 것입니다. Suspense를 사용하면 데이터가 로드되는 동안 폴백 컴포넌트를 렌더링할 수 있습니다. 그런 다음 데이터가 로드되면 폴백 컴포넌트가 실제 컴포넌트로 대체됩니다. 이것은 정말 멋진 기능이며 훌륭한 개발자 경험을 제공합니다.</p><p>Qwik은 이를 다르게 처리합니다. Qwik에는 서버에서만 실행되는 routeLoader$라는 함수가 있습니다. 페이지가 렌더링되기 전에 프로미스가 해결되어야 합니다. 따라서 제품 컴포넌트의 경우 routeLoader$가 호출되고 5초 후에 프로미스가 확인된 다음 페이지가 렌더링됩니다. Qwik에는 Suspense와 같은 개념이 없지만 <a target="_blank" rel="noopener noreferrer" href="https://qwik.dev/docs/server$/#streaming-responses">server$ 스트리밍을</a> 사용하여 동일한 작업을 수행할 수 있습니다. 여기서 차이점은 데이터 로딩을 직접 관리해야 하지만 데이터 로딩을 더 많이 제어할 수 있다는 것입니다. 예를 들어 처음 10개 제품을 로드한 다음 페이지를 렌더링한 다음 나머지 제품을 로드할 수 있습니다. 이것은 인위적인 예시이지만 요점을 잘 보여줍니다. 스트리밍으로 데이터를 로드하는 예제를 보여주는 흥미로운 Qwik의 <a target="_blank" rel="noopener noreferrer" href="https://github.com/BuilderIO/qwik/issues/4178">GitHub 이슈가</a> 있습니다. Qwik에서 이 작업을 수행하는 것이 상당히 복잡하다는 것을 알 수 있습니다. 이 부분에서 Next.js가 단순성으로 승리합니다.</p><p><strong>승자: </strong>Next.js는 React Suspense에 대한 개발자 경험으로 인해 승리했습니다. 그러나 Qwik은 잠재적으로 더 세밀하게 제어할 수 있으며 동일한 작업을 수행할 수 있지만 원활하게 수행하지는 못합니다.</p><h2>Qwik을 선택한 이유</h2><ul><li>대부분의 경우 서버와 클라이언트 구성 요소를 관리할 필요가 없는 등<strong>개발자 환경이 더 우수하기 때문에 Qwik이 궁극적으로 개발하기 더 쉽습니다</strong>. 특별히 클라이언트 측에서 렌더링하도록 만들지 않는 한 모든 것이 처음에 서버 측에서 렌더링되는 것이 Qwik의 기본 설계입니다. <i>'클라이언트 사용'</i> 또는 <i>'서버 사용</i>'이라는 표시를 하지 않아도 그냥 작동하며, 사용자는 이에 대해 생각하지 않아도 됩니다.</li><li><strong>Qwik 에코시스템은 초기 단계에 있지만, 더 광범위한 React 에코시스템에 액세스할 수 있습니다.</strong> 예, 수화에 대한 페널티가 있지만 실제로는 일반적으로 무시할 수 있는 수준이지만 Next.js에는 대안이 없기 때문에 수화에 대한 페널티가 존재합니다. Qwik의 은색 안감은 하이드레이션이 발생하는 시기를 제어할 수 있고 결국에는 React 컴포넌트를 Qwik 네이티브가 되도록 다시 작성/리팩터링할 수 있다는 것입니다.</li><li><strong>시그널이 React 사용 상태보다 우월하다는</strong> 점에는 이견이 많지 않을 것 같습니다. 오히려 일부 사람들은 시그널보다 RxJS를 주장할 수도 있지만, 이는 다른 논의입니다.</li><li><strong>저는 Qwik의 재개성 방식이 앞으로 프레임워크의 초석이 될 수 있다고 생각합니다. </strong>React 서버 컴포넌트도 렌더링 후 데이터를 클라이언트에 직렬화하는 것과 비슷한 작업을 수행합니다. 하지만 RSC에서는 "서버 컴포넌트에 대해 작성된 모든 코드는 직렬화 가능해야 하며, 이는 useEffect()나 state와 같은 라이프사이클 훅을 사용할 수 없다는 의미"인 반면, Qwik에는 이러한 제한이 없습니다. RSC가 올바른 방향으로 나아가는 단계이긴 하지만 현재로서는 Qwik의 접근 방식이 더 우수하다고 생각합니다. 그렇다고 해서 Qwik 자체가 미래에 반드시 사실상의 <i>프레임워크가</i> 될 것이라는 의미는 아니지만, 미래지향적이고 미래 지향적이며 다른 프레임워크(예: Next.js)가 완화해야 하는 많은 문제를 해결해 줍니다.</li><li>기본적으로 Next.js(또는 모든 React 프레임워크)에서는 서드파티 컴포넌트를 더 많이 추가할수록 브라우저의 번들 크기가 커집니다. 여기에는 선형 관계가 있습니다. <strong>그러나 Qwik에서는 직접적인 선형 관계가 아니라 훨씬 더 많은 제어가 있습니다. 특별히 필요한 경우가 아니면 기본적으로 브라우저에 자바스크립트가 전달되지 않습니다.</strong> 예를 들어 차트 라이브러리가 포함된 컴포넌트를 가질 수 있으며, 페이지에서 라이브러리를 가져온 경우에도 해당 라이브러리가 로드되는 시기를 제어할 수 있습니다. 즉, 모달에서만 사용되는 차트 라이브러리가 있는 경우 모달이 열릴 때만 해당 라이브러리를 로드하도록 Qwik에 지시할 수 있습니다. 이는 Qwik에게 큰 도움이 됩니다. Next.js에서는 동적 가져오기를 통해 이 작업을 수행할 수 있지만 Qwik만큼 간단하지는 않습니다. 또한 Qwik에는 방금 언급한 시나리오보다 훨씬 더 많은 제어 기능이 있습니다.</li><li><strong>Qwik에서는 클라이언트의 onClick에서 비동기 생성기의 서버 응답을 스트리밍할 수 있습니다.</strong> <a target="_blank" rel="noopener noreferrer" href="https://qwik.dev/docs/server$/#streaming-responses">이 예시를</a> 보면 바로 여기에 마법의 소스가 있습니다. React 서버 컴포넌트를 사용하여 Next.js/React에서 이를 모방하기 위해 무언가를 해킹하는 것이 불가능한 것은 아니지만, 이를 지원하는 것이 Qwik의 기본 설계이므로 Qwik이 이를 수행하는 방식이 아닐 것입니다.</li><li><a target="_blank" rel="noopener noreferrer" href="https://qwik.dev/docs/components/tasks/#track"><strong>사용태스크는</strong></a><strong> React의 사용효과와 비슷하지만</strong>, <strong>Qwik은 시그널을 사용하기 때문에 사용법이</strong> React의 <i>사용효과 + 사용상태보다</i> <strong>훨씬 직관적입니다</strong>. 상용구 코드가 훨씬 적고 논리가 더 합리적입니다.</li></ul><h2>결론: Qwik 프레임워크가 승리</h2><p>Next.js나 Qwik 중 어느 쪽도 잘못될 수는 없습니다. 둘 다 훌륭한 문서가 있고, 추진력이 있으며, 둘 다 프로덕션에서 사용됩니다. Qwik이 뛰어나다고 생각하는 많은 기술적 영역을 제시했지만, 제가 정말 좋아하는 것은 프레임워크에서 개발할 때의 무형의 느낌입니다. 모든 프레임워크나 언어에 이러한 무형의 느낌이 있는 것은 아닙니다. Qwik에는 그런 느낌이 있어서 코딩할 때마다 기분이 좋습니다.</p><p><a target="_blank" rel="noopener noreferrer" href="https://outshift.cisco.com/#theshift">Shift 뉴스레터에 가입</a> 하여 새로운 기술에 대한 최신 인사이트를 더 많이 받아보세요.</p></div></div>
	      </article>
			</main>
    </body>
  </html>
  