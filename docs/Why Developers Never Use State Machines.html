
  <html lang="ko">
    <head>
      <meta charset="utf-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>Why Developers Never Use State Machines</title>
      <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
      <script src="//unpkg.com/alpinejs" defer></script>
    </head>
    <body x-data="{ dark: false }" x-bind:data-theme="dark ? 'dark' : 'light'">
      <main class="container">
      	<button x-on:click="dark = !dark" class="contrast outline">Switch Theme</button>
	      <article>
	        <div id="readability-page-1" class="page"><div>
					
					<p>읽기 시간: 5분 20초</p>
				</div><div>
				<h2>소개</h2>
<p>상태 머신은 비즈니스 프로세스의 여러 상태를 설명하는 일반적인 방법입니다. 언뜻 보기에 개발자에게는 쉬운 도구처럼 보입니다. 기본적으로 머신 내의 모든 상태를 정의하고 한 상태에서 다른 상태로의 전환을 설명하기만 하면 됩니다. 하지만 겉보기에는 단순해 보이지만 개발자들은 곧 상태 머신을 사용한 것을 후회하기 시작합니다.</p>
<h2>상태 머신의 주요 결함</h2>
<p>스테이트 머신은 로직이 단순한 프로세스에서 사용할 수 있습니다. 실제 사례를 생각해 봅시다. 램프에 상태 머신을 사용한다고 가정해 보겠습니다. 램프는 불이 켜져 있을 때 활성 상태와 꺼져 있을 때 비활성 상태, 총 두 가지 상태를 갖게 됩니다. 시스템이 작동하려면 상태 전환이 필요합니다. 이 경우 스위치 켜기 및 스위치 끄기 명령이 필요합니다. </p>
<p>상태 머신 작업은 상태와 상태 전환의 두 가지 유형만 있다면 매우 간단해 보입니다. 하지만 수많은 상태 또는 상태 클래스가 있는 보다 정교한 시스템을 개발한다고 가정해 보세요. 각 상태마다 시스템의 동작이 다르므로 모든 상태를 특성화하는 것이 여러분의 과제입니다. 또한 시스템이 한 상태에서 다른 상태로 이동할 수 있도록 하는 이벤트도 정의해야 합니다. 예를 들어 온라인 주문 시스템을 만들라는 요청을 받았다고 가정해 보겠습니다. 이를 위해서는 고객이 주문할 때 시스템이 어떻게 작동하는지, 재고가 없는 경우 또는 고객이 선택한 품목을 변경하거나 삭제하기로 결정한 경우와 같이 시스템의 모든 가능한 상태를 고려해야 합니다. 이러한 상태의 수는 100개 이상에 달할 수 있습니다. 각 상태에 대한 시스템 동작을 지정하기 시작하면 곧 코드를 읽을 수 없게 된다는 사실을 깨닫게 됩니다. </p>
<p>게다가 상태 관리는 모든 개발자에게 까다로운 프로세스가 됩니다. 예를 들어, 시스템이 발전하여 새로운 기능을 추가해야 할 때 어떻게 해야 할까요? 시스템을 완전히 재구성해야 할 것입니다. 게다가 새로운 상태와 그 전환을 추가하면 코드의 복잡성이 급격히 증가하여 프로그램에 새로운 변경 사항을 적용하기가 더 어려워집니다. 시스템을 관리할 수 없게 됩니다. </p>
<p>복잡한 상태 머신은 유지 관리와 디버깅도 어렵게 만듭니다. 분석해야 하는 비동기 텍스트 로그가 1000줄 이상일 수도 있습니다. 이 작업을 하다 보면 곧 '스파게티 코드'로 작업하는 자신을 발견하게 될 것입니다.  특정 문제가 발생하면 그 원인을 파악하는 데 몇 시간이 걸릴 수도 있습니다. 결과적으로 시스템 디버깅은 악몽으로 변합니다.</p>
<h2>발생할 수 있는 다른 문제</h2>
<p>유한 상태 머신을 고려하면 계산 능력이 떨어집니다. 기본 FSM은 일련의 상태와 트랜지션으로 구성됩니다. 따라서 메모리는 상태의 수에 의해 제한됩니다. 기계가 가진 유일한 메모리는 상태로 인코딩되고 상태의 수가 유한하기 때문에 메모리도 엄격하게 유한하다는 것을 의미합니다. 논리도 제한되어 있어 한 상태에서 다른 상태로 전환하는 것만 편집할 수 있습니다.</p>
<p>또한 상태 머신을 사용할 때 개발자는 도달할 수 없는 상태에 도달하는 문제에 직면할 수 있습니다. 이는 스테이트 머신이 특정 상태에 도달했는데 해당 활동을 트리거할 유효한 입력이 없어 해당 상태를 종료할 수 없을 때 발생합니다. 이 문제는 종종 결과를 알 수 없는 동작으로 이어지고 결과적으로 시스템 장애로 이어집니다.</p>
<h2>대안을 고려해야 할 적절한 시기는 언제인가요?</h2>
<p>상태 머신을 구현하는 것이 최선의 선택은 아닙니다:</p>
<p><strong>코드를 상태로 나눌 수 없는 경우</strong></p>
<p>상태 머신을 사용할 가치가 있는지 이해하려면 시스템을 여러 가지 상태로 나눌 수 있는지 생각해 보세요. 종이에 다이어그램을 그려보면 쉽게 이해할 수 있습니다. 예를 들어, 작업 관리 시스템을 구축해야 하는데 다양한 조건에서 시스템이 어떻게 작동하는지 알아내려고 합니다. 이 작업이 완료되면 시스템을 여러 상태로 분해합니다. 10개의 상태를 생각해냈다고 가정하고 다음 단계는 이를 다이어그램에 반영하는 것입니다. 그 다음에는 한 상태에서 다른 상태로 전환할 수 있는 특정 조건을 생각해야 합니다. 예를 들어, 할당된 직원이 작업을 완료하면 진행 중 상태가 완료로 바뀝니다. 이러한 모든 전환이 다이어그램에 반영될 수 있습니다. 그러나 시스템이 너무 복잡하여 별도의 상태로 나눌 수 없는 경우 다이어그램화가 불가능해집니다. 이 경우 상태 머신에 대한 가능한 대안을 생각하는 것이 좋습니다.</p>
<p><strong>상태의 수는 무한정입니다.</strong></p>
<p>각 상태 머신은 새로운 상태를 추가로 생성하는 일련의 입력 항목을 받아들입니다. 새로운 시스템을 구축할 때 개발자는 다음 단계나 출력에 대한 정보를 포함하여 가능한 모든 입력 조합을 생각해야 합니다. 입력 항목의 수가 너무 많거나 무한정인 경우에는 다른 도구의 사용을 고려할 필요가 있습니다.</p>
<p><strong>여러 상태를 병렬로 실행하려는 경우</strong></p>
<p>상태 머신은 순차적으로 실행해야 하는 작업에 적합한 솔루션입니다. 이 경우 다음에 활성화할 상태를 결정하는 것은 이전 상태의 동작에 따라 달라집니다. 그러나 여러 작업을 병렬로 실행하려는 경우 상태 머신은 옵션이 아닙니다. </p>
<p><strong>알고리즘이 너무 단순하거나 너무 복잡한 경우</strong></p>
<p>특정 경우에는 스테이트 머신이 유용할 수 있습니다. 예를 들어 코드를 여러 개의 상태로 나눌 수 있고 이러한 상태가 다양한 입력에 의해 영향을 받는다면 상태 머신을 사용하는 것이 좋습니다. 그러나 복잡성이 증가할 가능성이 낮은 간단한 알고리즘이라면 상태 머신이 필요하지 않습니다. 다시 말하지만, 상태 수가 너무 많아 코드를 읽을 수 없게 된다면 다른 대안을 생각해 보는 것도 좋습니다.</p>
<h2>결론</h2>
<p>상태 머신은 명확한 수의 상태와 해당 상태로의 전환을 트리거하는 이벤트를 정의할 수 있을 때 유용합니다. 사용자 인터페이스나 통신 프로토콜에 유용할 수 있습니다. 그러나 복잡한 시스템을 구축할 때는 상태 머신을 구현하는 것이 최선의 선택이 아닙니다. 이 경우 가독성이 떨어지는 수백 줄의 코드를 다루게 될 것입니다. 또한 유지 관리 및 지원에 문제가 발생할 가능성이 높습니다. 따라서 시스템을 별도의 상태로 분해할 수 없거나 상태의 수가 무한하지 않은 경우에는 가능한 대안을 고려해야 합니다. </p>			</div></div>
	      </article>
			</main>
    </body>
  </html>
  