
  <html lang="ko">
    <head>
      <meta charset="utf-8">
      <title>Was Rust Worth It? - Jarrod Overson - Medium</title>
      <link rel="canonical" href="https://jsoverson.medium.com/was-rust-worth-it-f43d171fb1b3">
      <style>
        pre {
          padding: 1rem;
          background-color: #263238;
          color: #fff
        }
      </style>
    </head>
    <body>
      <article>
        <div id="readability-page-1" class="page"><div><figure><figcaption>확실하지 않은 게</figcaption></figure><div><h2 id="ade7">자바스크립트에서 러스트까지, 3년의 시간.</h2><div><a rel="noopener follow" href="https://jsoverson.medium.com/?source=post_page-----f43d171fb1b3--------------------------------"><div aria-hidden="false"><p><img alt="Jarrod Overson" src="https://miro.medium.com/v2/resize:fill:88:88/1*DUjBSZ8vCnqtthWwHubL9A.png" width="44" height="44" loading="lazy" data-testid="authorPhoto"></p></div></a></div></div><p id="b39c">몇 년 전, 저는 모든 것을 내려놓고 WebAssembly에 100% 집중하기로 했습니다. 당시에는 Rust가 WebAssembly 컴파일을 가장 잘 지원했고, 가장 완벽한 기능을 갖춘 WebAssembly 런타임도 Rust 기반이었습니다. Rust가 최고의 옵션이었죠. 저는 그 모든 과대광고가 무엇인지 궁금해서 바로 뛰어들었습니다.</p><p id="b755">그 이후로 저는 다른 멋진 사람들과 함께 WebAssembly를 핵심 모듈 시스템으로 사용하는 애플리케이션 프레임워크이자 런타임인 <a href="https://github.com/candlecorp/wick" rel="noopener ugc nofollow" target="_blank">Wick을</a> 구축했습니다.</p><figure><figcaption>Wick은 Rust 실험의 주요 목표였습니다.</figcaption></figure><p id="6fee">3년 동안 여러 번의 프로덕션 배포와 <a href="https://github.com/jsoverson/node-to-rust" rel="noopener ugc nofollow" target="_blank">전자책</a>, 그리고 <a href="https://crates.io/me/crates" rel="noopener ugc nofollow" target="_blank">crates.io에</a> 배포된 약 100개의 패키지를 통해 Rust에 대한 몇 가지 생각을 공유할 때가 되었다고 생각합니다.</p><h2 id="7ba4">좋은 점</h2><h2 id="0854">적은 비용으로 더 많은 것을 유지할 수 있습니다.</h2><p id="9c68">저는 테스트 중심 개발을 적극 지지합니다. 저는 Java와 JavaScript 같은 언어로 테스트하는 데 익숙해져 있습니다. 다른 언어와 마찬가지로 Rust로 테스트를 작성하기 시작했지만 <em>실패할 수 없는</em> 테스트를 작성하고 있다는 것을 알게 되었습니다. 테스트가 실행될 수 있는 지점, 즉 Rust 코드가 컴파일되는 지점에 도달하면 Rust가 너무 많은 오류를 발생시켜 많은 일반적인 테스트 케이스가 무의미해집니다. <code translate="no">unsafe {}</code> 블록과 패닉에 빠지기 쉬운 방법( <code translate="no">.unwrap()</code>)을 피한다면 기본적으로 많은 문제를 회피할 수 있는 기반에서 시작하는 것입니다.</p><p id="468a">Rust의 차용 검사기의 공격성, Rust의 유형 시스템의 풍부함, 기능적 패턴과 라이브러리, 'null' 값의 부족은 모두 테스트와 같은 곳에서 더 적은 노력으로 더 많은 것을 유지 관리할 수 있게 해줍니다. 저는 다른 언어에 비해 훨씬 적은 수의 테스트로 Wick 프로젝트에서 70,000줄이 넘는 코드를 유지 관리했습니다.</p><p id="cde4">테스트를 작성해야 할 때 고민할 필요 없이 즉석에서 쉽게 추가할 수 있습니다. Rust의 통합 테스트 하네스를 사용하면 코드 바로 옆에 테스트를 추가할 수 있습니다.</p><h2 id="29a1">이제 다른 언어로 더 잘 코딩합니다</h2><p id="7b0c">Rust로 프로그래밍하는 것은 마치 감정적으로 학대하는 관계에 있는 것과 같습니다. 다른 사람이었다면 지극히 정상적이라고 생각했을 일들에 대해 하루 종일, 매일같이 소리를 지르죠. 결국에는 화를 내는 것에 익숙해집니다. 일상이 됩니다. 컴파일러의 화를 유발하지 않기 위해 줄타기를 하는 법을 배우게 됩니다. 그리고 실제 삶에서와 마찬가지로 이러한 행동 변화는 영원히 지속됩니다.</p><p id="d05f">정서적 학대는 일반적으로 변화를 장려하는 <em>건전한</em> 방법으로 간주되지 않지만, 그럼에도 불구하고 변화에 영향을 미칩니다.</p><p id="c7a0">저는 다른 언어로 코드를 작성할 때 줄이 어긋나거나 반환 값이 체크되지 않은 경우 불편함을 느끼지 않고는 코드를 작성할 수 없습니다. 또한 런타임 오류가 발생하면 비이성적으로 화가 나기도 합니다.</p><figure><figcaption><em>"</em><code translate="no"><em>done"</em></code><em> 가 함수가 아니라니요? 왜 "</em><code translate="no"><em>done”</em></code><em> 가 함수가 아닐 수도 있다는 걸 왜 알려주지 않았나요?</em></figcaption></figure><h2 id="133d">클리피는 훌륭합니다!</h2><p id="f0cc"><a href="https://github.com/rust-lang/rust-clippy" rel="noopener ugc nofollow" target="_blank">클리피는</a> 러스트의 린터이지만, 린터라고 부르는 것은 잘못된 표현입니다. 컴파일러가 여러분을 울릴 수 있는 언어에서 클리피는 부스러기라기보다는 친절한 친구에 가깝습니다.</p><p id="aed8">Rust 표준 라이브러리는 <em>방대합니다</em>. 수많은 세분화된 유형, 특성, 매크로, 함수에 수많은 기능이 분산되어 있기 때문에 아마도 존재하는 것으로 알고 있는 함수를 찾기가 어렵습니다. 많은 Clippy 규칙(예, <code translate="no"><a href="https://rust-lang.github.io/rust-clippy/master/index.html#/manual_is_ascii_check" rel="noopener ugc nofollow" target="_blank">manual_is_ascii_check</a></code>)은 일반적인 패턴을 찾아서 stdlib 메서드나 타입으로 대체하는 것이 더 낫습니다.</p><p id="b1cb">Clippy에는 성능, 가독성, 불필요한 간접성을 다루는 <a href="https://rust-lang.github.io/rust-clippy/master/index.html" rel="noopener ugc nofollow" target="_blank">수백 개의 규칙이</a> 있습니다. 가능한 경우 대체 코드를 자주 제공합니다.</p><p id="fd27">또한 (곧) 프로젝트에 대한 글로벌 린트를 구성할 수 있게 될 것 같습니다. 지금까지는 프로젝트의 일관성을 유지하려면 솔루션을 해킹해야 했습니다. Wick에서는 스크립트를 사용하여 수십 개의 상자에 대한 <a href="https://github.com/candlecorp/wick/blob/main/src/main.rs#L8-L84" rel="noopener ugc nofollow" target="_blank">인라인 린트 구성을</a> 자동으로 업데이트합니다. Rust 커뮤니티가 이 문제를 해결할 수 있는 솔루션을 찾는 데 <a href="https://github.com/rust-lang/cargo/issues/5034" rel="noopener ugc nofollow" target="_blank"><em>수년이</em></a> 걸렸고, 그 결과 다음과 같은 결과를 얻었습니다.</p><h2 id="9fdb">나쁜 점</h2><h2 id="8a7c">감수해야 할 공백이 있습니다.</h2><p id="764a">위의 클리피 문제를 다시 떠올릴 때마다 제 정신이 맞는지 의심스러웠습니다. 분명히 내가 틀렸다. 제가 놓친 구성이 있을 겁니다. 믿을 수가 없었습니다. 아직도 믿을 수 없습니다. 라인트를 전역적으로 구성하는 방법이 있을 <strong><em>겁니다</em></strong>. <a href="https://www.appsloveworld.com/rust/4/how-can-i-have-a-shared-clippy-configuration-for-all-the-crates-in-a-workspace" rel="noopener ugc nofollow" target="_blank">이</a> 글을 <a href="https://github.com/rust-lang/rust-clippy/issues/6625" rel="noopener ugc nofollow" target="_blank">쓸</a> <a href="https://github.com/rust-lang/rust-clippy/issues/1313" rel="noopener ugc nofollow" target="_blank">때</a> 제가 망상에 빠진 <a href="https://github.com/EmbarkStudios/rust-ecosystem/issues/22" rel="noopener ugc nofollow" target="_blank">것은</a> 아닌지 <a href="https://github.com/rust-lang/rust/issues/45832" rel="noopener ugc nofollow" target="_blank">네</a> <a href="https://github.com/rust-lang/cargo/issues/5034" rel="noopener ugc nofollow" target="_blank">번이나 확인했습니다</a>. 그 문제는 지금은 해결되었지만 몇 년 동안 열려 있던 문제였습니다.</p><p id="a078">클리피는 훌륭하지만 이 사용 사례는 Rust 세계 곳곳에 있는 많은 사례 중 하나입니다. 제 사용 사례에 포함되지 않은 라이브러리나 도구를 자주 접하게 됩니다. 새로운 언어나 프로젝트에서는 드물지 않은 일입니다. 소프트웨어가 성숙하려면 (사용법을 익히는 데) 시간이 걸립니다. 하지만 Rust는 <em>그렇게</em> 새롭지 않습니다. Rust에는 뭔가 다른 느낌이 있습니다.</p><p id="8970">오픈 소스에서 엣지 케이스는 얼리어답터와 신규 사용자에 의해 자주 해결됩니다. 그들이 바로 엣지 케이스를 가진 사람들입니다. 이들의 PR은 프로젝트를 개선하여 다음 사용자에게 더 나은 서비스를 제공합니다. <a href="https://github.blog/2023-08-30-why-rust-is-the-most-admired-language-among-developers/" rel="noopener ugc nofollow" target="_blank">Rust는 10년 넘게 "가장 사랑받는 언어</a>"로 선정되었습니다. 새로운 사용자를 끌어들이는 데는 문제가 없지만 라이브러리나 도구가 획기적으로 개선되지는 않습니다. 그 결과 특정 사용 사례를 처리하는 일회성 포크가 만들어지고 있습니다. 저도 그 점에 대해서는 유죄이지만, 홍보를 위한 노력이 부족해서가 아닙니다.</p><p id="79b6">이유는 모르겠습니다. 아마도 Rust의 세분화된 유형 시스템과 함께 안정적인 API를 유지해야 한다는 압박감 때문에 라이브러리 소유자가 반복 작업을 하기가 어렵기 때문일 것입니다. 버전이 크게 변경될 수 있는 사소한 변경을 받아들이기 어렵기 때문일 수도 있습니다.</p><p id="674c">또는 모든 사람이 모든 것을 처리할 수 있는 Rust 코드를 작성하는 것이 매우 어려워서 사람들이 이를 다루고 싶어하지 않기 때문일 수도 있습니다.</p><h2 id="e6f5">Cargo, crates.io 및 프로젝트 구조화 방법</h2><p id="d7d1">저는 제가 본 다른 인기 있는 프로젝트를 중심으로 Wick 리포지토리 구조를 모델링했습니다. 합리적으로 보였고 제대로 작동하기 전까지는 괜찮았습니다.</p><p id="e84b">Cargo를 사용하면 모듈 크기의 상자를 쉽게 빌드, 테스트 및 사용할 수 있습니다. 하지만 crates.io에 배포하는 것은 어떨까요? 완전히 다른 이야기입니다.</p><p id="4893">참조되는 <strong>모든</strong> 상자가 개별적으로 게시되지 않는 한 패키지를 crates.io에 게시할 수 없습니다. 어느 정도는 이해가 됩니다. 작성자의 로컬 파일 시스템에만 존재하는 패키지에 의존하는 크레이트에 의존하고 싶지는 않을 테니까요.</p><p id="2591">하지만 많은 개발자가 대규모 프로젝트를 자연스럽게 더 작은 모듈로 나누기 때문에 그 <em>안에만 존재하는 </em>하위 상자가 있는 상위 상자를 게시할 수 없습니다. 로컬 개발 종속성이 있는 상자를 게시할 수도 없습니다. 이 문제를 피하려면 무작위 유틸리티 상자를 게시하거나 프로젝트를 재구성하는 방법 중 하나를 선택해야 합니다. 이 제한은 자의적이고 불필요하게 느껴집니다. 이런 식으로 구조화된 프로젝트는 분명히 만들 수 있지만 게시할 수는 없습니다.</p><blockquote><p id="b7c4">편집: <a href="https://www.reddit.com/r/rust/comments/17gnkh2/was_rust_worth_it/k6jf2c0/" rel="noopener ugc nofollow" target="_blank">에드 페이지에게 문의</a> 한 결과 <code translate="no">version</code> 를 포함하지 않는 한 로컬 개발 종속성을 사용하여 게시할 <em>수</em> 있다고 합니다. <code translate="no">Cargo.toml</code></p></blockquote><p id="b0d9">그래도 Cargo의 워크스페이스 지원은 훌륭합니다! Cargo의 작업 영역은 대부분의 언어보다 대규모 프로젝트를 관리하기에 더 나은 환경을 제공합니다. 하지만 배포 문제는 해결하지 못합니다. 12가지 방법으로 작업 공간을 설정할 수 있지만 그 중 <em>어느</em> 방법도 배포가 쉽지 않습니다.</p><p id="5bd0">워크스페이스 게시를 간소화하기 위해 고안된 수많은 <a href="https://crates.io/search?q=cargo+workspace+publish" rel="noopener ugc nofollow" target="_blank">유틸리티 상자</a> 에서 이 문제를 확인할 수 있습니다. 각 유틸리티는 구성의 하위 집합에서 작동하며, 워크스페이스를 설정하는 "진정한 방법"은 여전히 저에게 익숙하지 않습니다. Wick을 게시할 때는 수동으로 반복되는 작업과 부분적으로만 작동하는 도구를 결합하는 데 한 시간 이상 걸리는 경우가 많습니다.</p><h2 id="8ab7">비동기</h2><p id="b1a0">Rust는 개발 초기부터 비동기 기능을 추가했습니다. 비동기는 나중에 생각한 것처럼 느껴지고, 나중에 생각한 것처럼 작동하며, 이해하기 어렵고 해결하기 힘든 오류로 작업을 방해하는 경우가 많습니다. 해결책을 검색할 때는 다양한 런타임과 그 런타임의 비동기 방식에 따라 필터링해야 합니다. 비동기 라이브러리를 사용하고 싶으신가요? 특정 비동기 런타임 외에는 사용할 수 없을 가능성이 있습니다.</p><p id="ba1a">20년 동안 자바스크립트를 사용해왔고 Go를 꽤 잘 사용해왔지만, Rust와 마찰을 일으키는 <em>가장 큰 </em>원인은 바로 이 점입니다. 극복할 수 없는 문제는 아니지만, 비동기라는 괴물이 고개를 내밀었을 때 항상 대처할 준비가 되어 있어야 합니다. 다른 언어에서는 비동기가 거의 보이지 않습니다.</p><h2 id="14b4">추악한</h2><h2 id="c70d">리팩터링이 어려울 수 있습니다.</h2><p id="64a2">Rust의 풍부한 타입 시스템은 축복이자 저주입니다. Rust 타입으로 사고하는 것은 꿈같은 일입니다. Rust의 타입을 관리하는 것은 악몽이 될 수 있습니다. 데이터와 함수 시그니처에는 일반 타입, 일반 수명, 특성 제약 조건이 있을 수 있습니다. 이러한 제약 조건은 고유한 일반 유형과 수명을 가질 수 있습니다. <a href="https://github.com/rxRust/rxRust/blob/master/src/observable.rs#L1134-L1142" rel="noopener ugc nofollow" target="_blank">때로는 실제 코드보다 더 많은 유형 제약</a> 조건이 있을 수 있습니다.</p><figure><figcaption>로직보다 중요한 제약 조건</figcaption></figure><p id="79ea">또한 <a href="https://github.com/bytecodealliance/wasmtime/blob/038ddfeb6699591b5d82546c9b2d5076097bc9ce/cranelift/entity/src/iter.rs#L29-L58" rel="noopener ugc nofollow" target="_blank">모든 </a> 제네릭을 모든 <code translate="no"><a href="https://github.com/bytecodealliance/wasmtime/blob/038ddfeb6699591b5d82546c9b2d5076097bc9ce/cranelift/entity/src/iter.rs#L29-L58" rel="noopener ugc nofollow" target="_blank">impl</a></code>. 처음 작성할 때는 지루합니다. 하지만 리팩토링할 때는 사소한 변경이 연쇄적으로 엉망이 될 수 있습니다.</p><figure><figcaption>단순한 제네릭 ID가 계속 중복됩니다.</figcaption></figure><p id="c24a">한 걸음도 앞으로 나아가기 전에 14개의 서로 다른 정의를 수정해야 할 때 빠른 진전을 이루기는 어렵습니다.</p><p id="790a"><em>외부 의견을 반영하여 수정하세요: 문제는 표현력이 아니라 중복을 줄일 수 있는 언어나 툴링 솔루션이 없다는 것입니다. 동일한 제약 조건을 갖거나 동일한 일반 목록을 참조해야 하는 경우가 자주 발생하지만 별칭을 지정하거나 중앙 정의를 참조할 방법이 없습니다. 꼭 있어야 하는지는 모르겠지만, 그렇다고 해서 중복의 부담이 달라지지는 않습니다.</em></p><h2 id="32dd">결론</h2><p id="be53">저는 Rust를 좋아합니다. 이 도구가 할 수 있는 일과 다재다능함이 정말 마음에 듭니다. CLI 앱, 웹 서버 <em>,</em> 웹 클라이언트와 동일한 언어로 시스템 수준의 코드를 작성할 수 있습니다. 웹어셈블리를 사용하면 명령줄에서와 동일한 바이너리를 사용하여 <a href="https://wasm.candle.dev/llama2" rel="noopener ugc nofollow" target="_blank">브라우저에서</a> LLM을 실행할 수 있습니다. 아직도 감탄이 절로 나옵니다.</p><p id="715e">Rust 프로그램이 얼마나 견고할 수 있는지 정말 마음에 듭니다. Rust가 어떤 기능을 제공하는지 알게 되면 다른 언어로 돌아가기 어렵습니다. 저는 잠시 바둑으로 돌아갔어요. 다시 개발 속도에 취해버렸죠. 그러다 런타임 패닉에 빠졌고 유리가 깨졌습니다.</p><p id="9526">하지만 러스트에도 사마귀가 있습니다. 채용하기도 어렵고, 배우기도 느리고, 빠르게 반복하기에는 너무 경직되어 있습니다. 특히 비동기 코드의 경우 메모리 및 성능 문제를 해결하기가 어렵습니다. 모든 라이브러리가 다른 라이브러리만큼 안전한 코드를 제공하는 것은 아니며, 개발 도구도 부족한 점이 많습니다. 뒤늦게 시작하면 불리한 점이 많습니다. 이러한 장애물을 극복할 수 있다면 모든 사람이 뒤처지지 않을 것입니다. 만약의 경우죠.</p><p id="39d7">러스트는 우리에게 그만한 가치가 있었나요? 아직 말하기는 이르죠. 저희는 소규모 팀으로 놀라운 일을 해냈지만 엄청난 장애물도 있었습니다. 또한 기술적인 이유도 있었기 때문에 Rust를 더 실용적으로 만들 수 있었습니다.</p><p id="75ff">그만한 가치가 있을까요? 빠르게 반복해야 하는 경우라면 그렇지 않을 수도 있습니다. 범위가 정해져 있거나 초기 비용을 더 흡수할 수 있다면요? 반드시 고려해 보세요. 방탄 소프트웨어를 얻게 될 것입니다. 웹어셈블리에 대한 관심이 매달 높아지면서 완벽한 소프트웨어를 <em>한 번</em> 작성하면 <em>어디에서나</em> 재사용할 수 있다는 전망이 조만간 현실화되고 있습니다.</p></div></div>
      </article>
    </body>
  </html>
  