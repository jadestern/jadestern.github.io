
  <html lang="ko">
    <head>
      <meta charset="utf-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>Next.js vs. Remix - A Developer's Dilemma</title>
      <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
      <script src="//unpkg.com/alpinejs" defer></script>
    </head>
    <body x-data="{ dark: false }" x-bind:data-theme="dark ? 'dark' : 'light'">
      <main class="container">
      	<button x-on:click="dark = !dark" class="contrast outline">Switch Theme</button>
	      <article>
	        <div id="readability-page-1" class="page"><article>
  <p>React 생태계는 웹 개발의 혁신을 약속하는 프레임워크로 가득 찬 분주한 환경입니다. 오늘은 인기 있는 두 가지 경쟁자를 살펴볼 것입니다: 
<a href="https://nextjs.org/">Next.js와</a><a href="https://remix.run/">Remix입니다</a>.</p>

<p>Next.js는 서버 측 렌더링에 사용되는 가장 인기 있는 React 프레임워크 중 하나입니다. 오랜 기간 동안 사용되어 왔으며 개발자에게 필요한 모든 기능을 갖춘 뛰어난 개발자 경험을 제공합니다.</p>

<p>새로이 이 분야에 뛰어든 리믹스는 리액트 라우터의 창립자들이 만든 것으로, 풀스택 개발 접근 방식을 장려하고 몇 가지 혁신적인 기능을 제공합니다.<a href="https://remix.run/blog/oss-remix-dot-run#why-we-are-open-sourcing">2022년에 리믹스가 오픈소스로 출시되면서</a> 개발자들은 애플리케이션에 어떤 프레임워크가 더 적합한지 고민하기 시작했습니다.</p>

<p>두 프레임워크 모두 인상적인 기능과 열정적인 커뮤니티를 자랑하지만, 다음 프로젝트에서는 어떤 프레임워크를 선택해야 할까요?</p>

<p>챔피언을 선택하는 데 도움이 되도록 두 프레임워크의 장단점을 분석해 보겠습니다.</p>

<h2 id="1-routing">1. 라우팅</h2>

<h3 id="nextjs">Next.js</h3>

<p>Next.js에는 <strong>앱 라우터와</strong> <strong>페이지 라우터라는</strong> 두 가지 라우터가 있습니다. 
앱 라우터는 서버 컴포넌트 및 스트리밍과 같은 React의 최신 기능을 사용할 수 있는 최신 라우터입니다. 
페이지 라우터는 서버 렌더링된 React 애플리케이션을 구축할 수 있게 해준 최초의 Next.js 라우터로, 이전 Next.js 애플리케이션에 대해 계속 지원되고 있습니다.</p>

<p>앱 경로의 경우, Next.js 13은 디렉터리 기반 라우팅을 사용하여 <code translate="no">/app</code> 아래에 있는 page.tsx라는 파일이 경로로 빌드됩니다. <code translate="no">app</code> 디렉터리의 폴더에는 레이아웃을 위한<code translate="no">layout.tsx</code>, 해당 경로에 공개적으로 액세스할 수 있도록 하는 <code translate="no">page.tsx</code>, 로딩 상태를 정의하는<code translate="no">loading.tsx</code>, 오류 처리를 위한 <code translate="no">error.tsx</code> 이 포함될 수 있습니다. 중첩 경로를 만들려면 서로 폴더 안에 폴더를 중첩할 수 있습니다.</p>

<p><img data-src="/images/nextjs_remix/nextjs/routing.png" alt="" title="Title" width="700" height="400" src="https://blog.saeloun.com/images/nextjs_remix/nextjs/routing.png">


    <span><i></i></span>
</p>

<p>라우팅</p>

<p>소스: <a href="https://nextjs.org/docs/app/building-your-application/routing#route-segments">Next.js 문서</a></p>

<p>폴더 구조</p>

<p><img data-src="/images/nextjs_remix/nextjs/routing_detail_structure.png" alt="" title="Title" width="700" height="400" src="https://blog.saeloun.com/images/nextjs_remix/nextjs/routing_detail_structure.png">


    <span><i></i></span>
</p>

<p>Source: <a href="https://nextjs.org/docs/app/building-your-application/routing#component-hierarchy">Next.js 문서</a></p>

<h3 id="remix">Remix</h3>

<p>Remix v2는 플랫 파일 기반 라우팅 시스템을 사용합니다. <code translate="no">/app/routes</code> 폴더에서 새 구성 요소를 추가하여 새 경로를 만들 수 있습니다. 중첩된 경로를 만드는 것은 파일 이름에 마침표 구분자(<code translate="no">.</code>)를 사용하여 수행됩니다. 예를 들어 Remix 앱에서 <code translate="no">/concerts/trending</code> 경로를 만들려면 <code translate="no">concerts.trending.tsx</code> 라는 새 파일을 추가합니다.</p>

<p><img data-src="/images/nextjs_remix/remix/routing.png" alt="" title="Title" width="800" height="650" src="https://blog.saeloun.com/images/nextjs_remix/remix/routing.png">


    <span><i></i></span>
</p>

<p>Source: <a href="https://remix.run/docs/en/main/discussion/routes#conventional-route-configuration">Remix 문서</a></p>

<h3 id="point-of-view">관점</h3>

<p>이제 두 프레임워크의 라우팅 메커니즘을 비교해 보면 두 프레임워크 모두 파일 시스템 기반 라우팅이라는 거의 동일한 방향을 선택했으며, 이것이 올바른 방법인 것처럼 느껴집니다.</p>

<p>Remix는 파일/레이아웃을 보기만 해도 어떤 경로를 나타내는지 알 수 있어 더 직관적인 것 같습니다. 하지만 Next.js에 따르면 관련 라우팅 파일을 하나의 폴더에 넣어 각 경로 세그먼트의 로딩/오류 상태를 정의하는 데 도움이 되는 것도 합리적입니다.</p>

<h2 id="2-data-fetching">2. 데이터 불러오기</h2>

<h3 id="nextjs-1">Next.js</h3>

<p>Next.js는 몇 가지 데이터 불러오기 메서드를 제공합니다:</p>

<ol>
  <li><code translate="no">getServerSideProps</code>: 요청할 때마다 서버에서 데이터를 가져옵니다. 클라이언트가 페이지를 요청할 때 데이터를 가져오는 서버 측 렌더링(SSR)에 사용됩니다.</li>
  <li><code translate="no">getStaticProps</code>: 빌드 시 데이터를 가져와서 미리 렌더링된 콘텐츠가 포함된 정적 HTML 페이지를 생성합니다.</li>
  <li><code translate="no">getInitialProps</code>: 서버와 클라이언트 모두에서 실행되며 초기 렌더링 및 클라이언트 측 수화를 위한 데이터 페칭을 지원합니다. 레거시 API입니다.</li>
  <li><code translate="no">fetch</code>: Next.js는 기본 <code translate="no">fetch</code> 웹 API를 확장하여 서버에서 각 가져오기 요청에 대한 캐싱 및 재검증 동작을 구성할 수 있습니다.<code translate="no">fetch</code> async/await을 사용하면 서버 컴포넌트, 라우트 핸들러 및 서버 액션에서 사용할 수 있습니다.</li>
</ol>

<figure><pre translate="no"><code translate="no" data-lang="javascript"><span>async</span> <span>function</span> <span>getUsers</span><span>()</span> <span>{</span>
  <span>const</span> <span>res</span> <span>=</span> <span>await</span> <span>fetch</span><span>(</span><span>'</span><span>https://jsonplaceholder.typicode.com/users</span><span>'</span><span>)</span>
  <span>if </span><span>(</span><span>!</span><span>res</span><span>.</span><span>ok</span><span>)</span> <span>{</span>
    <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'</span><span>Failed to fetch data</span><span>'</span><span>)</span>
  <span>}</span>
  <span>return</span> <span>res</span><span>.</span><span>json</span><span>()</span>
<span>}</span>

<span>export</span> <span>default</span> <span>async</span> <span>function</span> <span>Page</span><span>()</span> <span>{</span>
  <span>const</span> <span>users</span> <span>=</span> <span>await</span> <span>getUsers</span><span>()</span>
  <span>return </span><span>(</span>
    <span>&lt;</span><span>div</span><span>&gt;</span>
      <span>&lt;</span><span>h1</span><span>&gt;</span><span>Users</span><span>&lt;</span><span>/h1</span><span>&gt;
</span>      <span>{</span><span>users</span><span>.</span><span>map</span><span>((</span><span>user</span><span>)</span> <span>=&gt;</span> <span>(</span>
        <span>&lt;</span><span>div</span> <span>key</span><span>=</span><span>{</span><span>user</span><span>.</span><span>id</span><span>}</span><span>&gt;</span><span>{</span><span>user</span><span>.</span><span>name</span><span>}</span><span>&lt;</span><span>/div</span><span>&gt;
</span>      <span>))}</span>
    <span>&lt;</span><span>/div</span><span>&gt;
</span>  <span>);</span>
<span>}</span></code></pre></figure>

<h3 id="remix-1">Remix</h3>

<p>리믹스에서는 로더에서 데이터를 가져옵니다. 각 경로는 렌더링할 때 경로에 관련 데이터를 제공하는 로더 함수를 정의할 수 있습니다. 
<code translate="no">useLoaderData</code> 로더의 데이터를 컴포넌트에 제공합니다. 로더는 서버에서만 실행됩니다.</p>

<figure><pre translate="no"><code translate="no" data-lang="javascript"><span>import</span> <span>{</span> <span>useLoaderData</span> <span>}</span> <span>from</span> <span>"</span><span>@remix-run/react</span><span>"</span><span>;</span>

<span>export</span> <span>const</span> <span>loader</span> <span>=</span> <span>async </span><span>()</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>users</span> <span>=</span> <span>await</span> <span>getUsers</span><span>();</span>
  <span>return</span> <span>json</span><span>({</span> <span>users</span> <span>});</span>
<span>};</span>

<span>export</span> <span>default</span> <span>function</span> <span>Page</span><span>()</span> <span>{</span>
  <span>const</span> <span>users</span> <span>=</span> <span>useLoaderData</span><span>&lt;</span><span>typeof</span> <span>loader</span><span>&gt;</span><span>();</span>
  <span>return </span><span>(</span>
    <span>&lt;</span><span>div</span><span>&gt;</span>
      <span>&lt;</span><span>h1</span><span>&gt;</span><span>Users</span><span>&lt;</span><span>/h1</span><span>&gt;
</span>      <span>{</span><span>users</span><span>.</span><span>map</span><span>((</span><span>user</span><span>)</span> <span>=&gt;</span> <span>(</span>
        <span>&lt;</span><span>div</span> <span>key</span><span>=</span><span>{</span><span>user</span><span>.</span><span>id</span><span>}</span><span>&gt;</span><span>{</span><span>user</span><span>.</span><span>name</span><span>}</span><span>&lt;</span><span>/div</span><span>&gt;
</span>      <span>))}</span>
    <span>&lt;</span><span>/div</span><span>&gt;
</span>  <span>);</span>
<span>}</span></code></pre></figure>

<h3 id="point-of-view-1">관점</h3>

<p>Next.js는 유연성과 사용자 정의가 우선시되는 정적 콘텐츠와 동적 콘텐츠가 혼합된 애플리케이션에 이상적인 것으로 보입니다. 
Remix의 데이터 불러오기 방식을 사용하면 데이터 로딩과 종속성을 보다 세밀하게 제어할 수 있습니다.</p>

<h2 id="3-data-mutations">3. 데이터 변형</h2>

<p>변형을 처리할 때는 백엔드 서버로 API 요청을 보낸 다음 변경 사항을 반영하도록 로컬 상태를 업데이트하는 방식으로 처리하는 경우가 많습니다.</p>

<p>두 프레임워크 모두 변이 처리를 핵심 기능에 직접 통합하여 변이 처리를 혁신하는 것을 목표로 합니다.</p>

<h3 id="nextjs-2">Next.js</h3>

<p>Next.js 13.4 이전에는 서버에서 작업을 생성하고 수행하는 유일한 방법은 API 경로를 만들고 상태를 업데이트하는 것이었습니다.</p>

<p>Next.js 13.4에서는 데이터 변형을 처리하는 서버 액션을 도입하여 개발자 환경을 간소화하고 사용자 환경을 개선했습니다.</p>

<p>// API 경로 사용</p>

<figure><pre translate="no"><code translate="no" data-lang="javascript"><span>export</span> <span>default</span> <span>function</span> <span>Page</span><span>()</span> <span>{</span>
  <span>async</span> <span>function</span> <span>onSubmit</span><span>(</span><span>event</span><span>:</span> <span>FormEvent</span><span>&lt;</span><span>HTMLFormElement</span><span>&gt;</span><span>)</span> <span>{</span>
    <span>event</span><span>.</span><span>preventDefault</span><span>();</span>
 
    <span>const</span> <span>formData</span> <span>=</span> <span>new</span> <span>FormData</span><span>(</span><span>event</span><span>.</span><span>currentTarget</span><span>);</span>
    <span>const</span> <span>response</span> <span>=</span> <span>await</span> <span>fetch</span><span>(</span><span>'</span><span>/api/submit</span><span>'</span><span>,</span> <span>{</span>
      <span>method</span><span>:</span> <span>'</span><span>POST</span><span>'</span><span>,</span>
      <span>body</span><span>:</span> <span>formData</span><span>,</span>
    <span>});</span>
 
    <span>// Handle response if necessary</span>
    <span>const</span> <span>data</span> <span>=</span> <span>await</span> <span>response</span><span>.</span><span>json</span><span>();</span>
    <span>// ...</span>
  <span>}</span>
 
  <span>return </span><span>(</span>
    <span>&lt;</span><span>form</span> <span>onSubmit</span><span>=</span><span>{</span><span>onSubmit</span><span>}</span><span>&gt;</span>
      <span>&lt;</span><span>input</span> <span>type</span><span>=</span><span>"</span><span>text</span><span>"</span> <span>name</span><span>=</span><span>"</span><span>name</span><span>"</span> <span>/&gt;</span>
      <span>&lt;</span><span>button</span> <span>type</span><span>=</span><span>"</span><span>submit</span><span>"</span><span>&gt;</span><span>Submit</span><span>&lt;</span><span>/button</span><span>&gt;
</span>    <span>&lt;</span><span>/form</span><span>&gt;
</span>  <span>);</span>
<span>}</span></code></pre></figure>

<p>// 서버 액션 사용</p>

<figure><pre translate="no"><code translate="no" data-lang="javascript"><span>export</span> <span>default</span> <span>function</span> <span>Page</span><span>()</span> <span>{</span>
  <span>async</span> <span>function</span> <span>create</span><span>(</span><span>formData</span><span>:</span> <span>FormData</span><span>)</span> <span>{</span>
    <span>'</span><span>use server</span><span>'</span><span>;</span>
    <span>const</span> <span>id</span> <span>=</span> <span>await</span> <span>createItem</span><span>(</span><span>formData</span><span>);</span>
  <span>}</span>
 
  <span>return </span><span>(</span>
    <span>&lt;</span><span>form</span> <span>action</span><span>=</span><span>{</span><span>create</span><span>}</span><span>&gt;</span>
      <span>&lt;</span><span>input</span> <span>type</span><span>=</span><span>"</span><span>text</span><span>"</span> <span>name</span><span>=</span><span>"</span><span>name</span><span>"</span> <span>/&gt;</span>
      <span>&lt;</span><span>button</span> <span>type</span><span>=</span><span>"</span><span>submit</span><span>"</span><span>&gt;</span><span>Submit</span><span>&lt;</span><span>/button</span><span>&gt;
</span>    <span>&lt;</span><span>/form</span><span>&gt;
</span>  <span>);</span>
<span>}</span></code></pre></figure>

<p><a href="https://nextjs.org/blog/next-14#forms-and-mutations">Next.js 14 폼 및 변</a>이에서 가져온 예제</p>

<h3 id="remix-2">Remix</h3>

<p>리믹스는 UI를 영구 서버 상태와 자동으로 동기화합니다. 
이는 세 단계로 이루어집니다:</p>

<ol>
  <li>라우팅 로더가 UI에 데이터 제공</li>
  <li>폼이 영구 상태를 업데이트하는 라우팅 액션에 데이터를 게시합니다.</li>
  <li>페이지의 로더 데이터가 자동으로 재검증됩니다.</li>
</ol>

<p><img data-src="/images/nextjs_remix/remix/remix-fullstack-data-flow.png" alt="" title="Title" width="500" height="400" src="https://blog.saeloun.com/images/nextjs_remix/remix/remix-fullstack-data-flow.png">


    <span><i></i></span>
</p>

<p>Remix는 사용자가 작업을 수행하는 애플리케이션의 모든 부분을 HTML 양식으로 유지하도록 권장합니다.  사용자가 양식 제출을 트리거할 때마다 액션을 호출합니다. 
액션이 실행되면 Remix는 브라우저 불러오기 요청을 통해 해당 경로에 대한 모든 로더를 다시 불러오고 UI를 새로고침하여 UI가 항상 데이터베이스와 동기화 상태를 유지하도록 합니다. 
이를 Remix의 "풀스택 데이터 흐름"이라고 합니다.</p>

<figure><pre translate="no"><code translate="no" data-lang="javascript"><span>export</span> <span>async</span> <span>function</span> <span>loader</span><span>({</span>
  <span>request</span><span>,</span>
<span>}:</span> <span>LoaderFunctionArgs</span><span>)</span> <span>{</span>
  <span>const</span> <span>user</span> <span>=</span> <span>await</span> <span>getUser</span><span>(</span><span>request</span><span>);</span>
  <span>return</span> <span>json</span><span>({</span>
    <span>displayName</span><span>:</span> <span>user</span><span>.</span><span>displayName</span><span>,</span>
    <span>email</span><span>:</span> <span>user</span><span>.</span><span>email</span><span>,</span>
  <span>});</span>
<span>}</span>

<span>export</span> <span>default</span> <span>function</span> <span>Component</span><span>()</span> <span>{</span>
  <span>const</span> <span>user</span> <span>=</span> <span>useLoaderData</span><span>&lt;</span><span>typeof</span> <span>loader</span><span>&gt;</span><span>();</span>
  <span>return </span><span>(</span>
    <span>&lt;</span><span>Form</span> <span>method</span><span>=</span><span>"</span><span>post</span><span>"</span> <span>action</span><span>=</span><span>"</span><span>/account</span><span>"</span><span>&gt;</span>
      <span>&lt;</span><span>h1</span><span>&gt;</span><span>Settings</span> <span>for</span> <span>{</span><span>user</span><span>.</span><span>displayName</span><span>}</span><span>&lt;</span><span>/h1</span><span>&gt;
</span>
      <span>&lt;</span><span>input</span>
        <span>name</span><span>=</span><span>"</span><span>displayName</span><span>"</span>
        <span>defaultValue</span><span>=</span><span>{</span><span>user</span><span>.</span><span>displayName</span><span>}</span>
      <span>/</span><span>&gt;
</span>      <span>&lt;</span><span>input</span> <span>name</span><span>=</span><span>"</span><span>email</span><span>"</span> <span>defaultValue</span><span>=</span><span>{</span><span>user</span><span>.</span><span>email</span><span>}</span> <span>/</span><span>&gt;
</span>
      <span>&lt;</span><span>button</span> <span>type</span><span>=</span><span>"</span><span>submit</span><span>"</span><span>&gt;</span><span>Save</span><span>&lt;</span><span>/button</span><span>&gt;
</span>    <span>&lt;</span><span>/Form</span><span>&gt;
</span>  <span>);</span>
<span>}</span>

<span>export</span> <span>async</span> <span>function</span> <span>action</span><span>({</span>
  <span>request</span><span>,</span>
<span>}:</span> <span>ActionFunctionArgs</span><span>)</span> <span>{</span>
  <span>const</span> <span>formData</span> <span>=</span> <span>await</span> <span>request</span><span>.</span><span>formData</span><span>();</span>
  <span>const</span> <span>user</span> <span>=</span> <span>await</span> <span>getUser</span><span>(</span><span>request</span><span>);</span>

  <span>await</span> <span>updateUser</span><span>(</span><span>user</span><span>.</span><span>id</span><span>,</span> <span>{</span>
    <span>email</span><span>:</span> <span>formData</span><span>.</span><span>get</span><span>(</span><span>"</span><span>email</span><span>"</span><span>),</span>
    <span>displayName</span><span>:</span> <span>formData</span><span>.</span><span>get</span><span>(</span><span>"</span><span>displayName</span><span>"</span><span>),</span>
  <span>});</span>

  <span>return</span> <span>json</span><span>({</span> <span>ok</span><span>:</span> <span>true</span> <span>});</span>
<span>}</span></code></pre></figure>

<p>이 예제는 <a href="https://remix.run/docs/en/main/discussion/data-flow#route-action">Remix 경로 액션 문서에서</a> 가져온 것입니다.</p>

<h3 id="point-of-view-2">관점</h3>

<ol>
  <li>Next.js 서버 액션은 React 에코시스템 및 React의 APIS와 연결되어 있는 반면, Remix는 웹 플랫폼에서 구현되며 웹이 작동하는 방식과 밀접하게 연관되어 있습니다.</li>
  <li>Next.js 액션은 컴포넌트 중심입니다. 반면 Remix 액션은 경로 중심이므로 컴포넌트만큼 컴포짓할 수 없습니다.</li>
  <li>Next.js에서는 경로를 재검증하도록 수동으로 지시해야 하는 반면 Remix는 자동으로 재검증을 수행합니다.</li>
</ol>

<p>이는 Next.js와 Remix의 장단점이며, 우리는 어느 것을 사용할 수 있고 어느 것이 필요한지 결정하고 그에 따라 결정할 수 있습니다.</p>

<h2 id="4-error-handling">4. 오류 처리</h2>

<p>Next.js와 Remix는 모두 웹 애플리케이션에서 오류를 우아하게 처리하는 메커니즘을 제공합니다.</p>

<h3 id="nextjs-3">Next.js</h3>

<p>각 경로 세그먼트에는 해당 경로의 오류 상태를 렌더링하기 위한 별도의 <code translate="no">error.js</code> 파일이 있습니다. error.js 파일 규칙을 사용하면 경로 세그먼트와 그 중첩된 자식을 React Error Boundary로 자동 래핑하여 중첩된 경로에서 예기치 않은 런타임 오류를 우아하게 처리할 수 있습니다. 서버나 브라우저에서 발생할 수 있는 예상치 못한 오류와 404와 같은 예상 오류 모두 처리할 수 있습니다.</p>

<h3 id="remix-3">Remix</h3>

<p>경로 세그먼트의 오류 상태를 렌더링하려면 <code translate="no">ErrorBoundary</code> 을 내보내면 됩니다. 서버나 브라우저에서 발생할 수 있는 예기치 않은 오류와 404와 같은 예상 오류를 모두 처리합니다.</p>



<h3 id="nextjs-4">Next.js</h3>

<p>Next.js는 118k⭐(작성 시점 기준)의 GitHub 별을 받은 잘 정립된 프레임워크입니다. 
대규모 커뮤니티와 에코시스템을 갖추고 있어 문제, 플러그인 또는 통합에 대한 해결책을 찾을 때 큰 이점이 있습니다.</p>

<h3 id="remix-4">Remix</h3>

<p>Remix는 약 26.6만 개의 GitHub 별(작성 시점 기준)을 보유하고 있으며 커뮤니티가 성장하고 있습니다.</p>

<h3 id="point-of-view-3">관점</h3>

<p>애플리케이션이 복잡하지 않고 커뮤니티의 도움이 많이 필요하지 않은 경우 Remix를 선호합니다. 애플리케이션에 더 광범위한 기능과 대규모 사용자 커뮤니티가 있는 프레임워크가 필요한 경우 Next.js가 좋은 선택입니다.</p>

<h2 id="6-learning-curve">6. 학습 곡선</h2>

<h3 id="nextjs-5">Next.js</h3>

<p>비교적 배우기 어렵습니다. 선택의 폭이 넓고 개발자가 올바르게 사용하지 않으면 낮은 수준의 제어가 과도할 수 있습니다.</p>

<h3 id="remix-5">Remix</h3>

<p>비교적 간단합니다. 
한 가지 방법만 제공하고 많은 것을 추상화합니다.</p>

<h2 id="7-deployment">7. 배포</h2>

<h3 id="nextjs-6">Next.js</h3>

<p>Next.js를 배포하는 것은 훌륭한 플랫폼인 Vercel 외부에서는 어려울 수 있지만 인프라가 AWS에 있는 경우 이상적이지 않을 수 있습니다. 
AWS 계정에서 Next.js를 호스팅하면 백엔드와의 통합이 더 쉬워지고 Vercel보다 비용 효율성이 더 높은 경우가 많습니다. 
Next.js는 서버리스 자체 호스팅을 기본적으로 지원하지 않지만 노드 애플리케이션으로 실행할 수 있습니다. 
그러나 이 접근 방식은 Vercel을 사용하는 것과 같은 이점을 제공하지 못할 수도 있습니다.</p>

<p>다행히도 새로운 오픈 소스 Next.js 서버리스 어댑터인 OpenNext가 있습니다. 
이 어댑터는 Next.js 빌드 출력을 가져와서 모든 서비스형 기능(FaaS) 플랫폼에 배포할 수 있는 패키지로 변환하여 배포를 보다 유연하게 만듭니다.</p>

<p>켄트 도즈는<a href="https://www.epicweb.dev/why-i-wont-use-nextjs">자신의 블로그에서 이 배포에 대한 우려를</a> 표명하고 있습니다.</p>

<h3 id="remix-6">Remix</h3>

<p>Remix는 자바스크립트 실행을 지원하는 모든 플랫폼에 배포할 수 있도록 설계되었습니다. 
이는 주로 표준에 중점을 두었기 때문입니다.</p>

<h2 id="8-pricing">8. 가격</h2>

<h3 id="nextjs-7">Next.js</h3>

<p>Vercel의 가격은 많은 사람들에게 큰 문제인 것 같습니다. 고려해야 할 중요한 포인트가 될 수 있습니다.</p>

<blockquote><div lang="en" dir="ltr"><p>저희는 이전하고자 하는 정적 자산 애플리케이션에 대해서만 ▲ (엔터프라이즈 티어의 경우 15만 달러 거부 후) 4만 달러의 견적을 받았습니다.</p><p>현재 클라우드프론트의 월별 청구서입니다: 12$</p></div>- 잭커리 그리싱어 (@zackerydev) <a href="https://twitter.com/zackerydev/status/1717556827569660378?ref_src=twsrc%5Etfw">October 26, 2023</a></blockquote>


<p>그러나 Vercel의 제품 부사장 Lee Rob은 자신의 <a href="https://leerob.io/blog/using-nextjs">게시물에서 가격 책정을 개선하기 위해 노력하고</a> 있다고 언급했습니다.</p>

<h3 id="remix-7">Remix</h3>

<p>리믹스는 자바스크립트 실행을 지원하는 모든 플랫폼에 배포할 수 있기 때문에 원하는 대로 플랫폼을 자유롭게 선택할 수 있습니다.</p>

<h2 id="9-partnership-with-big-brands">9. 대형 브랜드와의 파트너십</h2>

<h3 id="nextjs-8">Next.js</h3>

<p>Next.js는 Vercel에서 유지 관리합니다. React 팀은 React 서버 컴포넌트와 같은 새로운 기능을 출시하기 위해 Next.js 팀과 긴밀히 협력하고 있습니다.</p>

<h3 id="remix-8">Remix</h3>

<p>Remix가 2022년에 Shopify와 협력 관계를 맺었습니다! Shopify의 관리 하에, Remix는 커머스 분야의 확고한 리더로부터 장기적인 지원과 후원을 받게 됩니다.</p>

<h2 id="10-companies">10. 기업</h2>

<h3 id="nextjs-9">Next.js</h3>

<ol>
  <li><a href="https://jobs.netflix.com/">넷플릭스 채용</a></li>
  <li><a href="https://www.tiktok.com/about">TikTok</a></li>
  <li><a href="https://notion.com/">Notion</a></li>
  <li><a href="https://vercel.com/customers/loom-headless-with-nextjs">Loom</a></li>
</ol>

<p>자세한 목록은 <a href="https://nextjs.org/showcase">여기에서</a> 확인할 수 있습니다.</p>

<h3 id="remix-9">Remix</h3>

<ol>
  <li><a href="https://github.com/nasa-gcn/gcn.nasa.gov">NASA</a></li>
  <li><a href="https://twitter.com/remix_run/status/1706741495708238013">Docker</a> - 개발자가 모든 리포지토리의 취약점을 신속하게 식별하고 수정할 수 있도록 설계된 통합 컨테이너 보안 솔루션인 Docker Scout입니다,</li>
  <li><a href="https://www.shopify.com/">Shopify</a></li>
  <li><a href="https://marmelab.com/react-admin/Remix.html">react-admin</a> - 비공개 npm 레지스트리 및 엔터프라이즈 사용자 대시보드를 제공합니다.</li>
</ol>

<p>자세한 목록은 <a href="https://remix.run/showcase">여기에서</a> 확인할 수 있습니다.</p>

<p>그렇다면 누가 왕관을 차지할까요?</p>

<p>우승자는...</p>

<p>동점입니다! Next.js와 Remix는 모두 다른 영역에서 탁월합니다.</p>

<p>그러나 "최고의" 프레임워크는 프로젝트의 고유한 요구사항에 따라 달라집니다:</p>

<p>대상: 대규모 프로젝트, 풍부한 기능의 프레임워크, 광범위한 지원을 통한 빠른 성공 - Next.js가 챔피언이 될 수 있습니다.</p>

<p>대상: 성능에 중요한 프로젝트, 원활한 사용자 경험, 덜 복잡한 문제 해결, 최신 접근 방식을 탐색하려는 의지가 있는 경우 - Remix가 적합할 수 있습니다.</p>

<p><strong>기억하세요:</strong></p>

<p>두 프레임워크 모두 활발한 커뮤니티와 성장하는 리소스 풀을 자랑하며, 직접 실험하는 것이 핵심입니다. 각각의 프레임워크로 소규모 프로젝트를 구축하여 자신에게 맞는 것을 찾아보세요. 팀의 기술과 선호도가 중요합니다. 
팀의 개발 스타일에 맞는 프레임워크를 선택하세요.</p>

<p>행복한 코딩!</p>

</article></div>
	      </article>
			</main>
    </body>
  </html>
  