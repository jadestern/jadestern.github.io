
  <html lang="ko">
    <head>
      <meta charset="utf-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>htmx: Big Wins for State Management - w3ird0h - Medium</title>
      <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
      <script src="//unpkg.com/alpinejs" defer></script>
    </head>
    <body x-data="{ dark: false }" x-bind:data-theme="dark ? 'dark' : 'light'">
      <main class="container">
      	<button x-on:click="dark = !dark" class="contrast outline">Switch Theme</button>
	      <article>
	        <div id="readability-page-1" class="page"><div><p id="f5ce">제 생각은 새로운 것이 아니라 업계에서 다른 사람들이 인정한 것과 비슷합니다... 그리고 제가 주의를 기울이는 한 아직 새로운 것을 듣지 못했습니다...</p><p id="9ea3">"아직 새로운 것을 듣지 못했다"는 말은 제가 이 기술을 파고들 때, 이 기술로 어떤 경계를 넘나들어야 하는지 알고 테스트할 수 있는 것이 무엇인지 생각한다는 것은 제 연구에서 아직 분명하게 놓치고 있는 것이 없다는 것을 의미하기 때문에 중요하다고 생각합니다.</p><p id="dc1d">이 기술과 기법은 획기적인 것은 아니지만 현재 추진력을 얻고 있습니다. 워터쿨러에서 흔히 들을 수 있는 "이제 서버로 돌아가는 거죠?"라는 말을 들을 수 있을 정도입니다(그런 말이 더 이상 존재하나요? 저는 사무실에 간 지 4년이 지났어요).</p><blockquote><p id="cf7e">이 기술의 가장 큰 장점은 브라우저로 전송되는 애플리케이션의 상태 관리가 간소화된다는 점입니다.</p></blockquote><p id="77fa"><strong>클라이언트에서 </strong>무엇을 표시할지 알기 위해 더 이상 로직을 중복하거나 상태를 관리할 필요가 없기 때문에 웹 애플리케이션 상태 관리를 위한 인지 부하와 코드 줄을 획기적으로 줄일 수 있습니다. 또한 클라이언트가 만족할 수 있는 쾌적한 DX를 제공합니다.</p><p id="8884">개발 시간 절약, 제품 시간 절약, 회의 횟수 감소로 인한 시간 절약, 학습 필요성 감소(초기 장애물을 뛰어넘어 htmx를 제대로 사용하는 방법을 이해해야 하기 때문에) 등입니다. 서버에서 html 조각을 생성하는 데 여전히 React 같은 것을 사용할 수도 있지만 레이어 간 상태 동기화의 복잡성을 줄일 수 있습니다. 저는 기본적으로 그런 일(상태 관리)에 능숙하기 때문에 수년 동안 생계를 유지하고 가족을 먹여 살렸고, 웹 개발의 생산성을 훨씬 더 높일 수 있는 훌륭한 잠재력을 가지고 있습니다.</p><blockquote><p id="1a5c">리액트/앵귤러/뷰 등을 배울 필요가 없다고 상상해 보세요. 페이지에 올바른 것을 표시하기 위해 redux, 후크, vuex, ngrx 등을 배울 필요가 없습니다.</p></blockquote><p id="8f73">예를 들어보겠습니다:</p><p id="77bb">사용자에게 삭제 버튼을 표시해야 한다고 상상해 보세요.</p><p id="fe98">SPA에서는 다음과 <em>같이</em> 표시됩니다:</p><ul><li id="38e6">이미 컴포넌트가 로드되는 경로에 있다고 가정합니다.</li><li id="cd18">컴포넌트가 로드될 때 목록을 로드하기 위한 API 요청이 이루어질 수 있습니다.</li><li id="02e8">서버는 요청을 수신하고, 목록 집합을 클라이언트로 전송하기 위해 JSON을 작성하며, 여기에는 일부 항목에 <code translate="no">canDelete</code> 같은 것이 포함되어 <strong>있으므로 클라이언트에게 삭제 버튼이 표시되어야 하는지 파악하는 작업을 수행합니다</strong>.</li><li id="3106">클라이언트는 응답을 수신하고, 데이터가 상태 트리의 더 높은 곳에 저장되어 있거나 로컬일 수도 있는 데이터를 처리합니다.</li><li id="a4b8">클라이언트는 컴포넌트의 데이터를 처리하여 HTML을 작성하고 <code translate="no">canDelete</code> 프롭을 사용하여 <code translate="no">delete</code> 버튼을 작성할지 여부를 이해합니다... <strong>그래서 우리는 클라이언트에게 삭제 버튼이 표시되어야 하는지 이해하기 위해 작업합니다</strong>.</li></ul><p id="8552">HTML5에서는 다음과 같이 진행됩니다:</p><ul><li id="4869">데이터를 가져오기 위해 트리거할 HTML 요소 설정</li><li id="9eae">서버가 HTML을 빌드하여 클라이언트로 전송합니다.</li><li id="1468">htmx는 우리가 지시한 위치에 HTML을 배치합니다.</li></ul><p id="5938">htmx land에서 하지 <strong>않는</strong> 작업은 다음과 같습니다:</p><ul><li id="7feb">SPA 선택 또는 학습에 대한 관심</li><li id="2829">선택한 SPA와 잘 작동하는 상태 관리 기법을 선택하거나 학습하는 데 신경을 씁니다.</li><li id="afe6">나중에 클라이언트에서 사용할 수 있도록 데이터 저장(가능)</li><li id="7919">이미 서버에서 HTML을 작성하여 유선으로 전송했으므로 클라이언트에서 <code translate="no">canDelete?</code> 로직을 복제합니다.</li></ul><p id="7329">처음 이 기술을 접했을 때는 유동적인 느낌의 매력적인 인터랙티브 웹 애플리케이션이라는 과제를 해결하지 못할 어린애 같은 프로젝트라고 생각했지만, 정말 뛰어난 예제를 보고 나서는 흥미를 갖게 되었습니다.</p><p id="c2ea">현재 프런트엔드 환경에 이러한 기술과 경쟁업체가 등장하기 시작했고, 앞으로 파급력이 커져 이와 같은 기술이 대중적으로 채택될 것으로 예상됩니다. 우리는 지금 대량 채택 전 단계에 있으며, 관련 툴이 급증할 것입니다. 우리는 형편없는 블로그 게시물과 튜토리얼에 무릎을 꿇게 될 것입니다. 생계가 걸린 일이니까요.</p><p id="3803">Tailwind는 htmx와 함께 사용량이 증가할 것이라고 생각합니다.</p><p id="907d">한 친구가 "대부분의 조직은 React/Angular와 같이 정말 복잡한 것을 사용하여 구축하고자 하는 욕구가 있을 것"이라고 공유했는데, 저도 동의합니다. 직장에서 이 기술을 도입하려면 상당한 노력이 필요하며 실행 가능성을 확인하기 위한 구체적인 사례가 필요합니다.</p><p id="b731">더미 시나리오를 구성하여 그 효과를 보여주고 한계까지 밀어붙이는 프로젝트를 수행하는 것이 도움이 될 수 있으며, 아마도 제가 연구에 접근하는 한 가지 방법일 것입니다.</p><p id="2438">이 기술을 중심으로 성장하는 커뮤니티의 의도는 JS 사용을 완전히 없애는 것이 아니라, JS의 보급을 줄이고 타당성이 있을 때 활용하자는 것이라고 생각합니다.</p><p id="083a">이 프로젝트에 기회를 주셔야 합니다. 그럴 겁니다.</p></div></div>
	      </article>
			</main>
    </body>
  </html>
  