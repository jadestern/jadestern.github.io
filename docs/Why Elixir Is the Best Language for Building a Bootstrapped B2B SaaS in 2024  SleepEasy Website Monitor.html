
  <html lang="ko">
    <head>
      <meta charset="utf-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>Why Elixir Is the Best Language for Building a Bootstrapped, B2B SaaS in 2024 | SleepEasy Website Monitor</title>
      <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
      <script src="//unpkg.com/alpinejs" defer></script>
    </head>
    <body x-data="{ dark: false }" x-bind:data-theme="dark ? 'dark' : 'light'">
      <main class="container">
      	<button x-on:click="dark = !dark" class="contrast outline">Switch Theme</button>
	      <article>
	        <div id="readability-page-1" class="page"><div>
      <div>
<h3>내용</h3>
<ol>
    <li><a href="#who-cares-about-one-person-frameworks">1인 프레임워크에 누가 신경 쓰나요?</a></li>
    <li><a href="#how-elixir-collapses-a-web-apps-tech-stack">Elixir가 웹 앱의 기술 스택을 축소하는 방법</a>     <ol>
            <li><a href="#removing-layers-of-the-stack">스택의 레이어 제거하기</a></li>
            <li><a href="#building-more-of-the-stack-into-the-platform-itself">플랫폼 자체에 더 많은 스택 구축하기</a></li>
            <li><a href="#building-more-of-the-stack-using-tools-you-already-know">이미 알고 있는 도구를 사용하여 더 많은 스택 구축하기</a></li>
            <li><a href="#whats-it-add-up-to">무엇을 더할 수 있을까요?</a></li>
        </ol>
    </li>
    <li><a href="#a-few-other-accelerators-for-saas-startups">SaaS 스타트업을 위한 몇 가지 다른 액셀러레이터</a>       <ol>
            <li><a href="#buying-a-200-hour-head-start">200시간 먼저 시작하기</a></li>
            <li><a href="#consuming-openapi-specifications-with-grace">OpenAPI 사양을 여유롭게 사용하기</a></li>
            <li><a href="#maintainability-over-time">시간이 지남에 따른 유지 관리 가능성</a></li>
            <li><a href="#wrapping-up">마무리</a></li>
        </ol>
    </li>
    <li><a href="#appendix-breakdown-of-elixirs-answer-for-common-web-dev-requirements">부록: 일반적인 웹 개발 요구 사항에 대한 Elixir의 답변 분석</a></li>
    <li><a href="#footnotes">각주</a></li>
</ol>
</div>

<p>[이 글은 CodeBEAM America 2024의 <a href="https://codebeamamerica.com/talks/elixir-is-the-one-person-stack/">프레젠테이션인</a> '소프트웨어 스타트업을 위한 1인용 스택, Elixir'의 보조 자료입니다. <a href="https://www.sleepeasy.app/assets/files/elixir-one-person-stack-software-startup-codebeam.pdf">슬라이드를 PDF로 다운로드하거나</a> <a href="https://docs.google.com/presentation/d/11aRQTWI-Jqenmqe66rMuWWcy_VhMHN5x-dzm7sAW7ac/edit#slide=id.g2b1888d014f_0_27">Google 슬라이드에서 볼</a> 수 있습니다.]</p>

<p>SleepEasy의 프로그래밍 언어(그리고 앞으로 설명할 전체 스택)로 Elixir를 선택한 이유를 공유하고자 합니다. 저는 이 언어가 소프트웨어 비즈니스를 시작하는 소규모의 민첩한 팀에 특히 적합하다는 객관적인 특징에 초점을 맞추기 위해 최선을 다하겠습니다.</p>

<p>SleepEasy는 B2B 소프트웨어이므로 웹 앱이 반드시 필요합니다. 먼 미래의 어느 시점에는 모바일 앱도 필요할 수 있지만, 당분간은 모바일 없이도 잘 지낼 수 있을 것으로 예상합니다. 언젠가 모바일 앱이 필요하게 되더라도 웹 보기에 대한 간단한 래퍼로 충분할 것입니다.</p>

<p>제가 이 회사를 부트스트랩(자체 자금으로 창업하고 자체 수익으로만 회사를 성장시키는 것)하고 있다는 사실은 또 하나의 중요한 요구 사항을 설정합니다. 적어도 처음 몇 년 동안 또는 월 수익이 1만 달러 이상인 경우 한 명의 팀에서 앱을 구축하고 유지 관리할 수 있어야 한다는 것입니다.</p>



<h2 id="who-cares-about-one-person-frameworks">1인 프레임워크에 누가 신경을 쓰나요?</h2>





<p>풀스택 개발자 채용 공고를 보면 얼마나 많은 분야에 대한 전문 지식이 요구되는지 생각해 보세요. 모든 고용주는 유니콘을 찾으려고 노력합니다:</p>

<figure>
<img width="280px" src="https://www.sleepeasy.app/assets/images/tom-and-jerry-orchestra.gif" alt="Jerry, of Tom and Jerry, playing a dozen orchestra instruments at once">
<p>그림: 하나의 웹 앱을 구축하기 위해 24개의 도구를 조율하는 풀스택 개발자</p>
</figure>

<ul>
  <li>HTML</li>
  <li>CSS</li>
  <li>Tailwind</li>
  <li>프론트엔드 언어(자바스크립트/타입스크립트)</li>
  <li>백엔드 언어(Ruby, Python, Go 등)</li>
  <li>프런트엔드 프레임워크(React, Vue 등)</li>
  <li>프런트엔드 상태 관리 프레임워크(Redux, Jotai, Vuex 등)</li>
  <li>백엔드 프레임워크</li>
  <li>REST</li>
  <li>GraphQL</li>
  <li>SQL 데이터베이스</li>
  <li>NoSQL 데이터베이스</li>
  <li>백그라운드 작업 시스템</li>
  <li>Redis와 같은 인메모리 캐시</li>
  <li>서비스 충돌 복구 시스템(PM2, Upstart 등)</li>
  <li>메시지 큐(RabbitMQ, Redis 등)</li>
  <li>Nginx와 같은 웹 서버</li>
  <li>Docker</li>
  <li>Kubernetes</li>
  <li>클라우드 플랫폼(AWS, GCP, Azure)</li>
  <li>서버리스</li>
  <li>마이크로서비스</li>
  <li>서비스 확장</li>
</ul>

<p>🥴</p>

<p>너무 많습니다! 한 사람이 모든 것을 다 할 수 있기를 기대하는 것은 합리적이지 않습니다. 고객 개발, 마케팅, 영업 및 비즈니스의 다른 모든 부분을 책임져야 하는 1인 소프트웨어 회사를 시작하는 사람에게는 두 배로 <em>더</em> 그렇습니다.</p>

<p>이 모든 것이 피할 수 없는 결론으로 이어집니다:</p>

<blockquote>
  <p><strong>스택을 축소해야 합니다!</strong></p>
</blockquote>

<p>동급 최고의 웹 앱을 구축하기 위해 배워야 하는 다양한 기술의 수를 <em>획기적으로</em> 줄여야 합니다. 이것이 바로 Elixir(특히 Elixir와 Phoenix 웹 프레임워크)가 필요한 이유입니다.</p>

<h2 id="how-elixir-collapses-a-web-apps-tech-stack">Elixir가 웹 앱의 기술 스택을 축소하는 방법</h2>

<p>Elixir는 크게 세 가지 방법으로 웹 애플리케이션 개발을 간소화합니다.</p>

<ol>
  <li>스택의 레이어를 완전히 제거하기</li>
  <li>언어, 표준 라이브러리 또는 Erlang의 BEAM + OTP <a href="#footnote-1" id="footnote-1-source">플랫폼¹에</a> 더 많은 스택을 구축합니다.</li>
  <li>이미 알고 있는 도구에서 더 많은 스택 빌드하기</li>
</ol>

<p>설명해 드리겠습니다...</p>

<h3 id="removing-layers-of-the-stack">스택의 레이어 제거하기</h3>

<p><a href="https://github.com/phoenixframework/phoenix_live_view">피닉스 라이브뷰는</a> 많은 관심을 <a href="#footnote-2-source" id="footnote-2">받아왔으며²</a>, 그럴 만한 이유가 있습니다. '백엔드' <em>코드만</em> 작성하면서 풍부한 인터랙티브 클라이언트 측 경험(React나 Vue와 같은 SPA 프레임워크에 필적하는)을 만들 수 있다는 점이 매력적입니다. Phoenix의 뛰어난 웹소켓 지원을 기반으로 LiveView는 다음과 같은 기능을 제공합니다:</p>

<ul>
  <li>SPA와 유사한 페이지 전환(즉, 전체 페이지를 다시 로드하지 않고 변경되는 페이지 부분만 교체),</li>
  <li>백엔드에서 상태가 변경될 때 클라이언트 측 뷰의 실시간 "반응형" 업데이트, 그리고</li>
  <li>API를 구성하거나 JavaScript를 작성할 필요 없이 서버 상호 작용이 가능합니다.</li>
</ul>

<p>그리고 이 모든 기능이 거의 무료로 제공됩니다. 50밀리초 미만의 매끄러운 페이지 전환? 코드 0줄이면 됩니다.  프론트엔드에서 백엔드 이벤트를 트리거하고 싶으신가요? 3~4줄의 코드. 백엔드 작업의 업데이트를 진행하기 위해 프론트엔드를 구독하시나요? 4~6줄의 코드.</p>

<p>물론 주의할 점이 있습니다. LiveView는 자체적으로 상당한 학습 곡선을 가지고 있으며, 근본적으로 문서화되지 않은 것을 구축하려고 시도하는 것은 권장하지 않습니다. ( <a href="https://felt.com/">Felt를</a> WebSocket을 통해 Phoenix 백엔드와 통신하는 SPA로 구축한 이유가 여기에 있습니다.) 하지만 다시 말하지만, B2B SaaS를 구축하는 경우 95%의 경우 제품은 관리 대시보드, CRUD 앱 또는 이커머스 플랫폼으로 귀결됩니다... 다음 단계의 Figma가 아닙니다.</p>

<p>라이브뷰가 자바스크립트를 100% 대체했나요? 물론 아닙니다. 하지만 다행히도 '후크'를 지원하므로 앱의 나머지 부분은 Elixir에 유지하면서 일부 기능을 클라이언트 측 JavaScript(SPA 프레임워크 포함)에 위임할 수 있습니다. 4개월 동안 SleepEasy의 MVP를 개발한 결과, 프로젝트에 총 16줄의 JavaScript가 사용되었습니다.</p>

<p>더 적은 수의 기술만 익히면 된다는 구체적인 이점 외에도, 개발의 대부분을 한 곳(이 경우에는 백엔드)에 집중할 수 있다는 점이 얼마나 좋은지 아무리 강조해도 지나치지 않습니다. 클라이언트 측 JavaScript, REST API, 백엔드 간의 상호 작용에 대해 생각해야 한다는 것은 마치 태어날 때부터 무거운 조끼를 입은 것과 같았습니다. 부담스럽다고 생각하지는 않았지만 조끼를 벗고 나니 마치 공기 위를 걷는 것 같은 기분이 들었습니다.</p>

<h3 id="building-more-of-the-stack-into-the-platform-itself">플랫폼 자체에 더 많은 스택을 구축하기</h3>

<p>엘릭서는 라이브뷰 외에도 비슷한 스택 축소 이점을 제공합니다. 다른 에코시스템에서는 볼트로 고정해야 하는 많은 동시성 및 내결함성 도구에 대한 기본 지원을 제공합니다.</p>

<ul>
  <li>Elixir의 내결함성 기본 요소( <a href="https://hexdocs.pm/elixir/main/supervisor-and-application.html">프로세스 격리 및 감독 트리 모델</a>)는 전체 서비스 수준에서 크래시 복구의 필요성을 제거합니다.</li>
  <li>Erlang의 ETS 테이블은 대부분의 앱이 Redis에서 필요로 하는 인메모리 캐싱 기능을 제공하지만 별도의 서비스를 스핀업할 필요 없이(그리고 이와 같은 분산 시스템에서 문제가 발생할 수 있는 모든 것을 처리할 필요 없이) 제공합니다.</li>
  <li>Phoenix PubSub는 RabbitMQ와 같은 것을 대체할 수 있는 인메모리 메시지 큐를 제공합니다.</li>
  <li>동시성을 고려한 플랫폼의 세심한 설계로 단일 프로세스로 인해 나머지 시스템의 리소스가 고갈되는 것을 방지하므로 단일 시스템에서 수천 개의 동시 요청이 서로 충돌할 염려 없이 처리할 수 있습니다.</li>
</ul>

<h3 id="building-more-of-the-stack-using-tools-you-already-know">이미 알고 있는 도구를 사용하여 더 많은 스택 구축</h3>

<p>마지막으로 Elixir는 이미 알고 있는 도구를 기반으로 에코시스템을 구축하여 애플리케이션을 간소화합니다. 조금 이상하게 들리겠지만 작업 대기열 시스템을 생각해 보세요. Elixir가 백그라운드 작업을 처리하는 방식은 크게 두 가지입니다:</p>

<ul>
  <li>하나는 BEAM에 내장된 간편한 동시성 모델을 사용하는 것입니다(보통 <a href="https://hexdocs.pm/elixir/Task.html">Task를</a> 통해 또는 우회적인 방법으로 <a href="https://hexdocs.pm/elixir/main/genservers.html">GenServer를</a> 통해). 이는 서버 재부팅에 대해 강력할 필요가 없는 모든 임시 작업에 적합합니다.</li>
  <li>다른 하나는 Ruby의 Sidekiq와 비슷한 <a href="https://github.com/sorentwo/oban">Oban이라는</a> 라이브러리를 사용하는 것입니다.</li>
</ul>

<p>Oban은 Redis에 의해 지원되는 Sidekiq 및 유사한 시스템과 달리 Postgres(또는 SQLite를 사용하는 경우)에서 실행됩니다. 따라서 SQL 데이터베이스를 이미 알고 있어야 하므로 배워야 하는(그리고 배포하고 관리해야 하는!) 기술의 수가 한 가지 줄어듭니다.</p>

<p>Elixir는 이러한 방식으로 배포 모델도 간소화했습니다. 앞서 말씀드린 환상적인 동시성 모델 덕분에 Elixir는 시스템의 CPU 코어 수와 RAM 용량을 늘릴 때 매우 잘 확장됩니다. 이렇게 수직적으로 확장하는 것은 애플리케이션을 실행하는 더 많은 시스템으로 확장하는 것보다 훨씬 쉬우며, 향후 모든 개발에 걸림돌이 되는 분산 시스템 문제를 피할 수 있기 때문에 마이크로서비스로 확장하는 것보다 <em>훨씬</em> 쉽습니다. 더 큰 시스템을 위해 조금 더 많은 비용을 지불하는 대신 코드 변경이나 추가 테스트가 전혀 필요하지 않으니 분산 시스템 스케일아웃에 대해 말할 수 있는 것이 없습니다! (추가 혜택으로, 단일 데이터베이스와 통신하는 단일 모놀리스를 배포하는 것은 매우 저렴합니다!).</p>

<p>Elixir 스택이 여러분이 이미 알고 있는 도구에서 더 많은 스택을 구축하는 마지막 영역은 테스트에 관한 것입니다. ExUnit은 <em>놀랍고</em> 그 가독성에 대해 며칠 동안 찬사를 보낼 수 있지만(언어와 함께 제공되는 테스트 도구를 전체 커뮤니티가 사용하는 다른 에코시스템이 얼마나 될까요?), Elixir에 단위 테스트 프레임워크가 있다는 사실은 그렇게 놀랍지 않습니다. 놀라운 것은 LiveView에 대한 테스트 스토리입니다.</p>

<p>라이브뷰를 사용하면 백엔드에서 프론트엔드 인터랙티브를 구축할 수 있다는 점을 기억하시나요? 또한 본질적으로 느리고 불완전한 브라우저 자동화 대신 ExUnit에서 프론트엔드 상호 작용에 대한 <em>테스트를</em> 작성할 수 있습니다. "이 양식 필드를 채우고 이 버튼을 클릭하면 제목이 _______ 인 페이지로 리디렉션되어야 한다"와 같은 어설션을 작성할 수 있습니다. 이러한 통합 테스트를 작성하는 데 드는 비용(런타임, 개발 시간, 인지 부하 및 일반적인 골치 아픈 요소)은 비즈니스 로직에서 순수한 함수를 테스트하는 것과 거의 비슷하며, React SPA를 작성할 때보다 <em>훨씬</em> 더 많은 테스트를 작성하게 됩니다. 무언가를 두 번 이상 수동으로 테스트해야 한다면 통합 테스트가 될 것입니다.</p>

<h3 id="whats-it-add-up-to">그게 무슨 의미가 있을까요?</h3>

<p>풀스택 개발자가 알아야 할 기술의 원래 목록으로 돌아가서 여기서 설명한 Elixir 스택으로 얼마나 많은 기술을 대체하거나 제거할 수 있는지 살펴봅시다. 제 계산으로는 웹 앱에 합리적으로 필요할 것으로 예상되는 23가지에서 8가지로 줄었습니다(Elixir에 내장된 모든 것을 학습해야 할 기술 중 하나로 간주하고 Phoenix에 내장된 모든 것을 다른 기술로 간주합니다):</p>

<ol>
  <li>Elixir(내결함성을 위한 감독 트리, <code translate="no">Task</code> 와 같은 동시성 프리미티브, 캐싱을 위한 ETS 포함)</li>
  <li>Phoenix(LiveView 및 PubSub 포함)</li>
  <li>강력한 백그라운드 작업을 위한 Oban</li>
  <li>Postgres</li>
  <li>원하는 PaaS(저는 Heroku와 유사한 자체 호스팅 PaaS인 Dokku를 선호하고, 다른 분들은 Render, Fly.io 또는 Gigalixir를 선호합니다)</li>
  <li>HTML</li>
  <li>CSS</li>
  <li>Tailwind</li>
</ol>

<p>Elixir를 사용하게 되면 이러한 기술의 절반 정도만 익히게 된다는 점을 고려하면 나쁘지 않은 수준입니다.</p>

<p>풀스택 개발자가 처리해야 할 것으로 예상되는 각 항목에 대한 Elixir 에코시스템의 완전한 분석은 <a href="#appendix-breakdown-of-elixirs-answer-for-common-web-dev-requirements">아래 부록을</a> 참조하세요.</p>

<h2 id="a-few-other-accelerators-for-saas-startups">SaaS 스타트업을 위한 몇 가지 다른 액셀러레이터</h2>

<p>위에서 설명한 스택을 사용하면 B2B SaaS 앱의 95%를 구축할 수 있으며, 다른 어떤 에코시스템보다 더 빠르고 안정적으로 구축할 수 있습니다. 하지만 Elixir 생태계에는 부트스트랩 스타트업에 매우 적합한 몇 가지 영역이 더 있으며, 이를 강조하지 않는다면 아쉬울 것입니다.</p>

<h3 id="buying-a-200-hour-head-start">200시간 먼저 시작하기</h3>

<p>첫 번째는 <a href="https://docs.petal.build/petal-pro-documentation/">Petal Pro 프레임워크입니다</a>. "Petal"에는 PETAL 스택에 대한 참조가 있습니다: 피닉스, 엘릭서, 테일윈드, 알파인 JS, 라이브뷰입니다. (멋진 약자이지만, 2022년에 LiveView( <code translate="no">LiveView.JS</code> )가 도입된 이후로는 알파인 없이도 모달의 가시성 토글과 같은 순전히 클라이언트 측 상호작용을 처리할 수 있습니다.)</p>

<p>Petal Pro는 모든 SaaS 앱에 절대적으로 필요하거나 모니터링, 디버깅 및 지원 제공에 <em>매우</em> 유용한 <em>수많은</em> 기능을 구현하는 데 있어 유리한 출발점을 제공합니다. 저는 과거에 이러한 기능을 대부분 처음부터 구축해 본 적이 있는데, 모두 완벽하게 구현할 수 있지만 시간이 걸립니다. 300달러를 투자하고도 다시 <em>고민할</em> 필요가 없다는 것은 정말 대단한 일입니다.</p>

<p>시간을 크게 절약할 수 있는 몇 가지 기능을 소개합니다:</p>

<ul>
  <li>구독 과금을 위한 Stripe 통합</li>
  <li>사용자가 그룹화할 수 있는 조직(조직 초대장 보내기 및 수락 포함)</li>
  <li>관리자 대시보드(그리고 이전에는 <em>며칠이</em> 걸렸던 새 대시보드 보기를 한 시간 만에 만들 수 있는 자체 관리자 대시보드 구축용 툴킷)</li>
  <li>사용자 사칭, 사용자가 문제를 보고할 때 로그인하여 정확히 무엇을 보고 있는지 확인할 수 있습니다.</li>
  <li>페이지 레이아웃, 메뉴, 모든 것을 위한 어두운 모드 지원이 포함된 멋지게 디자인된 라이브 뷰 구성 요소 라이브러리</li>
</ul>

<h3 id="consuming-openapi-specifications-with-grace">OpenAPI 사양을 우아하게 사용</h3>

<p>다음으로, 항상 생태계 규모에 대한 우려가 있는데, Elixir의 생태계가 NPM이나 PyPI보다 훨씬 작은 것은 사실입니다. 하지만 실제로 사용해 보니 패키지 에코시스템의 구멍이 그리 나쁘지 않다는 것을 알게 되었습니다. 서드파티 서비스의 REST 엔드포인트 몇 개만 있으면 이러한 통합을 작성하는 것은 어렵지 않습니다. (저는 종속성에 대한 자체 구현을 작성하는 것이 권장될 뿐만 아니라 종종 가장 쉬운 경로인 C++에서 이빨을 깎았습니다!). 하지만 거대한 타사 API와의 긴밀한 통합이 필요한 경우에는 시작이 쉽지 않을 수 있습니다.</p>

<p>바로 이런 경우에 AJ Foster의 <a href="https://github.com/aj-foster/open-api-generator"><code translate="no">open-api-generator</code></a> 가 등장합니다. 대부분의 OpenAPI 생성기와 달리 자동 생성된 코드를 심층적으로 사용자 정의하여 인체공학적인 Elixir API를 생성할 수 있는 방법을 제공합니다. 써드파티를 위해 OpenAPI 사양을 소비하고 대량으로 토해내는 대신(사람이라면 절대 손으로 만들지 않을 엉터리 API를 만들 수 있음), 생성기는 다음과 같은 방법을 제공합니다:</p>

<ul>
  <li>API의 구성 요소 이름 바꾸기</li>
  <li>스키마를 모듈 네임스페이스로 그룹화</li>
  <li>거의 동일한 여러 데이터 구조를 하나로 병합하기</li>
  <li>...그리고 훨씬 더</li>
</ul>

<p><a href="https://github.com/aj-foster/open-api-github">AJ의 GitHub API 래퍼를</a> GitHub OpenAPI를 뱉어낼 때 기본적으로 제공되는 것과 비교해 보면, 밤낮을 가리지 않고... 무급 자원봉사자가 손으로 GitHub API를 래핑하려고 하면 결코 따라갈 수 없는 규모를 자랑합니다.</p>

<p>AJ는 작년 ElixirConf에서 멋진 강연을 통해 이 기능의 위력을 과시했습니다:</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/XSwxNgza7hE?si=p0xQt9Iu0LawU9_7" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>

<h3 id="maintainability-over-time">시간 경과에 따른 유지 관리 가능성</h3>

<p>마지막으로 언급하고 싶은 것은 Elixir 생태계에서 이탈이 거의 없다는 점입니다. 프레임워크에 "패치" 업데이트를 적용하는 것조차 전문가라도 <em>몇 시간</em> 동안 지루한 디버깅을 해야 하는( <a href="https://twitter.com/garybernhardt/status/1748486057920963041">최근 Gary Bernhardt가 한탄한</a> 것처럼) 다른 스택과는 완전히 대조적으로, Elixir 또는 Phoenix로 업데이트를 적용하는 것은 큰 문제가 되지 않습니다. 저처럼 경고를 오류로 간주하는 경우 몇 가지 사용 중단 등이 자주 발생하지만 대부분 쉽게 수정할 수 있습니다. 이는 제가 최근에 실시한 두 가지 설문조사에도 반영되어 <a href="#footnote-3" id="footnote-3-source">있습니다³</a>. 압도적으로 많은 사용자가 최근 1년 이내에 출시된 Elixir와 Phoenix 버전을 사용하고 있으며, 3년 이상 된 버전을 사용하는 사용자는 5% 미만입니다.</p>

<p><a href="https://x.com/TylerAYoung/status/1748423976609554728"><img src="https://www.sleepeasy.app/assets/images/elixir-versions.png" alt="Elixir versions used in production; 82.1% of poll respondents are using Elixir 1.15 or newer; 15.5% are using 1.13 or 1.14; 0.5% are using 1.11 or 1.12; 1.9% are using 1.10 or earlier"></a></p>

<p><a href="https://x.com/TylerAYoung/status/1748689778650849630"><img src="https://www.sleepeasy.app/assets/images/phoenix-versions.png" alt="Phoenix versions used in production; 78.5% of poll respondents are using Phoenix 1.7; 16.8% are using 1.6; 1.9% are using 1.5; 2.8% are using 1.4 or earlier"></a></p>

<p>Elixir와 Phoenix는 안정성을 중시하기 때문에 일반적으로 번거로움 없이 새로운 기능에 쉽게 액세스할 수 있습니다.</p>

<h2 id="wrapping-up">마무리</h2>

<p>저는 Elixir가 모든 앱에 적합한 언어라고 말할 자격이 없습니다. 저는 대기업에서 일한 적이 없고, Elixir를 사용한 경험은 주로 웹과 네트워킹에 집중되어 있습니다. <em>하지만</em> 현재 진행 중인 프로젝트와 B2B SaaS를 구축하는 1인 개발팀의 요구 사항을 고려할 때 시작 속도와 비즈니스가 어떤 방향으로 나아가든 성장하는 데 필요한 기능을 모두 제공하는 다른 스택은 없다고 생각합니다.</p>

<p>어떤 의견이든 듣고 싶습니다. <a href="https://twitter.com/TylerAYoung">Twitter</a>, <a href="https://fosstodon.org/@tylerayoung">Mastodon</a> 또는 이메일(이 도메인에서는 제 이름)로 저에게 연락해 주세요.</p>

<h2 id="appendix-breakdown-of-elixirs-answer-for-common-web-dev-requirements">부록: 부록: 일반적인 웹 개발 요구 사항에 대한 Elixir의 답변 분석</h2>



<table>
  <thead>
    <tr>
      <th>기술</th>
      <th>일반적인 방법</th>
      <th>제가 옹호하는 Elixir 방식</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HTML</td>
      <td>배워야 한다</td>
      <td>아직 배워야 합니다</td>
    </tr>
    <tr>
      <td>CSS</td>
      <td>아직 배워야 함</td>
      <td>죄송합니다, 아직 배워야 합니다</td>
    </tr>
    <tr>
      <td>Tailwind</td>
      <td>선택 사항이지만 좋습니다.</td>
      <td>선택 사항이지만 좋습니다.</td>
    </tr>
    <tr>
      <td>프런트엔드 언어</td>
      <td>자바스크립트/타입스크립트</td>
      <td>Phoenix LiveView</td>
    </tr>
    <tr>
      <td>백엔드 언어</td>
      <td>루비, 파이썬, Go</td>
      <td>Elixir</td>
    </tr>
    <tr>
      <td>프론트엔드 프레임워크</td>
      <td>React, Vue</td>
      <td>피닉스 라이브뷰</td>
    </tr>
    <tr>
      <td>프론트엔드 상태 관리 프레임워크</td>
      <td>Redux, Jotai, Vuex</td>
      <td>라이브뷰 사용 시 N/A</td>
    </tr>
    <tr>
      <td>백엔드 프레임워크</td>
      <td>Rails, Next.js, Django</td>
      <td>Phoenix LiveView</td>
    </tr>
    <tr>
      <td>REST</td>
      <td>클라이언트-서버 통신에 필요</td>
      <td>LiveView에서는 불필요 <br>(제품상의 이유로 필요한 경우 Phoenix)</td>
    </tr>
    <tr>
      <td>GraphQL</td>
      <td>클라이언트-서버 통신에 필요할 수 있음</td>
      <td>라이브뷰에서는 불필요 <br>(제품상의 이유로 필요한 경우 압생트)</td>
    </tr>
    <tr>
      <td>SQL 데이터베이스</td>
      <td>Postgres, MySQL, SQLite</td>
      <td>Postgres</td>
    </tr>
    <tr>
      <td>NoSQL 데이터베이스</td>
      <td>Mongo, CouchDB</td>
      <td>Postgres JSONB 열 또는 ETS를 사용한 인메모리 캐싱</td>
    </tr>
    <tr>
      <td>백그라운드 작업 시스템</td>
      <td>Sidekiq, Celery, BullMQ</td>
      <td>내장 <code translate="no">Task</code> 또는 Oban 라이브러리</td>
    </tr>
    <tr>
      <td>인메모리 캐시</td>
      <td>Redis</td>
      <td>ETS 또는 Cachex와 같은 ETS를 둘러싼 얇은 래퍼</td>
    </tr>
    <tr>
      <td>서비스 충돌 복구 시스템</td>
      <td>PM2, Upstart</td>
      <td>수퍼바이저 트리를 통한 기본 제공 장애 복구</td>
    </tr>
    <tr>
      <td>메시지 큐</td>
      <td>RabbitMQ, Redis</td>
      <td>Phoenix PubSub</td>
    </tr>
    <tr>
      <td>웹 서버</td>
      <td>Nginx, Apache, Gunicorn</td>
      <td>Phoenix</td>
    </tr>
    <tr>
      <td>컨테이너화</td>
      <td>Docker</td>
      <td>컨테이너(또는 베어 바이너리 릴리스 배포)를 통해 추상화하는 Render, Fly.io, Gigalixir 또는 Dokku와 같은 PaaS</td>
    </tr>
    <tr>
      <td>컨테이너 오케스트레이션</td>
      <td>Kubernetes</td>
      <td>PaaS 또는 베어메탈 배포</td>
    </tr>
    <tr>
      <td>클라우드 플랫폼</td>
      <td>AWS, GCP, Azure</td>
      <td>PaaS 또는 베어메탈 배포</td>
    </tr>
    <tr>
      <td>서버리스</td>
      <td>AWS 람다</td>
      <td>수직 확장형 모놀리스 <br> 서버리스와 같은 확장이 정말 필요하거나 다른 하드웨어에서 기능을 원활하게 실행해야 하는 경우 <a href="https://fly.io/blog/rethinking-serverless-with-flame/">FLAME</a> </td>
    </tr>
    <tr>
      <td>마이크로서비스</td>
      <td>Pain</td>
      <td>코어가 많은 모놀리스 <br> 팀 간 업무 분리를 보장해야 하는 경우 <a href="https://hexdocs.pm/boundary/readme.html">바운더리</a> </td>
    </tr>
    <tr>
      <td>서비스 확장</td>
      <td>수평적</td>
      <td>수직, 이중화 또는 다중 지역 배포가 필요한 경우 수평만 가능</td>
    </tr>
  </tbody>
</table>



<p><a href="#footnote-1-source" id="footnote-1">¹</a> "BEAM"은 Elixir가 구축된 Erlang 가상 머신의 이름이며, OTP("오픈 텔레콤 플랫폼")는 프로세스 격리, 네트워킹, 분산 컴퓨팅 등을 위한 핵심 Erlang 추상화 및 라이브러리의 집합입니다.</p>

<p>Phoenix는 StackOverflow의 개발자 설문조사에서 2년 연속<a href="https://survey.stackoverflow.co/2022/#section-most-loved-dreaded-and-wanted-web-frameworks-and-technologies">(2022년</a>, <a href="https://survey.stackoverflow.co/2023/#section-admired-and-desired-web-frameworks-and-technologies">2023년</a>) "가장 사랑받는 웹 프레임워크"로 선정되었습니다.</p>

<p>과학적이지 않다는 점은 인정하지만 Elixir 설문조사에 200명 이상의 응답자가, Phoenix 버전에 100명 이상의 응답자가 참여했으니 생태계에 대한 합리적인 스냅샷처럼 보입니다.</p>

    </div></div>
	      </article>
			</main>
    </body>
  </html>
  